```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

### Linked Lists. Iteration, DFS


```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
        
x= ListNode(2)
l = []
l.append(x)
l[0].val

x.val = 3
l[0].val
```




    2






    3



### Iteration-Pointer. O(N) O(1). O(N) O(N) if creates new ListNode


## Middle Point


```python
slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    
# 1 - 2 - 3 - 4
#         ^
```


```python
new = ListNode(0)
new.next = head

slow = fast = new
# ÊâæÂà∞‰∏≠Èó¥ËäÇÁÇπ
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    
# 1 - 2 - 3 - 4
#     ^
```


```python
slow = fast = head 
while fast.next and fast.next.next:
    slow = slow.next
    fast = fast.next.next
    
# 1 - 2 - 3 - 4
#     ^
```

## 206. (10) Reverse Linked List (Iteration-Pointers, Recursion) (Amazon 24, Microsoft 9, Google 7)

O(N)  
O(1)


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:        
    def reverseList(self, head):  # Iterative
        if not head:
            return
        
        new = None
        while head:
            p = head.next
            head.next = new
            new = head
            head = p
        return new

class Solution:        
    def reverseList(self, head):  # Iterative
        if not head:
            return 
        
        p = head
        new = None
        while p:
            p = p.next
            head.next = new
            new = head
            head = p
        return new
```


```python
# O(N)
# O(N)
class Solution:
    def reverseList(self, head): # Recursive
        """
        :type head: ListNode
        :rtype: ListNode
        """
        def recursive(head, new):
            if not head:
                return new
            
            nxt = head.next
            head.next = new
            
            return recursive(nxt, head)

        return recursive(head, None)
```

## 92. (2) Reverse Linked List II (Pointers-Iteration) (Microsoft 4, Amazon 4)


```python
class Solution:
    def reverseBetween(self, head, m, n):
        """
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """
        def reverse(head, end):
            new = None
            while head != end:
                p = head.next
                head.next = new
                new = head
                head = p
            return new

        if not head:
            return 

        if not head.next:
            return head

        if m == n:
            return head

#         if not head.next.next:
#             p = head.next
#             p.next = head
#             head.next = None
#             return p

        p = ListNode(0)
        p.next = head
        left = right = head

        for i in range(m - 1):
            left = left.next
            p = p.next

        for i in range(n):
            right = right.next

        if m == 1 and not right:
            return reverse(left, right)

        if m == 1 and right:
            new = reverse(left, right)
            head.next = right
            return new

#         if m != 1 and not right:
#             new = reverse(left, right)
#             p.next = new
#             return head

        new = reverse(left, right)       
        p.next = new
        left.next = right
        return head
```


```python
# 1 2 3 4 5
# 1 3 2 4 5
# 1 4 3 2 5
```


```python
class Solution:
    def reverseBetween(self, head, m, n):
        """
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """
        
        if not head:
            return 
        
        new = ListNode(0)
        new.next = head
        
        left = new
        for i in range(m-1):
            left = left.next
        
        right = left.next
        for i in range(n-m):
            p = right.next
            right.next = p.next
            p.next = left.next
            left.next = p
        return new.next
```

## 83. Remove Duplicates from Sorted List (Pointers-Iteration) (Amazon 6, Microsoft 2)
O(N)  
O(1)


```python
class Solution:
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return
        
        p = head
        while p and p.next:
            if p.val == p.next.val:
                p.next = p.next.next
                
            else:
                p = p.next
                
        return head
```


```python
class Solution:
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        
```

## 141. Linked List Cycle (Pointers-Iteration) (Amazon 6, Microsoft 2)

O(N)  
O(1)


```python
class Solution:
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        if not head or not head.next:
            return False
        
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

## 19. Remove Nth Node From End of List (Pointers-Iteration)(Amazon 11, Facebook 8, Microsoft 2)   
O(N)  
O(1)


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        if not head:
            return
        
        if not n:
            return head
        
        slow = fast = new = ListNode(0)
        new.next = head
        
        for i in range(n):
            fast = fast.next
            if not fast:
                return head
        
        while fast and fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return new.next
```

## 234. Palindrome Linked List (Pointers-Iteration) (Microsoft 6, Amazon Onsite 9)
O(N)  
O(1)


```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        fast = slow = head
        # ÊâæÂà∞‰∏≠Èó¥ËäÇÁÇπ
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        # ÁøªËΩ¨ÂêéÂçäÈÉ®ÂàÜ
        
        def reverse(head):
            new = None
            while head:
                p = head.next
                head.next = new
                new = head
                head = p 
            return new
        

        new = reverse(slow)
    
        # ÊØîËæÉÂâçÂêé‰∏§ÈÉ®ÂàÜ
        while new: # while prev and head:
            if new.val != head.val:
                return False
            new = new.next
            head = head.next
        return True
```

## (2) 328. Odd Even Linked List (Pointers-Iteration) (Microsoft 5, Amazon)
O(N)  
O(1)


```python
class Solution:
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 

        odd = head
        even = head.next
        p = even

        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next

        odd.next = p
        return head
    
1234
```


```python
class Solution:
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 

        odd = head
        even = head.next
        p = even

        while even and even.next:
            odd.next = odd.next.next
            odd = odd.next
            even.next = even.next.next
            even = even.next

        odd.next = p
        return head
```

## 142. Linked List Cycle II (In-place-pointer. Iteration-Pointers) (Microsoft 4, Amazon 2)


```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return 
        
        slow = head
        fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        
        if slow != fast:
            return 
                
        slow2 = head
        while slow != slow2:
            slow = slow.next
            slow2 = slow2.next
            
        return slow
```


```python
class Solution():
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return
        
        slow = head.next
        fast = head.next.next
    
        while fast and fast.next and slow != fast:
            slow, fast = slow.next, fast.next.next
            
        if not fast or not fast.next:
            return
        
        slow2 = head
        while slow2 != slow:
            slow, slow2 = slow.next, slow2.next
        return slow
```

## 143. Reorder List (Iteration-Pointers, Stack) (Facebook 12, Amazon 11, Microsoft 6)


```python
# 1 2 3 4 5 6 7
# 1 2 3 4
#  7 6 5
```


```python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        def reverse(head):
            if not head:
                return 
            
            new = None
            while head:
                p = head.next
                head.next = new
                new = head
                head = p
            return new

        if not head or not head.next:
            return
        
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        
        l2 = slow.next
        slow.next = None
        l2 = reverse(l2)
        
        l1 = head
        while l2:
            p = l1.next
            l1.next = l2
            l2 = l2.next
            l1.next.next = p
            l1 = p
            
        return l1
```


```python
class Solution:
    def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """
        if not head: 
            return 
        
        p = head
        stack = []
        # ÊääÊâÄÊúâËäÇÁÇπÂéãÂÖ•Ê†à‰∏≠
        while p:
            stack.append(p)
            p = p.next
        # ÈïøÂ∫¶
        n = len(stack)
        # ÊâæÂà∞‰∏≠ÁÇπÂâç‰∏Ä‰∏™‰ΩçÁΩÆ 
        count = (n - 1) // 2
        p = head
        while count:
            # ÂºπÂá∫Ê†àÈ°∂
            tmp = stack.pop()
            # ‰∏éÈìæÂ§¥ÊãºÊé•
            tmp.next = p.next
            p.next  = tmp
            # ÁßªÂä®‰∏Ä‰∏™‰ΩçÁΩÆ
            p = tmp.next
            count -= 1
        stack.pop().next = None
```


```python
class Solution():
    def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        
        array = []
        while head:
            array.append(head)
            head = head.next
            
        i = 0
        j = len(array) - 1
        while i < j:
            array[i].next = array[j]
            i += 1
            
            # ÂÅ∂Êï∞‰∏™ËäÇÁÇπÁöÑÊÉÖÂÜµÔºå‰ºöÊèêÂâçÁõ∏ÈÅá
            if i == j:
                break
                
            array[j].next = array[i]
            j -= 1
            
        array[i].next = None
```

## Partition List (Amazon 2)


```python
class Solution(object):
    def partition(self, head, x):
        """
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """
        # before and after are the two pointers used to create two list
        # before_head and after_head are used to save the heads of the two lists.
        # All of these are initialized with the dummy nodes created.
        before = before_head = ListNode(0)
        after = after_head = ListNode(0)

        while head:
            # If the original list node is lesser than the given x,
            # assign it to the before list.
            if head.val < x:
                before.next = head
                before = before.next
            else:
                # If the original list node is greater or equal to the given x,
                # assign it to the after list.
                after.next = head
                after = after.next

            # move ahead in the original list
            head = head.next

        # Last node of "after" list would also be ending node of the reformed list
        after.next = None
        # Once all the nodes are correctly assigned to the two lists,
        # combine them to form a single list which would be returned.
        before.next = after_head.next

        return before_head.next
```

## 61. Rotate List (Pointers-Iteration) (Amazon 2, Microsoft 2, Linkedin 2)

O(N)  
O(1)


```python
class Solution:
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        
        # base cases
        if not head:
            return
        if not head.next:
            return head
        
        # close the linked list into the ring
        old_tail = head
        n = 1
        while old_tail.next:
            old_tail = old_tail.next
            n += 1
        old_tail.next = head
        
        # find new tail : (n - k % n - 1)th node
        # and new head : (n - k % n)th node
        new_tail = head
        for i in range(n - k % n - 1):
            new_tail = new_tail.next
        new_head = new_tail.next
        
        # break the ring
        new_tail.next = None
        
        return new_head
```

## 160. Intersection of Two Linked List (Pointers-Iteration) (Facebook 7, Amazon 6, Microsoft 3->5)

O(m+n)  
O(1)


```python
class Solution:
    def getIntersectionNode(self, head1, head2):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        first = head1
        second = head2
        while first is not second:
            first = first.next if first else head2
            second = second.next if second else head1
            
#             p1 = p1.next if p1 else head2
#             p2 = p2.next if p2 else head1
        return first
```

‰∏§‰∏™ÈìæË°®ÁöÑÈïøÂ∫¶‰∏çÁõ∏ÂêåÊó∂ÔºåÂ¶ÇÊûúÊàë‰ª¨‰ªéÂ§¥ÂºÄÂßãÈÅçÂéÜÂà∞ËææÂ∞æÁªìÁÇπÁöÑÊó∂Èó¥Â∞±‰∏ç‰∏ÄËá¥„ÄÇÂÖ∂ÂÆûËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òËøòÊúâ‰∏Ä‰∏™Êõ¥ÁÆÄÂçïÁöÑÂäûÊ≥ïÔºöÈ¶ñÂÖàÈÅçÂéÜ‰∏§‰∏™ÈìæË°®ÂæóÂà∞ÂÆÉ‰ª¨ÁöÑÈïøÂ∫¶ÔºåÂ∞±ËÉΩÁü•ÈÅìÂì™‰∏™ÈìæË°®ÊØîËæÉÈïøÔºå‰ª•ÂèäÈïøÁöÑÈìæË°®ÊØîÁü≠ÁöÑÈìæË°®Â§öÂá†‰∏™ÁªìÁÇπ„ÄÇÂú®Á¨¨‰∫åÊ¨°ÈÅçÂéÜÁöÑÊó∂ÂÄôÔºåÂú®ËæÉÈïøÁöÑÈìæË°®‰∏äÂÖàËµ∞Ëã•Âπ≤Ê≠•ÔºåÊé•ÁùÄÂÜçÂêåÊó∂Âú®‰∏§‰∏™ÈìæË°®‰∏äÈÅçÂéÜÔºåÊâæÂà∞ÁöÑÁ¨¨‰∏Ä‰∏™Áõ∏ÂêåÁöÑÁªìÁÇπÂ∞±ÊòØÂÆÉ‰ª¨ÁöÑÁ¨¨‰∏Ä‰∏™ÂÖ¨ÂÖ±ÁªìÁÇπ„ÄÇ

## 445. Add Two Numbers II (Math, Node-Iteration, Pointers) (Microsoft 7, Amazon 7, Apple 3)
O(M+N)  
O(N)


```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """

        x1 = 0
        while l1:
            x1 = x1 * 10 + l1.val
            l1 = l1.next

        x2 = 0
        while l2:
            x2 = x2 * 10 + l2.val
            l2 = l2.next

        x = x1 + x2

        head = ListNode(0)
        tmp = head
        for c in str(x):
            tmp.next = ListNode(int(c))
            tmp = tmp.next
            
#         node_tmp = None
#         while x > 0:
#             n = x % 10
#             new_node = ListNode(n)
#             new_node.next = node_tmp
#             node_tmp = new_node
#             x = x // 10
#         return node_tmp

        return head.next
```

## 2. Add Two Numbers (Math, Pointer-Iteration. Recursion) (Amazon 50->37, Google 16, Microsoft Onsite 16, Apple 15, Facebook 7)

Êó∂Èó¥Â§çÊùÇÂ∫¶: O(N)  
Âõ†‰∏∫Êó∂Èó¥Â§çÊùÇÂ∫¶Êó†Ê≥ïÂáèÂ∞èÔºåÊàë‰ª¨‰∏ÄÂÆöÂæóÈÅçÂéÜÂÆål1Âíål2ÁöÑÊØè‰∏Ä‰ΩçÊâçËÉΩÂæóÂà∞ÊúÄÁªàÁöÑÁªìÊûúÔºåO(N)Ê≤°ÂæóÂïÜÈáè  
O(N)


```python
class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        new = ListNode(0)
        p = new
        c = 0
        
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            sums = x + y + c
            c = sums // 10
            p.next = ListNode(sums % 10)
            p = p.next
            
            if l1:
                l1 = l1.next
                
            if l2:
                l2 = l2.next
                
        if c > 0:
            p.next = ListNode(c)
                
        return new.next
```


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def addTwoNumbers(self, l1, l2, c = 0):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        
        val = l1.val + l2.val + c
        c = val // 10
        res = ListNode(val % 10)
        
        if l1.next or l2.next or c != 0:
            if not l1.next:
                l1.next = ListNode(0)
            if not l2.next:
                l2.next = ListNode(0)
                
            res.next = self.addTwoNumbers(l1.next, l2.next, c)
        return res
    
# class Solution:
#     def addTwoNumbers(self, l1, l2):
#         """
#         :type l1: ListNode
#         :type l2: ListNode
#         :rtype: ListNode
#         """     
#         # Âõ†‰∏∫Â§ÑÁêÜÂà∞ÊúÄÂêéÁöÑÊó∂ÂÄôÔºåÂèØËÉΩËæìÂÖ•ÁöÑ l1 Âíå l2 ÈÉΩ‰∏çÊòØ‰∏Ä‰∏™ ListNode ËÄåÊòØ None ‰∫Ü
#         if not l1 and not l2: 
#             return 
#         elif not (l1 and l2): # l1 Âíå l2 ÂÖ∂‰∏≠‰∏Ä‰∏™ÊòØ None 
#             return l1 or l2
#         else: # l1 Âíå l2 ÈÉΩ‰∏çÊòØ None 
#             if l1.val + l2.val < 10: # ‰∏™‰ΩçÊï∞Áõ∏Âä†Ê≤°ÊúâËøõ‰Ωç
#                 l3 = ListNode(l1.val+l2.val)
#                 l3.next = self.addTwoNumbers(l1.next, l2.next) # ÈÄíÂΩíË∞ÉÁî®
#             else: # # ‰∏™‰ΩçÊï∞Áõ∏Âä†ÊúâËøõ‰Ωç
#                 l3 = ListNode(l1.val+l2.val-10)
#                 # ÈÄíÂΩíË∞ÉÁî®ÔºåËÆ∞ÂæóÂä†‰∏äËøõ‰Ωç
#                 l3.next = self.addTwoNumbers(l1.next, self.addTwoNumbers(l2.next, ListNode(1)))
#         return l3
```


```python
%10
```




    2




```python
'0' + '1'
```




    '01'




```python
res = [1,2,3]
res.reverse()
res
```




    [3, 2, 1]



## 21. Merge Two Sorted Lists (Pointers-Iteration. Recursion) (Amazon OA 31, Microsoft 14, Facebook 5)

O(m+n)  
O(1)


```python
class Solution:
    def mergeTwoLists(self, l1, l2):
        # maintain an unchanging reference to node ahead of the return node.
        if not l1:
            return l2
        
        if not l2:
            return l1
        
        
        new = p = ListNode(0)

        while l1 and l2:
            if l1.val <= l2.val:
                p.next = l1
                p = p.next
                l1 = l1.next
            else:
                p.next = l2
                p = p.next
                l2 = l2.next            
            

        # exactly one of l1 and l2 can be non-null at this point, so connect
        # the non-null list to the end of the merged list.
        p.next = l1 or l2

        return new.next
```

O(m+n)  
O(m+n)


```python
class Solution:
    def mergeTwoLists(self, l1, l2): 
#         if not l1 or not l2:
#             return l1 or l2
        
#         if l1 == None:
#             return l2
#         elif l2 == None:
#             return l1
        
        if not l1:
            return l2
        if not l2:
            return l1
        
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
    

```


```python
l1 = ListNode(1)
l2 = ListNode(2)

s = Solution()
x = s.mergeTwoLists(l1,l2)
x.val
x.next.val
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-123-49b6632b8b78> in <module>
          6 x.val
          7 x.next.val
    ----> 8 x.next.next.val
    

    AttributeError: 'NoneType' object has no attribute 'val'



```python
# def x(l1,l2):
#     if l1 == None:
#         return l2
#     elif l2 == None:
#         return l1
    
def x(l1, l2):
    if not l1 or not l2:
        return l1 or l2

a = None
b = ListNode(1)
c = x(a,b)
print(c.val)

```

    1





    False



## 23. Merge k Sorted Lists (Pointers-Iteration. Recursion) (Amazon 36, Facebook 27, Microsoft Onsite 11) (Hard)



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# nlogk. k is number of linkedlisk
# 1
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        
        if not lists:
            return 
        
        def mergeTwoLists(l1, l2):
            if not l1:
                return l2
            if not l2:
                return l1
            
            new = p = ListNode(0)

            while l1 and l2:
                if l1.val <= l2.val:
                    p.next = l1
                    p = p.next
                    l1 = l1.next
                else:
                    p.next = l2
                    p = p.next
                    l2 = l2.next            
    
            p.next = l1 or l2
            return new.next

#             if l1.val < l2.val:
#                 l1.next = mergeTwoLists(l1.next, l2)
#                 return l1
#             else:
#                 l2.next = mergeTwoLists(l1, l2.next)
#                 return l2
        
        def merge(l, r):
            if l == r:
                return lists[l]

            m = (l+r) // 2

            l1 = merge(l, m)
            l2 = merge(m+1, r)
            return mergeTwoLists(l1, l2)
        
        return merge(0, len(lists) -1)
    
```


```python
from Queue import PriorityQueue
class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        new = tmp = ListNode(0)
        queue = PriorityQueue()
        
        for head in lists:
            if head:
                queue.put((head.val, head))
                
        while not queue.empty():
            val, head = queue.get()
            tmp.next = head
            tmp = tmp.next
            head = head.next
            if head:
                queue.put((head.val, head))
        return new.next
```


```python
O(k*n)  
O(k*n)
```


```python
from queue import PriorityQueue
q = PriorityQueue()
for n in range(3):
    q.put(n)

while not q.empty():
    x = q.get()
    print(x)
    
q.put(6)
while not q.empty():
    y = q.get()
    print(y)
```

    0
    1
    2
    6



```python
Input:
[[ 5, 12, 17, 21, 23],
 [ 1,  2,  4,  6,  8],
 [12, 14, 18, 19, 27],
 [ 3,  7,  9, 15, 25]]

Output:
[[ 1,  2,  3,  4,  5],
 [ 6,  7,  8,  9, 12],
 [12, 14, 15, 17, 18],
 [19, 21, 23, 25, 27]]
```

### DFS-Recursion. O(N) O(N)

## (5) 138. Copy List with Random Pointer (Node, Dic. DFS, Recursion) (Amazon OA 61, Microsoft Onsite 1, 10, Facebook 5)

Êó∂Èó¥Â§çÊùÇÂ∫¶: O(N)  
O(N)


```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val, next, random):
        self.val = val
        self.next = next
        self.random = random
"""
class Solution:
    """
    :type head: Node
    :rtype: Node
    """ 
    def copyRandomList(self, head):
        if not head:
            return    
        
        dic = {}
        
        def dfs(head):
            if head in dic:
                return dic[head]
            
            if not head:
                return 

            res = Node(head.val, None, None)

            dic[head] = res

            res.next = dfs(head.next)
            res.random = dfs(head.random)

            return res
        
        return dfs(head)
```


```python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return head

        # Creating a new weaved list of original and copied nodes.
        ptr = head
        while ptr:

            # Cloned node
            new_node = Node(ptr.val, None, None)

            # Inserting the cloned node just next to the original node.
            # If A->B->C is the original linked list,
            # Linked list after weaving cloned nodes would be A->A'->B->B'->C->C'
            new_node.next = ptr.next
            ptr.next = new_node
            ptr = new_node.next

        ptr = head

        # Now link the random pointers of the new nodes created.
        # Iterate the newly created list and use the original nodes random pointers,
        # to assign references to random pointers for cloned nodes.
        while ptr:
            ptr.next.random = ptr.random.next if ptr.random else None
            ptr = ptr.next.next

        # Unweave the linked list to get back the original linked list and the cloned list.
        # i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'
        ptr_old_list = head # A->B->C
        ptr_new_list = head.next # A'->B'->C'
        head_old = head.next
        while ptr_old_list:
            ptr_old_list.next = ptr_old_list.next.next
            ptr_new_list.next = ptr_new_list.next.next if ptr_new_list.next else None
            ptr_old_list = ptr_old_list.next
            ptr_new_list = ptr_new_list.next
        return head_old
```

## 24. Swap Node in PairÔºàDFS-Recursion, Iteration-Pointers) (Microsoft 5->7, Facebook 3, Amazon 4)

O(N)  
O(1)


```python
class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return
        
        if not head.next:
            return head
        
        p = head.next
        head.next = self.swapPairs(head.next.next)
        p.next = head
        return p
```


```python
class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head

        cur = dummy = ListNode(-1)
        dummy.next = head

        while cur.next and cur.next.next:
            next_one, next_two, next_three = cur.next, cur.next.next, cur.next.next.next
            cur.next = next_two
            next_two.next = next_one
            next_one.next = next_three
            cur = next_one
        return dummy.next
```


```python
class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 
        
        cur = head
        while cur and cur.next:
            tmp = cur.val
            cur.val = cur.next.val
            cur.next.val = tmp     
            cur = cur.next.next
        return head
```


```python
class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return 
        
        if head and head.next:
            temp = head.val
            head.val = head.next.val
            head.next.val = temp
            self.swapPairs(head.next.next)
        return head
```

## 25. Reverse Nodes in K-Group (Pointers-Iteration, Stack) (Amazon 6, Microsoft Onsite 1, 8)(Hard)


```python
class Solution:
    def reverseKGroup(self, head, k):
        if not head:
            return 
        
        left = right = head
        
        for i in range(k):
            if not right:
                return head
            right = right.next
        
        def reverseList(head, end):  # Iterative
            new = None
            
            while head != end:
                p = head.next
                head.next = new
                new = head
                head = p
            return new
        
        new = reverseList(left, right)
        head.next = self.reverseKGroup(right, k)
        return new
```


```python
class Solution:
    def reverseKGroup(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        
        dummy = ListNode(0)
        p = dummy
        while True:
            count = k 
            stack = []
            tmp = head
            while count and tmp:
                stack.append(tmp)
                tmp = tmp.next
                count -= 1
            # Ê≥®ÊÑè,ÁõÆÂâçtmpÊâÄÂú®k+1‰ΩçÁΩÆ
            # ËØ¥ÊòéÂâ©‰∏ãÁöÑÈìæË°®‰∏çÂ§ük‰∏™,Ë∑≥Âá∫Âæ™ÁéØ
            if count : 
                p.next = head
                break
            # ÁøªËΩ¨Êìç‰Ωú
            while stack:
                p.next = stack.pop()
                p = p.next
            #‰∏éÂâ©‰∏ãÈìæË°®ËøûÊé•Ëµ∑Êù• 
            p.next = tmp
            head = tmp
        
        return dummy.next
```


```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        cur = head
        count = 0
        while cur and count!= k:
            cur = cur.next
            count += 1
        if count == k:
            cur = self.reverseKGroup(cur, k)
            while count:
                tmp = head.next
                head.next = cur
                cur = head
                head = tmp
                count -= 1
            head = cur   
        return head
```

## 148. Sort List (Microsoft Onsite 5, Facebook 4, Amazon 3)
Merge sort


```python
class Solution:

    def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head
        
        dummy = ListNode(0)
        dummy.next = head
        
        fast = slow = dummy
        # ÊâæÂà∞‰∏≠Èó¥ËäÇÁÇπ
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        
        second = slow.next
        slow.next = None
        
        # second = self.findMid(head) # ÊâæÂà∞ÈìæË°®ÂêéÂçäÊÆµÁöÑhead
        l = self.sortList(head)
        r = self.sortList(second)
        return self.merge(l, r)

    def merge(self, l, r): # O(NlgN)
        if not l:
            return r
        if not r:
            return l
        
        p = head = ListNode(0)
        while l and r:
            if l.val < r.val:
                p.next = l
                p = p.next
                l = l.next
            else:
                p.next = r
                p = p.next
                r = r.next
            
        p.next = l or r # l and r at least one is None
        return head.next
```


```python
class Solution:
    def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head

        second = self.findMid(head) # ÊâæÂà∞ÈìæË°®ÂêéÂçäÊÆµÁöÑhead
        l = self.sortList(head)
        r = self.sortList(second)
        return self.merge(l, r)

    def merge(self, l, r): # O(NlgN)
        if not l:
            return r
        if not r:
            return l
        
        dummy = head = ListNode(None)
        head.next = l
        while l and r:
            if l.val < r.val:
                head.next = l
                l = l.next
            else:
                head.next = r
                r = r.next
            head = head.next
        head.next = l or r # l and r at least one is None
        return dummy.next

    def findMid(self, head):
        fast, slow = head, head 
        while fast.next and fast.next.next:
            fast = fast.next.next
            slow = slow.next
        second = slow.next
        slow.next = None
        return second
```


```python
class Solution:
    def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
    
        #use the list to solve the problem        
        list=[]
        res=head
        while res:
            list.append(res.val)
            res=res.next
        
        list.sort()
        res = head
        #Following is important
        for part in list:
            res.val=part
            res=res.next
        return head
```

### (33) Binary Tree. DFS, BFS, Iteration
‰∏ÄÂè•ËØùÔºåÁúãÂà∞Ê†ëüå≤Â∞±Ë¶ÅÊÉ≥Âà∞ÈÄíÂΩí


```python
class Tree:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        
root = Tree(5)

if not isinstance(root, Tree):
    raise('input')
```

### DFS-Recursion. O(N) O(N). Pre. In. Post

## 144. Binary Tree Preorder Traversal (BT. Recursion-DFS, Queue-BFS) (Google 2)
O(N)  
O(N)


```python
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        res = []
        
        def dfs(root):
            if not root:
                return
            
            res.append(root.val)
            dfs(root.left)
            dfs(root.right)
            
        dfs(root)
        return res
```


```python
# O(2^n-1)
# O(logn)
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        stack = []
        
        p = root
        
        while p or stack:
            if p:
                stack.append(p)
                res.append(p.val)
                p = p.left
                
            else:
                root = stack.pop()
                p = root.right
                
        return res
```


```python
# O(2^n-1)
# O(logn)
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        stack = []
        
        tree = root
        
        while tree or stack:
            while tree:
                res.append(tree.val)
                stack.append(tree)
                tree = tree.left
                
            if stack:
                tree = stack.pop()
                tree = tree.right
                
        return res
```

ÂâçÂ∫èÈÅçÂéÜÁöÑÈ°∫Â∫è‰∏∫Ê†π-Â∑¶-Âè≥ÔºåÂÖ∑‰ΩìÁÆóÊ≥ï‰∏∫Ôºö

ÊääÊ†πËäÇÁÇπpushÂà∞Ê†à‰∏≠  
Âæ™ÁéØÊ£ÄÊµãÊ†àÊòØÂê¶‰∏∫Á©∫ÔºåËã•‰∏çÁ©∫ÔºåÂàôÂèñÂá∫Ê†àÈ°∂ÂÖÉÁ¥†Ôºå‰øùÂ≠òÂÖ∂ÂÄº  
ÁúãÂÖ∂Âè≥Â≠êËäÇÁÇπÊòØÂê¶Â≠òÂú®ÔºåËã•Â≠òÂú®ÂàôpushÂà∞Ê†à‰∏≠  
ÁúãÂÖ∂Â∑¶Â≠êËäÇÁÇπÔºåËã•Â≠òÂú®ÔºåÂàôpushÂà∞Ê†à‰∏≠„ÄÇ  


```python
class Solution():
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        stack = [root]
        res = []
        
        while stack:
            root = stack.pop()

            res.append(root.val)
            if root.right:
                stack.append(root.right)
            if root.left:
                stack.append(root.left)
        
        # see flatten bt to ll
        return res
```

## 94. Binary Tree Inorder Traversal (BT, Recursion-DFS) (Facebook 4, Microsoft 4)

O(N)  
O(N)


```python
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        
        def dfs(root):
            if not root:
                return
            
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)
            
        dfs(root)
        return res
```


```python
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        stack = []
        
        def left_node(node):
            while node:
                stack.append(node)
                node = node.left
        
        left_node(root)
        
        while stack:
            node = stack.pop()   
            
            res.append(node.val)
        
            if node.right:
                left_node(node.right)
                
        return res
```


```python
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        stack = []
        
        p = root
        
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                node = stack.pop()   
                res.append(node.val)
                p = node.right
                
        return res
```


```python
# buggy
class Solution:
    def inorderTraversal(self, root, value):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        
        def dfs(root):
            if not root:
                return
            
            dfs(root.left)
            
            if root.val <= value:
                if not root.left and not root.right:
                    root = None
            
            dfs(root.right)
            
        dfs(root)
        return res
```

## Morris Inorder Transversal


```python
# A binary tree node
class Node:
    # Constructor to create a new node
    def __init__(self, val):
        self.val = val 
        self.left = None
        self.right = None
```

Initialize the root as the current node curr.

While curr is not NULL, check if curr has a left child.

If curr does not have a left child, print curr and update it to point to the node on the right of curr.

Else, make curr the right child of the rightmost node in curr's left subtree.

Update curr to this left node.


```python
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        # Set current to root of binary tree
        current = root
        
        res = []
        while current:
            
            if not current.left:
                res.append(current.val)
                current = current.right
        
            else:
                #Find the inorder predecessor of current
                pre = current.left
                while pre.right and pre.right != current:
                    pre = pre.right
                
                # Make current as right child of its inorder predecessor
                if not pre.right:
                    pre.right = current
                    current = current.left
                    
                # Revert the changes made in if part to restore the 
                # original tree i.e., fix the right child of predecssor
                # fix the right child of prev
                else:
                    pre.right = None
                    res.append(current.val)
                    current = current.right
                    
        return res
```


```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        result = []
        
        while root:
            if root.left:  # There's a left child, need to do some work | Figure out the right most node on the left side of root, and connect it to the root. Why? Because that right-most-guy is the immediate predecessor of the root (Inorder traversal)
                node = root.left
                
                while node.right and node.right!=root:  # There are only two ways where this while loop can break, A) none, or B) You see that there is a loop in your tree! 
                    node = node.right
                    
                if not node.right:   
				    """This is our boy, connect him to root"""
                    node.right = root
                    root = root.left  """Continue to the left branch of the root"""
                else:  """node.right === root | Darn, loop in our tree, remove the connection, deal with root, and proceed to right of root"""
                    result.append(root.val)
                    root = root.right
                
            else:  # no right child, easy peasy, deal with root, and proceed to root's right side
                result.append(root.val)
                root = root.right
                
        return result
```


```python
""" 
Constructed binary tree is
            1
          /   \
        2      3
      /  \
    4     5
"""
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
 
MorrisTraversal(root)
```




    ' \nConstructed binary tree is\n            1\n          /           2      3\n      /      4     5\n'



    4
    2
    5
    1
    3


## 145.¬†Binary Tree Postorder Traversal (Facebook 2)


```python
from collections import deque
class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        stack = []
        res = deque()
        
        p = root
        
        while p or stack:
            if p:
                stack.append(p)
                res.appendleft(p.val)
                p = p.right
                
            else:
                node = stack.pop()
                p = node.left
                
        return res
```


```python
class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        stack = [root]
        res = []
        
        while stack:
            root = stack.pop()
            res.append(root.val)
            
            if root.left:
                stack.append(root.left)
                
            if root.right:
                stack.append(root.right)
                
        return res[::-1]
```

## 112. Path Sum (BT. DFS-Recursion) (Amazon 6)
O(N)  
O(N)


```python
class Solution:
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        
        if not root:
            return False
        
        def dfs(root, val = 0):             
            if not root:
                return False

            val += root.val
            
            if not root.left and not root.right:
                if val == sum:
                    return True
                else:
                    return False
                
            return dfs(root.left, val) or dfs(root.right, val)
        
        return dfs(root)
```

## 113. Path Sum II (BT, Recursion-DFS) (Amazon Onsite 5, Facebook 2, Google 2)


```python
class Solution:
    def pathSum(self, root, sums):
        
        res = []
        
        def dfs(root, val=[]):             
            if not root:
                return 

            val.append(root.val)
            
            if not root.left and not root.right:
                if sum(val) == sums: 
                    res.append(val.copy())
                
#             if root.left:
            dfs(root.left, val) 
#             if root.right:
            dfs(root.right, val)
            # return dfs(root.left, val) or dfs(root.right, val)
        
            val.pop()
        
        dfs(root)
        return res
        
# class Solution:
#     def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
#         results = []
#         def dfs(node, s, stack):
#             if node is None:
#                 return
#             stack.append(node.val)
#             if node.left is None and node.right is None:
#                 if s == node.val:
#                     results.append(stack.copy())
#             if node.left:
#                 dfs(node.left, s - node.val, stack)
#             if node.right:
#                 dfs(node.right, s - node.val, stack)
#             stack.pop()
#         dfs(root, sum, [])
#         return results 
```

## 545. Boundary of Binary Tree (BT. DFS-Recursion) (Amazon 10, Microsoft 3)


```python
class Solution:
    def boundaryOfBinaryTree(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        def leftdfs(node, leftbd):
            if not node:
                return
            
            if not node.left and not node.right:
                res.append(node.val)
                return
            
            if leftbd:
                res.append(node.val)
                 
            leftdfs(node.left, leftbd and node.left)
            leftdfs(node.right, leftbd and not node.left)
                
        def rightdfs(node, rightbd):
            if not node:
                return
            
            if not node.left and not node.right:
                res.append(node.val)
                return
                        
            rightdfs(node.left, rightbd and not node.right)
            rightdfs(node.right, rightbd and node.right)
            
            if rightbd:
                res.append(node.val)  
        
        res = [root.val]
        
        leftdfs(root.left, True)
        rightdfs(root.right, True)
        
        return res
```


```python
class Solution:
    def boundaryOfBinaryTree(self, root):
        """
        input: TreeNode
        output: List[int]
        """
        
        if not root:
            return []
        
        def dfs(node, leftbd, rightbd):
            if not node:
                return
            
            if not node.left and not node.right:
                res.append(node.val)
                return
            
            if leftbd:
                res.append(node.val)
                
            dfs(node.left, leftbd and node.left, rightbd and not node.right)
            dfs(node.right, leftbd and not node.left, rightbd and node.right)
            
            if rightbd:
                res.append(node.val)
        
        res = [root.val]
        
        dfs(root.left, True, False)
        dfs(root.right, False, True)
        
        return res
```

## 100. Same Tree (BT, Recursion-DFS) (Amazon 5, Microsoft 2, Google 2)
O(N)  
O(logN) ~ O(N)


```python
class Solution:
    def isSameTree(self, root1, root2):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """    
        # p and q are both None
        if not root1 and not root2:
            return True
        # one of p and q is None
#         if not root1 and root2 or root1 and not root2:
#             return False
        # same as above but simplified
        if not root1 or not root2:
            return False
        
        if root1.val != root2.val:
            return False
        
        return self.isSameTree(root1.left, root2.left) and self.isSameTree(root1.right, root2.right)
```


```python
class Solution:
    def isSameTree(self, p, q):
         """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """  
        queue = [(p, q)]
        while queue:
            node1, node2 = queue.pop(0)
            if not node1 and not node2:
                continue
                
            elif not node1 or not node2:
                return False
            
            else:
                if node1.val != node2.val:
                    return False
        
                queue.append((node1.left, node2.left))
                queue.append((node1.right, node2.right))
                    
        return True
```


```python
from collections import deque
class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """    
        if not p and not q:
            return True
        
        if not p or not q:
            return False
        
        def check(p, q):
            # if both are None
            if not p and not q:
                return True
            # one of p and q is None
            if not q or not p:
                return False
            if p.val != q.val:
                return False
            return True
        
        deq = deque([(p, q),])
        while deq:
            p, q = deq.popleft()
            if not check(p, q):
                return False
            
            if p:
                deq.append((p.left, q.left))
                deq.append((p.right, q.right))
                    
        return True
```

## 101. Symmetric Tree (BT, Recursion-DFS) (Amazon 6, Google 5)

O(N)  
O(N)


```python
class Solution:
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
        
        def divide_conquer(root1, root2):
            if not root1 and not root2:
                return True
            
            if not root1 and root2 or root1 and not root2:
                return False
        
            if root1.val != root2.val:
                return False
            # root1 == root2
            return divide_conquer(root1.left, root2.right) and divide_conquer(root1.right, root2.left)
        
        return divide_conquer(root.left, root.right)
```

## 572. Subtree of Another Tree (BT, Recursion-DFS) (Amazon OA 80, Microsoft Onsite 5)  


```python
class Solution:
    def isSubtree(self, root1, root2):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        
        if not root1 and not root2:
            return False
        
        if not root1 or not root2:
            return False
        
        def isSame(p, q):
            if not p and not q:
                return True
            if not p and q or p and not q:
                return False
            if p.val != q.val:
                return False
            return isSame(p.left,q.left) and isSame(p.right,q.right)
            
        if isSame(root1, root2):
            return True
             
        return self.isSubtree(root1.left, root2) or self.isSubtree(root1.right, root2)
```

## 250. Count Univalue Subtrees


```python
class Solution:
    def countUnivalSubtrees(self, root: TreeNode) -> int:
        def isUnivalue(root):
            l, r = True, True
            
            if root.left:
                if not isUnivalue(root.left) or root.left.val != root.val:
                    l = False
            if root.right:
                if not isUnivalue(root.right) or root.right.val != root.val:
                    r = False
                    
            self.res += l and r
            
            return l and r    
        
        if not root:
            return 0
        
        self.res = 0
        isUnivalue(root)
        return res
```

## ? Find Subtree that has same values


```python
def solution(root):
    if not root:
        return

    def dfs(root, root.left, root.right):
        if not root.left and not root.right:
            return True
        
        if not root.left or not root.right:
            if root.left.val != root.val or root.right.val != root.val:
                return False
            
            else:
                return True
        
        if root.left.val != root.right.val:
            return False
        
        return dfs(root.left, root.left.left, root.left.right) and dfs(root.right, root.right.left, root.right.right)
        
    
    if dfs(root, root.left, root.right):
        return root
        
    return solution(root.left) or solution(root.right)
    
```

## 951. Flip Equivalent Binary Trees (BT, Recursion-DFS) (Google 5)

O(min(len(root1), len(root2)))  
O(min(height(root1, height)root2))


```python
class Solution:
    def flipEquiv(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: bool
        """

        if not root1 and not root2:
            return True
        if not root1 and root2 or root1 and not root2:
            return False
        if root1.val != root2.val:
            return False

        return (self.flipEquiv(root1.left, root2.left) and
                self.flipEquiv(root1.right, root2.right) or
                self.flipEquiv(root1.left, root2.right) and
                self.flipEquiv(root1.right, root2.left))
```

## 104. Maximum Depth of Binary Tree (BT, Recursion-DFS) (Linkedin 5)

O(N)  
O(N)

Time complexity : we visit each node exactly once, thus the time complexity is O(N), where N is the number of nodes.

Space complexity : in the worst case, the tree is completely unbalanced, e.g. each node has only left child node, the recursion call would occur N times (the height of the tree), therefore the storage to keep the call stack would be O(N). But in the best case (the tree is completely balanced), the height of the tree would be log(N). Therefore, the space complexity in this case would be O(log(N))


```python
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if not isinstance(root, Tree):
            raise Exception('Invalid input')
            
        
        def divide_conquer(root):
            if not root:
                return 0
            
            left = divide_conquer(root.left) 
            right = divide_conquer(root.right) 
            return 1 + max(left, right) 
        
        return divide_conquer(root)
```


```python
a = []
sum(a)
```




    0



## 111. Minimum Depth of Binary Tree (BT, Recursion-DFS, Queue-BFS) (Facebook 7)


```python
class Solution:
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if not isinstance(root, Tree):
            raise Exception('Invalid input')
            
        def divide_conquer(root):
            if not root: 
                return 0 

            if not root.left and not root.right:
                return 1

            if root.left and not root.right:
                return 1 + divide_conquer(root.left)

            if not root.left and root.right:
                return 1+ divide_conquer(root.right)

            # Other cases
            left = divide_conquer(root.left) 
            right = divide_conquer(root.right) 
            return 1 + min(left, right) 
        
        return divide_conquer(root)
```


```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        queue = [root]
        depth = 1
        
        while queue:
            for i in range(len(queue)):
                cur = queue.pop(0)
                
                if not cur.left and not cur.right:
                    return depth
                
                if cur.left:
                    queue.append(cur.left)
                    
                if cur.right:
                    queue.append(cur.right)
                    
            depth += 1
            
            
        return depth
```

## 110 Balanced Binary Tree (BT, Recursion-DFS) (Amazon 4, Microsoft 4->2)


```python
class Solution:
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not isinstance(root, Tree):
            raise Exception('Invalid input')
        
        def depth(node):
            if not node:
                return 0
            
            left = depth(node.left)
            right = depth(node.right)
            return 1 + max(left, right)
        
        def divide_conquer(root):
            if not root:
                return True

            if abs(depth(root.left) - depth(root.right)) > 1:
                return False

            return divide_conquer(root.left) and divide_conquer(root.right)
        
        return divide_conquer(root)
```

## 543. Diameter of Binary Tree (BT, Recursion-DFS) (Facebook 34, Amazon 14, Microsoft 5)

O(N)  
O(N)


```python
class Solution:
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        
        def depth(root):
            if not root: 
                return 0
            
            left = depth(root.left)
            right = depth(root.right)
            self.res = max(self.res, left + right)
            return 1 + max(left, right) 
        
        self.res = 0
        depth(root)
        return self.res
```


```python
class Solution:
    def diameterOfBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        
        def depth(root):
            nonlocal res
            if not root: 
                return 0
            
            left = depth(root.left)
            right = depth(root.right)
            res = max(res, left + right)
            return 1 + max(left, right) 

        res = 0
        depth(root)
        return res
```

## 124. Binary Tree Maximum Path Sum (BT, Recursion-DFS) (Facebook 52, Amazon 13, Microsoft 7, Google Onsite 4) (Hard)

O(N)  
O(log(N)) ~O(N) We have to keep a recursion stack of the size of the tree height, which is O(log(N)) for the binary tree.

Algorithm
Initiate max_sum as the smallest possible integer and call max_gain(node = root).  
Implement max_gain(node) with a check to continue the old path/to start a new path:  
Base case : if node is null, the max gain is 0.  
Call max_gain recursively for the node children to compute max gain from the left and right subtrees : left_gain = max(max_gain(node.left), 0) and right_gain = max(max_gain(node.right), 0).  
Now check to continue the old path or to start a new path. To start a new path would cost price_newpath = node.val + left_gain + right_gain. Update max_sum if it's better to start a new path.  
For the recursion return the max gain the node and one/zero of its subtrees could add to the current path : node.val + max(left_gain, right_gain).  



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
           
        def max_gain(root):
#             nonlocal res
            if not root:
                return 0

            # max sum on the left and right sub-trees of node
            left = max(max_gain(root.left), 0)
            right = max(max_gain(root.right), 0)
            
            # the price to start a new path where `node` is a highest node
           
            # update max_sum if it's better to start a new path
            self.res = max(self.res, root.val + left + right)
        
            # for recursion :
            # return the max gain if continue the same path
            return root.val + max(left, right)
   
        self.res = float('-inf')
        max_gain(root)
        return self.res
```


```python
s = Solution()
s.res
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-3-6fff9065502e> in <module>
          1 s = Solution()
    ----> 2 s.res
    

    AttributeError: 'Solution' object has no attribute 'res'


## 687. Longest Univalue Path (Apple 2)


```python
class Solution(object):
    def longestUnivaluePath(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.ans = 0

        def dfs(node):
            if not node: 
                return 0
            
            left_length = dfs(node.left)
            right_length = dfs(node.right)
            
            left_arrow = right_arrow = 0
            
            if node.left and node.left.val == node.val:
                left_arrow = left_length + 1
            if node.right and node.right.val == node.val:
                right_arrow = right_length + 1
                
            self.ans = max(self.ans, left_arrow + right_arrow)
            
            return max(left_arrow, right_arrow)

        dfs(root)
        return self.ans
```


```python
class Solution(object):
    def longestUnivaluePath(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def longestUnivalueDepth(root):
            if not root:
                return 0
            l_depth = longestUnivalueDepth(root.left)
            r_depth = longestUnivalueDepth(root.right)
            
            l_new_depth, r_new_depth = 1, 1
            if l_depth > 0 and root.val == root.left.val:
                l_new_depth += l_depth
            if r_depth > 0 and root.val == root.right.val:
                r_new_depth += r_depth
                
            self.res = max(self.res, l_new_depth + r_new_depth - 2)
            return max(l_new_depth, r_new_depth)
        
        self.res = 0
        longestUnivalueDepth(root)
        return self.res
```

## 298. Binary Tree Longest Consecutive Sequence (Google 2)


```python
class Solution(object):
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def longest_path(root):
            if not root:
                return 0
            length = 1
            l = longest_path(root.left)
            r = longest_path(root.right)
            if root.left and root.left.val == root.val + 1:
                length = max(length, 1 + l)
            if root.right and root.right.val == root.val + 1:
                length = max(length, 1 + r)
            self.res = max(self.res, length)
            return length
        
        self.res = 0
        longest_path(root)
        return res
```

## 549. Binary Tree Longest Consecutive Sequence II (Google 3, Facebook 2, Apple)


```python
class Solution(object):
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def longest_path(root):           
            if not root:
                return 0, 0
            
            inc, dec = 1, 1
            
            l_inc, l_dec = longest_path(root.left)
            r_inc, r_dec = longest_path(root.right)
            if root.left:
                if root.left.val == root.val + 1:
                    inc = max(inc, 1 + l_inc)
                if root.left.val == root.val - 1:
                    dec = max(dec, 1 + l_dec)
            if root.right:
                if root.right.val == root.val + 1:
                    inc = max(inc, 1 + r_inc)
                if root.right.val == root.val - 1:
                    dec = max(dec, 1 + r_dec)
            self.res = max(self.res, inc + dec - 1)
            return (inc, dec)
        
        self.res = 0
        longest_path(root)
        return self.res
```

## 1145. Binary Tree Coloring Game (Google Onsite 4, Microsoft 4)


```python
class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        left_x = 0
        right_x = 0
        
        # total count of nodes
        def dfs(root):
            nonlocal left_x, right_x
            
            if not root:
                return 0
            
            left = dfs(root.left)
            right = dfs(root.right)
            if root.val == x:
                left_x = left
                right_x = right
            return left + right + 1
        
        dfs(root)
        return max([left_x, right_x, n - 1 - left_x - right_x]) > n / 2
```


```python
class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: int) -> bool:
        
        left_x = 0 
        right_x = 0
        
        def dfs(root):
            nonlocal left_x, right_x
            
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            if root.val == x:
                left_x = left
                right_x = right
            return left + right + 1
        
        dfs(root)
        parent = n - left_x - right_x - 1
        judge = [parent, left_x, right_x]
        return any([j > n // 2 for j in judge])
```

https://leetcode.com/discuss/interview-question/294183/Google-or-Tree-Game


```python
class Solution:
    def btreeGameWinningMove(self, root: TreeNode, n: int, x: TreeNode) -> bool:
        
        self.leftcnt, self.rightcnt = 0, 0
        
        def count(self, root): # return the number of total nodes
            if not root:
                return 0

            left = self.count(root.left)
            right = self.count(root.right)
            if root.val == x.val:
                self.leftcnt = left
                self.rightcnt = right
            return left + right + 1
    

        self.parentcnt = n - self.leftcnt - self.rightcnt - 1
        
        if self.parentcnt > total_nodes // 2:
            return x.parent
        elif self.leftcnt:
            return x.left
        elif self.rightcnt:
            return x.right
        else:
            return None
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-1-3f237546b729> in <module>
    ----> 1 class Solution:
          2     def btreeGameWinningMove(self, root: TreeNode, n: int, x: TreeNode) -> bool:
          3 
          4         self.leftcnt, self.rightcnt = 0, 0
          5 


    <ipython-input-1-3f237546b729> in Solution()
          1 class Solution:
    ----> 2     def btreeGameWinningMove(self, root: TreeNode, n: int, x: TreeNode) -> bool:
          3 
          4         self.leftcnt, self.rightcnt = 0, 0
          5 


    NameError: name 'TreeNode' is not defined


## 222. Count Complete Tree Nodes (BT, Recursion-DFS, Pointer) (Google 31 Phone,Facebook 11, Apple?)  
*- Êó∂Èó¥Â§çÊùÇÂ∫¶: O(lgN * lgN)- Á©∫Èó¥Â§çÊùÇÂ∫¶: O(1)*


```python
class Solution:
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0

        p = root
        q = root

        left = 1
        right = 1
        while p.left:
            left += 1
            p = p.left
            
        while q.right:
            right += 1
            q = q.right
            
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```


```python
class Solution(object):
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        nodes = [(root, 1)]
        i = 0
        while i < len(nodes):
            node, v = nodes[i]
            i += 1
            if node:
                nodes.append((node.left, 2*v))
                nodes.append((node.right, 2*v+1))

        return  nodes[-1][1] == len(nodes)
```

Êó∂Èó¥Â§çÊùÇÂ∫¶: O(lgN * lgN)  
O(1)

Ê±ÇÂá∫Ê≠£Â∏∏ÁöÑÂ∑¶Âè≥Â≠êÊ†ëÁöÑÈ´òÂ∫¶lhÂíårhÔºåÁÑ∂Âêé

Â¶ÇÊûúÁõ∏Á≠âÁöÑËØùÂ∞±Áü•ÈÅìÂ∑¶ËæπÂ≠êÊ†ëËÇØÂÆöÊòØÊª°ÁöÑÔºå‰∏ÄÂÖ±Êúâ2 ** lh‰∏™nodeÔºåÂÖàÁÆóÂá∫Êù•ÁÑ∂ÂêéÈÄíÂΩíËÆ°ÁÆóÂè≥ËæπÂ≠êÊ†ëÁöÑnode‰∏™Êï∞Ôºõ
ÂêåÁêÜlhÂíårh‰∏çÁõ∏Á≠âÁöÑËØùÔºåÂ∞±Áü•ÈÅìÂè≥ËæπÂ≠êÊ†ëÊòØÊª°ÁöÑÔºå‰∏ÄÂÖ±Êúâ2 ** rh‰∏™nodeÔºåÂÖàÁÆóÂá∫Êù•ÁÑ∂ÂêéÈÄíÂΩíËÆ°ÁÆóÂè≥ËæπÂ≠êÊ†ëÁöÑnode‰∏™Êï∞Ôºõ


```python
class Solution:
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        
        def height(root):
            if not root:
                return 0
            
            left = height(root.left)
            right = height(root.right)
            return 1 + max(left, right)

        lh = height(root.left)
        rh = height(root.right)
        
        if lh == rh:
            return 2 ** lh + self.countNodes(root.right)
        else:
            return 2 ** rh + self.countNodes(root.left)

    
```

## Check if Node Exists in Complete Tree (Google Phone)
https://leetcode.com/discuss/interview-question/236898/Google-or-Check-if-a-node-exists-in-a-complete-tree  
Share my solution using binary string:  
Binary String represents the path from root to the node, where '1' means going right and '0' means going left.  
For example, 4 = "100", starting from the index 1, we go from root = 1, going left --> 2, going left --> 4;  
7 = "111", starting from index 1, we go from root = 1, going right --> 3, going right --> 7.  


```python
def check(root, num):
    if num <= 0:
        return False
    
    chars = bin(num)[2:]
    
    for i in range(1, len(chars)):
        if not root:
            return False
        
        if chars[i] == '0':
            root = root.left
            
        else:
            root = root.right
    
    return root != None
```


```python
bin(4)[2:]
```




    '100'



## 236. (5) Lowest Common Ancestor of a Binary Tree (BT,Recursion-DFS, Queue-BFS) (Facebook 11->24, Amazon 9-16, Microsoft Onsite 1, 8)

O(N) where N is the number of nodes in the BT. In the worst case we might be visiting all the nodes of the BT.  
O(N) This is because the maximum amount of space utilized by the recursion stack would be N since the height of a skewed BT could be N.


```python
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return
        
        if root.val == p.val or root.val == q.val:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        
        # if not left and not right:
        #     return 
        
        if left and right:
            return root
        
        if left:
            return left
        if right:
            return right
        
#         if not left and not right:
#             return
```


```python
class Solution:

    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """

        # Stack for tree traversal
        stack = [root]

        # Dictionary for parent pointers
        parent = {root: None}

        # Iterate until we find both the nodes p and q
        while p not in parent or q not in parent:

            node = stack.pop()

            # While traversing the tree, keep saving the parent pointers.
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)

        # Ancestors set() for node p.
        ancestors = set()

        # Process all ancestors for node p using parent pointers.
        while p:
            ancestors.add(p)
            p = parent[p]

        # The first ancestor of q which appears in
        # p's ancestor set() is their lowest common ancestor.
        while q not in ancestors:
            q = parent[q]
        return q
```

## 116. Populating Next Right Pointers in Each Node I (BT. DFS-Recursion, Pointer) (Amazon 12, Microsoft 8)  
O(N)  
O(N)


```python
class Solution:
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        
        if not root:
            return
        
        if root.left and root.right:
            root.left.next = root.right  
            
            if root.next:
                root.right.next = root.next.left
            
        self.connect(root.left)
        self.connect(root.right)
        
        return root
```


```python
class Solution:
	def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        
		if not root or not root.left:
			return root
        
		root.left.next = root.right
        
		if root.next:
			root.right.next=root.next.left
            
		self.connect(root.left)
		self.connect(root.right)
		return root
```

## 226. Invert Binary Tree (BT, Recursion-DFS, Queue-BFS) (Amazon 4, Google 2)
O(N)  
O(N)


```python
class Solution:
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return 
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```


```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return
        
        queue = [root]
        while queue:
            node = queue.pop(0)
            
            node.left, node.right = node.right, node.left
            
            if node.left:
                queue.append(node.left)
                
            if node.right:
                queue.append(node.right)
                
        return root
```


```python
class Solution:
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        queue = [root]
        while queue:
            node = queue.pop(0)
            if node:
                node.left, node.right = node.right, node.left
                queue.extend([node.left, node.right]) 
        return root
```

## 108. Convert Sorted Array to Binary Search Tree (BT, Recurison-DFS) (Microsoft 3, Amazon 3)


```python
# nums‰∏∫Á©∫Ôºåreturn None
# numsÈùûÁ©∫Ôºånums[n/2]‰∏∫‰∏≠Èó¥ÂÖÉÁ¥†ÔºåÊ†πÁªìÁÇπÔºånums[:mid]‰∏∫Â∑¶Â≠êÊ†ëÔºå nums[mid+1:]‰∏∫Âè≥Â≠êÊ†ë

# O(N)
# O(1)
class Solution:
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        if not isinstance(nums, list):
            raise Exception('Invalid input')
        
        if not nums:
            return 
        
        return self.dfs(nums)
        
    def dfs(self, nums):
        if not nums:
            return
        
        mid = len(nums) >> 1
        root = TreeNode(nums[mid])
        root.left = self.dfs(nums[:mid])
        root.right = self.dfs(nums[mid+1:])
        return root
```

## 109. Convert Sorted List to Binary Search Tree (Amazon 7, Facebook 4)


```python
# O(N)
# O(N)
class Solution:
    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        def sortedArrayToBST(nums):
            if not nums:
                return
            
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = sortedArrayToBST(nums[:mid])
            root.right = sortedArrayToBST(nums[mid+1:])
            return root
        
        if not head:
            return 
        
        array = []
        while head:
            array.append(head.val)
            head = head.next
        return sortedArrayToBST(array)
```


```python
class Solution:

    def findSize(self, head):
        ptr = head
        c = 0
        while ptr:
            ptr = ptr.next
            c += 1
        return c


    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """

        # Get the size of the linked list first
        size = self.findSize(head)

        # Recursively form a BST out of linked list from l --> r
        def dfs(l, r):
            nonlocal head

            # Invalid case
            if l > r:
                return None

            mid = (l + r) // 2

            # First step of simulated inorder traversal. Recursively form
            # the left half
            left = dfs(l, mid - 1)

            # Once left half is traversed, process the current node
            node = TreeNode(head.val)   
            node.left = left

            # Maintain the invariance mentioned in the algorithm
            head = head.next

            # Recurse on the right hand side and form BST out of them
            node.right = dfs(mid + 1, r)
            return node
        return dfs(0, size - 1)
```

## 105. Construct Binary Tree from Preorder and Inorder Transversal (BT, Recursion-DFS) (Amazon 7, Microsoft 5)

preorder ÊòØ Ê†π -> Â∑¶ -> Âè≥  
inorder ÊòØ Â∑¶ -> Ê†π -> Âè≥

È¶ñÂÖàpreÁöÑÁ¨¨‰∏Ä‰∏™Â∞±ÊòØÊï¥‰∏™Ê†ëÁöÑroot, ÂÅáËÆæ preorder[0] = inorder[k],ÈÇ£‰πàinorderÁöÑÂâçk-1‰∏™Â∞±ÊòØÊ†ëÁöÑÂ∑¶Â≠êÊ†ëÔºåÂêéÈù¢ÈÉ®ÂàÜÂ∞±ÊòØÊ†ëÁöÑÂè≥Â≠êÊ†ë


```python
class Solution:
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if not preorder or not inorder:
            return 
        
        root = TreeNode(preorder[0])
        k = inorder.index(preorder[0])
        
        root.left = self.buildTree(preorder[1:k+1], inorder[:k])
        root.right = self.buildTree(preorder[k+1:], inorder[k+1:])
        return root
```

## 106 Construct Binary Tree from Inorder and Postorder Transversal (BT, Recursion-DFS) (Amazon 7)


```python
class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if not inorder or not postorer:
            return
        
        root = TreeNode(postorder[-1])
        k = inorder.index(postorder[-1])
        
        root.left = self.buildTree(inorder[:k], postorder[:k]) 
        root.right = self.buildTree(inorder[k+1:], postorder[k:-1])
        
        return root
```

## Remove Extra Edge (BT, Recursion-DFS) (Google)


```python
class Solution:
    def removeEdgeBT(root):
        
        seen = set()
        def dfs(root):
            if not root:
                return
            
            if root in seen:
                return
            
            seen.add(root)
            
            root.left = dfs(root.left)
            root.right = dfs(root.right)
            
            return root
```


```python
public static TreeNode removeEdgeBT(TreeNode root) {
	return removeEdgeBT(root, new HashSet<>());
}

private static TreeNode removeEdgeBT(TreeNode node, Set<TreeNode> seen) {
	if (node == null || !seen.add(node)) return null;
	node.left = removeEdgeBT(node.left, seen);
	node.right = removeEdgeBT(node.right, seen);
	return node;
}
```

## 97. Unique Binary Search Tree II (Apple 2)


```python
class Solution:
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        if n == 0:
            return []
        
        nums = [i for i in range(1, n+1)]

        def helper(nums):
            if not nums:
                return [None]
            res = []
            for idx, num in enumerate(nums):
                for l in helper(nums[:idx]):
                    for r in helper(nums[idx+1:]):
                        node = TreeNode(num)
                        node.left = l
                        node.right = r
                        res.append(node)
            return res

        return helper(nums)
```

### BFS-Queue. O(N) O(N)

## 958 Check Completeness of a Binary Tree (BT, Queue-BFS) (Facebook 7)

O(N)  
O(N)


```python
class Solution:
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """   
        queue = [root]
        end = False
        while queue:
            for i in range(len(queue)):
                node = queue.pop(0)
                
                if not node:
                    end = True
                    continue
                if end:
                    return False
                
                queue.extend([node.left, node.right])
                
            # queue = tmp
        return True
```


```python
class Solution:
    def isCompleteTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """   
        queue = [root]
        end = False
        while queue:
            tmp = []
            for node in queue:
                if not node:
                    end = True
                    continue
                if end:
                    return False
                tmp.extend([node.left, node.right])
            queue = tmp
        return True
```

## 199. Binary Tree Right Side View (BT, Queue-BFS) (Facebook 13, Amazon 8)  
O(N)  
O(N)


```python
class Solution:
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        if not root:
            return 
        
        res = []
        queue = [root]
        while queue:
            for i in range(len(queue)):
                node = queue.pop(0)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            res.append(node.val)
        return res
```

## 117. Populating Next Right Pointers in Each Node II (BT, Queue-BFS) (Amazon Onsite 6, Microsoft 4, Google 2)

The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.
The parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.
Connect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.
Do this one level by one level. The whole thing is quite straightforward.


```python
class Solution:
    def connect(self, root):
        """
        input: Node
        output: Node
        """
        
        if not root:
            return 
        res = []
        queue = [root]
            
        while queue:
            tmp = []            
            for i in range(len(queue)):
                node = queue.pop(0)         
                tmp.append(node)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            res.append(tmp) 
            
        # while queue:
        #     tmp = []
        #     for node in queue:
        #         if node.left:
        #             tmp.append(node.left)
        #         if node.right:
        #             tmp.append(node.right)
        #     res.append(tmp)
        #     queue = tmp
            
        for queue in res:
            for i in range(len(queue)-1):
                queue[i].next = queue[i+1]
                
        return root
```

## 102. Binary Tree Level Order Traversal (BT, Queue-BFS) (Amazon 11, Microsoft 6)

O(N)  
O(N)


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        queue = [root]
        
        while queue:
            tmp = []
            
            for i in range(len(queue)):
                node = queue.pop(0)         
                tmp.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            res.append(tmp) 
        return res
```


```python
x = [[], []]
len(x)
```




    2




```python
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        queue = [root]
        
        while queue:
            # nextl = []
            tmp = []
            for i in range(len(queue)):
                node = queue.pop(0)    
                if node:
                    
                    tmp.append(node.val)

    #                 if node.left:
                    queue.append(node.left)
    #                 if node.right:
                    queue.append(node.right)
            
            if tmp:
                res.append(tmp) 
        return res
```


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# DFS-Recursion
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        def dfs(root, depth = 0):
            if not root:
                return
            # start the current level
            if len(res) == depth:
                res.append([])

            # append the current node value
            res[depth].append(root.val)

            # process child nodes for the next level

            dfs(root.left, depth + 1)
            dfs(root.right, depth + 1)
            
        dfs(root)
        return res
```

## 103. Binary Tree Zigzag Level Order Transversal (BT, Queue-BFS, Recursion-DFS) (Amazon 33, Microsoft 11)

Êó∂Èó¥Â§çÊùÇÂ∫¶: O(N)  
O(N)


```python
# BFS
class Solution:
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        
        if not root:
            return []
        
        res = []
        queue = [root]
        level = 0
        
        while queue:
            tmp = []
            
            for i in range(len(queue)):
                node = queue.pop(0)
                tmp.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            if level % 2 == 0:
                res.append(tmp)  
            else:
                tmp.reverse()
                res.append(tmp)
            
            level += 1
        return res
```


```python
## DFS
class Solution:
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        def dfs(root, depth):
            if not root: 
                return 
            
            if len(res) == depth:
                res.append([])
                
            if depth % 2 == 0:
                res[depth].append(root.val)
            else: 
                res[depth].insert(0, root.val)
                
            dfs(root.left, depth + 1)
            dfs(root.right, depth + 1)
            
        dfs(root, 0)
        return res
```


```python
s = [1,2,3]
s = s.reverse()
s
```


```python
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

s = Solution()
s.zigzagLevelOrder(root)
```

    tmp_res = [3]
    next_level = 9 1
    next_level = 20 2
    res = [[3]]
    level_count = 1
    cur_level = 2
    
    tmp_res = [9]
    tmp_res = [9, 20]
    next_level = 15 1
    next_level = 7 2
    tmp_res = [20, 9]
    res = [[3], [20, 9]]
    level_count = 2
    cur_level = 2
    
    tmp_res = [15]
    tmp_res = [15, 7]
    res = [[3], [20, 9], [15, 7]]
    level_count = 3
    cur_level = 0
    





    [[3], [20, 9], [15, 7]]



## 107. Binary Tree Level Order Transversal III (BT. BFS-Queue, DFS-Queue) (Microsoft 3)


```python
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        queue = [root]
        
        while queue:
            tmp = []
            # nextl = []
            
            for i in range(len(queue)):
                node = queue.pop(0)         
                tmp.append(node.val)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            res.append(tmp) 
        return res[::-1]
```


```python
class Solution:
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        res = []
        def dfs(root, depth = 0):
            if not root:
                return
            # start the current level
            if len(res) == depth:
                res.append([])

            # append the current node value
            res[depth].append(root.val)

            # process child nodes for the next level

            dfs(root.left, depth + 1)
            dfs(root.right, depth + 1)
            
        dfs(root)
        return res[::-1]
```

## 314. Binary Tree Vertical Order Traversal (Facebook 10, Amazon 8)


```python
from collections import defaultdict

class Solution(object):
    def verticalOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        
        cols = defaultdict(list)
        queue = [(root, 0)]

        while queue:
            node, col = queue.pop(0)
            cols[col].append(node.val)
            
            if node.left:
                queue.append((node.left, col - 1))
            if node.right:
                queue.append((node.right, col + 1))
                
        return [cols[k] for k in sorted(cols.keys())]
```

## 863. All Nodes Distance K in Binary Tree (Amazon 9, Facebook 8, Microsoft 5, Apple 2)


```python
class Solution:
    def distanceK(self, root, target, K):
        """
        :type root: TreeNode
        :type target: TreeNode
        :type K: int
        :rtype: List[int]
        """
        
        def dfs(node, prev = None):
            if not node:
                return
            
            node.prev = prev
            dfs(node.left, node)
            dfs(node.right, node)

        dfs(root)

        queue = collections.deque([(target, 0)])
        seen = {target}
        
        res = []        
        while queue:
            node, d = queue.popleft()
#             print(node.val)
            
            if d == K:
                res.append(node.val)            
            
            for nei in (node.left, node.right, node.prev):
                if nei and nei not in seen:
                    seen.add(nei)
                    queue.append((nei, d+1))

        return res

```

## Validate Single Binary Tree (Google Phone)
https://leetcode.com/discuss/interview-question/347374/Google-and-Facebook-or-Validate-Single-Binary-Tree 


```python
class Solution:
    def is_binary_tree(nodes_list):
        dic = {}
        for n in nodes_list:
            dic[n] = False   # each node starts without parent

        root = len(nodes_list)  # root candidates counter. Initially, all nodes are candidates.
        for n in nodes_list:
            if n.left:
                if n.left not in nodes_dict:  # child not in original list
                    return False
                if dic[n.left]:  # child already has a parent
                    return False
                dic[n.left] = True   # we mark the child as "it already has a parent"
                root -= 1  # root candidates decrease by 1

            if n.right:  # do the same for the right child
                if n.right not in dic:
                    return False
                if dic[n.right]:
                    return False
                dic[n.right] = True
                root -= 1

        if root == 1:
            return True
        else:
            return False
```

## 894. All Possible Full Binary Trees (Google Onsite)


```python
class Solution:
    def allPossibleFBT(self, N):
        """
        :param N: A full binary tree must have odd number of nodes
        The number of leaf nodes must be N // 2 + 1
        :return:
        """
        def recur(N):
            """
            :param N: Number of leaf nodes in the "full" binary tree
            :return:
            """
            if N == 0:
                return
            if N == 1:
                return [TreeNode(0)]

            result = []
            
            for i in range(1, N):
                for left in recur(i):
                    for right in recur(N - i):
                        root = TreeNode(0)
                        root.left = left
                        root.right = right
                        result.append(root)
            return result

        if N % 2 == 0: 
            return []
        return recur(N // 2 + 1)
```

### Iteration-Pointer.

## 114. Flatten Binary Tree to Linked List (Tree. BFS, Iteration-Queue, Pointer) (Facebook 8, Amazon 3, Microsoft 5, Apple 3)


```python
class Solution:
    def flatten(self, root):
        """
        Do not return anything, modify root in-place instead.
        """
        while root:
            if root.left:
                most_right = root.left
                
                while most_right.right: 
                    most_right = most_right.right
                
                most_right.right = root.right
                root.right = root.left
                
                root.left = None
            root = root.right
        return root
```


```python
from collections import deque

class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        
        queue= deque([root])
        head = TreeNode(0)
        cur = head
        
        while queue:
            node = queue.popleft()
            cur.right = node
            if node.right: 
                queue.appendleft(node.right)
            if node.left:
                queue.appendleft(node.left)
                
            node.left = None
            cur = cur.right
```


```python
class Solution:
    def flatten(self, root):
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        
        queue=[root]
        head = TreeNode(0)
        cur = head
        
        while queue:
            node = queue.pop()
            cur.right = node
            if node.right:
                queue.append(node.right)
            if node.left:
                queue.append(node.left)
                
            node.left = None
            cur = cur.right
```

## 230. Kth Smallest Element in a BST (BT, Recursion-DFS) (Microsoft 3, Amazon 3, Apple 3)
O(N)  
O(1)


```python
class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype:
        """
        if not root:
            return []
        
        stack = []
        p = root
        
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
                
            else:
                node = stack.pop()
                k -= 1
                if not k:
                    return node.val
                
                p = node.right
```


```python
class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        
        stack = []
        
        def left_node(node):
            while node:
                stack.append(node)
                node = node.left
        
        left_node(root)
        
        while stack:
            node = stack.pop()   
            
            k -= 1
            if not k:
                return node.val
        
            if node.right:
                left_node(node.right)
```


```python
class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        stack = []
        
        while True:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            k -= 1
            if not k:
                return root.val
            root = root.right
```


```python
class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        res = []
        def dfs(root):
            if not root:
                return 
    
            # if root.left:
            dfs(root.left)
                
            res.append(root.val)
            
            # if root.right:
            dfs(root.right)
            
        dfs(root)
        return res[k-1]
```

## 270. Closest Binary Search Tree Value (Facebook 14, Amazon 4)


```python
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        closest = root.val
        while root:
            closest = min(root.val, closest, key = lambda x: abs(target - x))
            
            if root.val > target:
                root = root.left
            else:
                root = root.right
            
        return closest
```

## 285. Inorder Successor in BST (BT, Recursion-DFS) (Facebook 3, Microsoft 3->5, Amazon 3)


```python
class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        """

        res = None
        while root:
            if root.val > p.val:
                res = root
                root = root.left
                
            else:
                root = root.right
                
        return res
```


```python
class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':
        """ 
        1. ‰∏≠Â∫èÈÅçÂéÜ
        2. MorrisÈÅçÂéÜ
        """
        inorderList = []

        def dfs(root):
            if not root:
                return 

            dfs(root.left)
            inorderList.append(root)
            dfs(root.right)

        dfs(root)
        for i in range(len(inorderList)):
            # Ê≥®ÊÑèÂà§Êñ≠Ë∂äÁïå
            if inorderList[i].val == p.val and i < len(inorderList) - 1:
                return inorderList[i+1]
        return None

```

## Search in BST


```python
class Solution:
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """        
        if not root:
            return
        
        while root:
            if root.val == val:
                return root

            if root.val > val:
                root = root.left

            elif root.val < val:
                root = root.right
```


```python
class Solution:
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """        
        if not root:
            return
        
        if root.val == val:
            return root
        
        if root.val > val:
            return self.searchBST(root.left, val)
        elif root.val < val:
            return self.searchBST(root.right, val)
```

## 235. (5) Lowest Common Ancestor of a Binary Search Tree (BST, Recursion-DFS, Queue-BFS) (Amazon 4, Facebook 3, Microsoft 3, Linkedin 8->2)


```python
#O(N)
#O(1)
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        while root:
            if root.val > p.val and root.val > q.val:
                # If both p and q are lesser than parent
                root = root.left
            
            elif root.val < p.val and root.val < q.val:    
                # If both p and q are greater than parent
                root = root.right
            
            else:
                # We have found the split point, i.e. the LCA node.
                return root
```


```python
#O(N)
#O(N)
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if not root:
            return 
        
        # If both p and q are lesser than parent
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
            
        # If both p and q are greater than parent
        elif root.val < p.val and root.val < q.val:    
            return self.lowestCommonAncestor(root.right, p, q)
        # We have found the split point, i.e. the LCA node.

        return root
```

## 98. (5) Validate Binary Search Tree (BST, Recursion-DFS, Queue-BFS) (Facebook 24, Amazon 14, Microsoft 7)

O(N) since we visit each node exactly once.  
O(N) since we keep up to the entire tree.


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def dfs(root, lower, upper):
            if not root:
                return True
            
            if root.val >= upper or root.val <= lower:
                return False
            
            return dfs(root.left, lower, root.val) and dfs(root.right, root.val, upper)
        
#             if not dfs(root.right, root.val, upper):
#                 return False
#             if not dfs(root.left, lower, root.val):
#                 return False
#             return True

        return dfs(root, float('-inf'), float('inf'))
```


```python
class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        if not root:
            return True
        
        
        res = []
        def dfs(root):
            if not root:
                return
            
            dfs(root.left)
            res.append(root.val)
            dfs(root.right)
            
        dfs(root)
        
        for i in range(1, len(res)):
            if res[i] <= res[i-1]:
                return False
            
        return True
```


```python
#O(N)
#O(N)
class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return True
            
        stack = [(root, float('-inf'), float('inf')), ] 
        while stack:
            root, lower, upper = stack.pop()
            if not root:
                continue
            val = root.val
            if val <= lower or val >= upper:
                return False
            stack.append((root.right, val, upper))
            stack.append((root.left, lower, val))
        return True  
```

## 333. Largest BST Subtree (Amazon 4, Facebook 4, Apple)


```python
class Solution(object):
    def largestBSTSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def isValid(root, lower, upper):
            if not root:
                return True
            
            if root.val <= lower or root.val >= upper:
                return False
            
            return isValid(root.left, lower, root.val) and isValid(root.right, root.val, upper)
        
        def countNode(root):
            if not root:
                return 0
            
#             if not root.left and not root.right:
#                 return 1
            return 1 + countNode(root.left) + countNode(root.right)

        
        if not root:
            return 0
        
#         if not root.left and not root.right:
#             return 1
        
        if isValid(root, float('-inf'), float('inf')):
            return countNode(root)
        
        return max(self.largestBSTSubtree(root.left), self.largestBSTSubtree(root.right))
        
```

## 450. Delete Node in BST (BST. DFS-Recursion) (Microsoft Onsite 2->5, Amazon 2)  
O(h)  
O(h)


```python
class Solution:
    def deleteNode(self, root, key):
        
        def minimum(root):          
            while root.left:
                root = root.left

            return root
        
        if not root:
            return 
        
        if root.val > key:
            root.left = self.deleteNode(root.left, key)

        
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)

        
        else:
            if not root.left and not root.right:
                return
            
            if not root.left:
                return root.right

            if not root.right:
                return root.left
        
            node = minimum(root.right)
            root.val = node.val
            root.right = self.deleteNode(root.right, node.val)
                 
        
        return root
```


```python
# Buggy
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        
        if not root:
            return 
        
        if root.val == key:
            if not root.left and not root.right:
                return None
                
            elif root.left and root.right:
                root.val = root.right.val
                root.right = root.right.right
                return root    
                
            elif root.left and not root.right:
                root.val = root.left.val
                root.left = root.left.left
                return root
                
            elif root.right and not root.left:
                root.val = root.right.val
                root.right = root.right.right
                return root
                   
        root.left = self.deleteNode(root.left, key)
        root.right = self.deleteNode(root.right, key)
        
        return root
```

## 701. Insert in BST (Amazon 2)


```python
class Solution:
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        if not root:
            return TreeNode(val)
        
        if root.val > val:
            # insert into the left subtree
            root.left = self.insertIntoBST(root.left, val)
        
        if root.val < val:
            # insert into the right subtree
            root.right = self.insertIntoBST(root.right, val)
            
        return root
```

## 669. Trim a Binary Search Tree (Microsoft 2)


```python
class Solution():
    def trimBST(self, root, L, R):
        """
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: TreeNode
        """
        def trim(node):
            if not node:
                return 
            elif node.val > R:
                return trim(node.left)
            elif node.val < L:
                return trim(node.right)
            else:
                node.left = trim(node.left)
                node.right = trim(node.right)
                return node

        return trim(root)
```

## Delete node greater than value


```python
def dfs(root, value):
    if not root:
        return
    
    if root.val < value:
        root.right = dfs(root.right, value)
        return root
    
    elif root.val >= value:
        return dfs(root.left, value)
```

## 426. Convert Binary Search Tree to Sorted Doubly Linked List (BST. DFS, Iteration-Recursion, Pointer) (Facebook 21, Amazon 3, Microsoft Onsite 2)


```python
class Solution:
    def treeToDoublyList(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        def dfs(root):
            nonlocal first
            nonlocal last
            
            if not root:
                return 
            
            dfs(root.left)

            if last:
                last.right = root
                root.left = last

            else:
                first = root

            last = root
            dfs(root.right)
                
        if not root:
            return 

        first = None
        last = None
        dfs(root)
        last.right = first
        first.left = last
        return first
```

## 99. Recover Binary Search Tree (BST, Recursion-DFS) (Amazon Onsite 13, Microsoft 6, Google 3)


```python
# Recursive Inorder Traversal
class Solution:
    def recoverTree(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """
        def find_two_swapped(root):
            nonlocal x, y, pred
            if not root:
                return
            
            find_two_swapped(root.left)
            if pred and root.val < pred.val:
                y = root
                # first swap occurence
                if x is None:
                    x = pred 
                # second swap occurence
                else:
                    return
            pred = root
            find_two_swapped(root.right)
        
        x = y = pred = None
        find_two_swapped(root)
        x.val, y.val = y.val, x.val
```


```python
# Iterative Inorder Traversal
class Solution:
    def recoverTree(self, root: TreeNode):
        """
        :rtype: void Do not return anything, modify root in-place instead.
        """
        stack = []
        x = y = pred = None
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if pred and root.val < pred.val:
                y = root
                if x is None:
                    x = pred 
                else:
                    break
            pred = root
            root = root.right

        x.val, y.val = y.val, x.val
```


```python
#The idea of Morris algorithm is to set the temporary link between the node and its predecessor: predecessor.right = root. So one starts from the node, computes its predecessor and verifies if the link is present.
#There is no link? Set it and go to the left subtree.
#There is a link? Break it and go to the right subtree.

# Morris Inorder Traversal
class Solution:
    def recoverTree(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """
        # predecessor is a Morris predecessor. 
        # In the 'loop' cases it could be equal to the node itself predecessor == root.
        # pred is a 'true' predecessor, 
        # the previous node in the inorder traversal.
        x = y = predecessor = pred = None
        
        while root:
            # If there is a left child
            # then compute the predecessor.
            # If there is no link predecessor.right = root --> set it.
            # If there is a link predecessor.right = root --> break it.
            if root.left:       
                # Predecessor node is one step left 
                # and then right till you can.
                predecessor = root.left
                while predecessor.right and predecessor.right != root:
                    predecessor = predecessor.right
 
                # set link predecessor.right = root
                # and go to explore left subtree
                if predecessor.right is None:
                    predecessor.right = root
                    root = root.left
                # break link predecessor.right = root
                # link is broken : time to change subtree and go right
                else:
                    # check for the swapped nodes
                    if pred and root.val < pred.val:
                        y = root
                        if x is None:
                            x = pred 
                    pred = root
                    
                    predecessor.right = None
                    root = root.right
            # If there is no left child
            # then just go right.
            else:
                # check for the swapped nodes
                if pred and root.val < pred.val:
                    y = root
                    if x is None:
                        x = pred 
                pred = root
                
                root = root.right
        
        x.val, y.val = y.val, x.val
```


```python
class Solution:
    def recoverTree(self, root):
        """
        Do not return anything, modify root in-place instead.
        """
        def dfs(root): 
            if not root:
                return []
            
            dfs(root.left)
            nodes.append(root)
            vals.append(root.val)
            dfs(root.right)
    
        nodes = []
        vals = []
        dfs(root)
        vals.sort()

        for i in range(len(vals)):
            if nodes[i].val != vals[i]:
                nodes[i].val = vals[i]
```

### N-ry Tree

## Subtree with Maximum Average (Amazon OA)


```python
class Solution: 
    def MaxAverageSubtree(self, root):
        if not root or not root.children:
            return None
        
        res = [float('-inf'), 0]
        # self.res[0]: average; self.res[1]: number of nodes
        
        def dfs(root):
        if not root.children:
            return [root.val, 1]
        
        temp_sum, temp_num = root.val, 1
        for child in root.children:
            child_sum, child_num = dfs(child)
            temp_sum += child_sum
            temp_num += child_num
            
        if temp_sum/temp_num > res[0]:
            res = [temp_sum/temp_num, root.val]
        
        return [temp_sum, temp_num]
        
        
        dfs(root)
        return res[1]  
```

## 133. Clone Graph (N-ary Tree. DFS-Recursion) (Facebook 18, Amazon 11, Microsoft Onsite, Apple 4)  


```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val, neighbors):
        self.val = val
        self.neighbors = neighbors
"""
# DFS
class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        
        if not node:
            return
        
        visited = {}
        
        def dfs(node):
            if node in visited:
                return visited[node]
            
            clone = Node(node.val, [])
            visited[node] = clone
            
#             clone.neighbors = [dfs(n) for n in node.neighbors]
            for n in node.neighbors:
                clone.neighbors.append(dfs(n))
    
            return clone
        
        return dfs(node)
```

## 559. Maximum Depth of N-ary Tree (N-ary Tree. DFS-Recursion) (Amazon 3)


```python
class Solution:
    def maxDepth(self, root):
        """
        :type root: Node
        :rtype: int
        """
        if not root: 
                return 0

        def dfs(root):
            if not root.children: 
                return 1
            
            height = []
            for node in root.children:
                height.append(dfs(node))
                
            return max(height) + 1
        
        return dfs(root)
    
# class Solution:
#     def maxDepth(self, root):
#         """
#         :type root: TreeNode
#         :rtype: int
#         """ 
#         if not root: 
#             return 0 

#         left = self.maxDepth(root.left) 
#         right = self.maxDepth(root.right) 
#         return 1 + max(left, right) 
```

## Time To Receive Note/Min Time to Wet Tree (Google Phone)
https://leetcode.com/discuss/interview-question/394258/ 


```python
class Solution:
    def findLongestPath(self, root):
        if not root:
            return 0
        if not root.children:
            return 0

        res = 0
        for node in root.children:
            res = max(res, node[1] + self.findLongestPath(node[0]))
            
        return res
    
# int findLongestNotePath(Node* root) {
#   if (root == nullptr) return 0;
#   if (root->children.size() == 0) return 0;
#   else{
#     int maxPath = 0;
#     for (auto c : root->children) {
#       maxPath = max(maxPath, c.second + findLongestNotePath(c.first));
#     }
#     return maxPath;
#   }
# }
```

## 589. N-ary Tree Preorder Traversal (Google)


```python
class Solution:
    def preorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        
        res = []    
        def addnode(root):
            if not root:
                return
            
            res.append(root.val)

            for c in root.children:
                addnode(c)
                    
        addnode(root)
        return res
```


```python
class Solution:
    def preorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        
        stack = [root]
        output = []            
        while stack:
            root = stack.pop()
            output.append(root.val)
            stack.extend(root.children[::-1])
                
        return output
```

## 590. N-ary Tree Postorder Traversal


```python
class Solution:
    def postorder(self, root):
        """
        :type root: Node
        :rtype: List[int]
        """
        if not root:
            return []
        
        res = []    
        def addnode(root):
            if not root:
                return
            
            for c in root.children:
                addnode(c)
                
            res.append(root.val)
                    
        addnode(root)
        return res
```
