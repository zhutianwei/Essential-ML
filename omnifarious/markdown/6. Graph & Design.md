```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

### Graph(List, Dict). DFS, BFS, Topological Sorting

## 773. Sliding Puzzle


```python
row = len(board)
        col = len(board[0])
        directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]
        
        def getTarget(row, col):
            res = []
            result = row * col
            
            for n in range(result):
                res.append(str(n))
                
            x = res.pop(0)
            res.append(x)
            
            return ' '.join(res)
            
#             res = ''
#             result = row * col
#             for n in result:
#                 res += str(n)
            
#             return res
        
        def boardToString(board):
            res = ''
            for i in range(len(board)):
                for j in range(len(board[0])):
                    res += str(board[i][j])
                    res += ' '
        
            return res.rstrip()

        def stringToBoard(s):
            board = [[0] * col for i in range(row)]
            s = s.split()
        
            for i in range(col * row):                
                board[i // col][i % col] = int(s[i])
                
            return board

        def getNext(cur):
            res = []
            curboard = stringToBoard(cur)
            
            for i in range(row * col):
                if curboard[i // col][i % col] == 0:
                    
                    x = i // col
                    y = i % col
                    for i, j in directions:
                        nxt_x = x + i
                        nxt_y = y + j
                        if 0 <= nxt_x < row and 0 <= nxt_y < col:
                            curboard[x][y],curboard[nxt_x][nxt_y] = curboard[nxt_x][nxt_y],curboard[x][y]
                            res.append(boardToString(curboard))
                            curboard[x][y],curboard[nxt_x][nxt_y] = curboard[nxt_x][nxt_y],curboard[x][y]
            return res

        init = boardToString(board)
        target = getTarget(row, col)
        
        if init == target:
            return 0
        
        queue = [init]
        visited = {init: 0}
        
        while queue:
            cur = queue.pop(0)
            nxt = getNext(cur)
            for s in nxt:
                if s not in visited:
                    queue.append(s)
                    visited[s] = visited[cur] + 1
                    
                    if s == target:
                        return visited[s]
        return -1
```


```python
a = set()
a.add(((1,0), (2,1)))
a
```




    {((1, 0), (2, 1))}




```python
x = [[1,2], [2,3]]
for i in range(len(x)):
    x[i] = tuple(x[i])

x = tuple(x)
print(x)
a = set(x)

    

```

    ((1, 2), (2, 3))



```python
s = 'a b c '
s.rstrip()
```




    'a b c'




```python
a = [[1,2,3], [5,4,0]]
str(a)
```




    '[[1, 2, 3], [5, 4, 0]]'



## Monarchy (Google Phone)


```python
class Monarch:
    def __init__(self):
        self.name = None
        self.childern = []
        self.isAlive = True
        
class Monarchy:
    def __init__(self):
        self.firstMonarch = None
        self.monarchs = {}
        
    def birth(self, child, parent):
        # create monarch
        monarch = Monarch()
        monarch.name = child
        # If it's the first monarch
        if not parent and not self.firstMonarch:
            self.firstMonarch = monarch
        else: 
            # find parent and add child
            if not (parent in self.monarchs):
                print("Parent not found")
                return
            self.monarchs[parent].childern.append(monarch)
        # Add the monarch to hash table
        self.monarchs[child] = monarch

    def death(self, name):
        self.monarchs[name].isAlive = False

    def preOrder(self, node):
        if not node:
            return

        if node.isAlive:
            # don't print dead people :'(
            print(node.name)
        for child in node.childern:
            
            self.preOrder(child)

    def getOrderOfSuccession(self):
        self.preOrder(self.firstMonarch)

# Main
m = Monarchy()
m.birth("king", None)
m.birth("Andy", "king")
m.birth("Bob", "king")
m.birth("Catherine", "king")
m.birth("Matthew" , "Andy")
m.birth("Alex " , "Bob")
m.birth("Asha " , "Bob")
m.getOrderOfSuccession()
```

    king
    Andy
    Matthew
    Bob
    Alex 
    Asha 
    Catherine


## 261. Valid Graph Tree (Amazon 4)


```python
from collections import defaultdict
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        if len(edges) != n - 1: 
            return False
    
        # Create an adjacency list.
        adj_list = defaultdict(list)
        for A, B in edges:
            adj_list[A].append(B)
            adj_list[B].append(A)

        # We still need a seen set to prevent our code from infinite
        # looping if there *is* cycles (and on the trivial cycles!)
        seen = set()

        def dfs(node):
            
            for neighbour in adj_list[node]:
                if neighbour not in seen:
                    seen.add(neighbour)
                    dfs(neighbour)

        seen.add(0)
        dfs(0)
        return len(seen) == n
```


```python
from collections import defaultdict
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        if len(edges) != n - 1: 
            return False
    
        # Create an adjacency list.
        adj_list = defaultdict(list)
        for A, B in edges:
            adj_list[A].append(B)
            adj_list[B].append(A)

        # We still need a seen set to prevent our code from infinite
        # looping if there *is* cycles (and on the trivial cycles!)
        seen = {0}
        queue = collections.deque([0])

        while queue:
            node = queue.popleft()
            for neighbour in adj_list[node]:
                if neighbour not in seen:
                    seen.add(neighbour)
                    queue.append(neighbour)

        return len(seen) == n
```


```python
from collections import defaultdict
class Solution:
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        
        if len(edges) != n - 1: 
            return False
    
        adj_list = defaultdict(list)
        for A, B in edges:
            adj_list[A].append(B)
            adj_list[B].append(A)

        parent = {0: -1}
        stack = [0]

        while stack:
            node = stack.pop()
            for neighbour in adj_list[node]:
                if neighbour == parent[node]:
                    continue
                if neighbour in parent:
                    return False
                parent[neighbour] = node
                stack.append(neighbour)

        return len(parent) == n
```

## 323. Number of Connected Components in an Undirected Graph (Amazon 6, Facebook 4)


```python
# DFS
from collections import defaultdict
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        def dfs(n):
            for x in g[n]:
                if x not in visited:
                    visited.add(x)
                    dfs(x)

        visited = set()
        
        g = defaultdict(list)
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        ret = 0
        for i in range(n):
            if i not in visited:
                visited.add(i)
                dfs(i)
                ret += 1

        return ret
```


```python
# DFS
from collections import defaultdict
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        def dfs(n):
            if n in visited:
                return
            
            visited.add(n)
            
            for x in g[n]:
                dfs(x)

        visited = set()
        
        g = defaultdict(list)
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        ret = 0
        for i in range(n):
            if i not in visited:
                dfs(i)
                ret += 1

        return ret
```


```python
# BFS
def countComponents(n, edges):
    g = {x:[] for x in xrange(n)}
    for x, y in edges:
        g[x].append(y)
        g[y].append(x)

    ret = 0
    for i in xrange(n):
        queue = [i]
        ret += 1 if i in g else 0
        for j in queue:
            if j in g:
                queue += g[j]
                del g[j]

    return ret
```


```python
# Union Find
def countComponents(n, edges):
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(xy):
        x, y = map(find, xy)
        if rank[x] < rank[y]:
            parent[x] = y
        else:
            parent[y] = x
            if rank[x] == rank[y]:
                rank[x] += 1

    parent, rank = range(n), [0] * n
    map(union, edges)
    return len({find(x) for x in parent})
```

## 547. Friend Circles (Amazon 6)


```python
class Solution:
    def findCircleNum(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        m = len(matrix)
        n = len(matrix[0])
        
        visited = set()
        
        def dfs(i):
            for j in range(n):
                if matrix[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
                       
        count = 0
        for i in range(m):
            if i not in visited:
                visited.add(i)
                dfs(i)
                count += 1
                
        return count
```

## 332. Reconstruct Itinerary (Amazon 8, Google 4, Facebook 4, Apple 2)


```python
from collections import defaultdict
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        graph = collections.defaultdict(list)
        for frm, to in tickets:
            graph[frm].append(to)
            
        for tos in graph.values():
            tos.sort()
            
        print(graph)    
        
        res = []
        
        def dfs(source):
            while graph[source]:
                v = graph[source].pop(0)
                dfs(v)
                
            res.append(source)
        
        dfs("JFK")
        return res[::-1]
```


```python
import bisect
res = []
array = [1,5,4,8]
for n in array:
    bisect.insort_left(res, n)
    
print(res)
```

    [1, 4, 5, 8]


## 743. Network Delay Time (Google 7 Phone)


```python
from collections import defaultdict
class Solution:
    def networkDelayTime(self, times, N, K):
        """
        :type times: List[List[int]]
        :type N: int
        :type K: int
        :rtype: int
        """

        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append([v, w])

        dist = {}
        for node in range(1, N+1):
            dist[node] = float('inf')

        def dfs(node, elapsed):
            if elapsed >= dist[node]: 
                return
            
            dist[node] = elapsed
            for nei, time in sorted(graph[node], key = lambda x:x[1]):
                dfs(nei, elapsed + time)

        dfs(K, 0)
        ans = max(dist.values())
        return ans if ans < float('inf') else -1
```

## 399. Evaluate Division (Google 8, Amazon 3)


```python
class Solution:    
    def calcEquation(self, equations, values, queries):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        """
        
        # 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数
        graph = {}
        for (x, y), v in zip(equations, values):
            if x in graph:
                graph[x][y] = v
            else:
                graph[x] = {y: v}
            if y in graph:
                graph[y][x] = 1/v
            else:
                graph[y] = {x: 1/v}
        
        # dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果
        def dfs(first, last):
            if first not in graph:
                return -1
            if first == last:
                return 1
            if last in graph[first]:
                return graph[first][last]
            
            for node in graph[first].keys():
                if node not in visited:
                    visited.add(node)  # 添加到已访问避免重复遍历
                    res = dfs(node, last)
                    if res != -1:
                        return graph[first][node] * res
            return -1

        # 逐个计算query的值
        res = []
        for first, last in queries:
            visited = set()
            res.append(dfs(first, last))
        return res
```

Although this looks like a math problem, we can easily model it with graph.

For example:
Given:
a/b = 2.0, b/c = 3.0
We can build a directed graph:
a -- 2.0 --> b -- 3.0 --> c
If we were asked to find a/c, we have:
a/c = a/b * b/c = 2.0 * 3.0
In the graph, it is the product of costs of edges.

Do notice that, 2 edges need to added into the graph with one given equation,
because with a/b we also get result of b/a, which is the reciprocal of a/b.

so the previous example also gives edges:
c -- 0.333 --> b -- 0.5 --> a

Now we know how to model this problem, what we need to do is simply build the
graph with given equations, and traverse the graph, either DFS or BFS, to find a path
for a given query, and the result is the product of costs of edges on the path.

One optimization, which is not implemented in the code, is to "compress" paths for
past queries, which will make future searches faster. This is the same idea used in
compressing paths in union find set. So after a query is conducted and a result is found,
we add two edges for this query if these edges are not already in the graph.

Given the number of variables N, and number of equations E,
building the graph takes O(E), each query takes O(N), space for graph takes O(E)

I think if we start to compress paths, the graph will grow to O(N^2), and we
can optimize the query to O(1), please correct me if I'm wrong.




```python
class Solution:
    def calcEquation(self, equations, values, queries):

        graph = {}
        
        def build_graph(equations, values):
            def add_edge(f, t, value):
                if f in graph:
                    graph[f].append((t, value))
                else:
                    graph[f] = [(t, value)]
            
            for vertices, value in zip(equations, values):
                f, t = vertices
                add_edge(f, t, value)
                add_edge(t, f, 1/value)
        
        def find_path(query):
            b, e = query
            
            if b not in graph or e not in graph:
                return -1.0
                
            q = [(b, 1.0)]
            visited = set()
            
            while q:
                front, cur_product = q.pop(0)
                if front == e:
                    return cur_product
                visited.add(front)
                for neighbor, value in graph[front]:
                    if neighbor not in visited:
                        q.append((neighbor, cur_product*value))
            
            return -1.0
        
        build_graph(equations, values)
        return [find_path(q) for q in queries]
```


```python
graph = {}
        
def build_graph(equations, values):
    def add_edge(f, t, value):
        if f in graph:
            graph[f].append((t, value))
        else:
            graph[f] = [(t, value)]

    for vertices, value in zip(equations, values):
        print('vertices=', vertices)
        print('value=', value)
        f, t = vertices
        add_edge(f, t, value)
        add_edge(t, f, 1/value)
        
equations = [ ["a", "b"], ["b", "c"] ]
values = [2.0, 3.0]
build_graph(equations, values)
graph
```

    vertices= ['a', 'b']
    value= 2.0
    vertices= ['b', 'c']
    value= 3.0





    {'a': [('b', 2.0)],
     'b': [('a', 0.5), ('c', 3.0)],
     'c': [('b', 0.3333333333333333)]}




```python
def find_path(query):
            b, e = query
            
            if b not in graph or e not in graph:
                return -1.0
                
            q = [(b, 1.0)]
            visited = set()
            
            while q:
                front, cur_product = q.pop(0)
#                 print('front=', front)
#                 print('cur_product=', cur_product)
                
                if front == e:
                    return cur_product

                visited.add(front)
#                 print('visited', visited)
                
                for neighbor, value in graph[front]:
#                     print('neighbor=', neighbor)
#                     print('value=', value)
                    if neighbor not in visited:
                        q.append((neighbor, cur_product*value))
#                         print('q=', q) 
                print()          
            return -1.0    
query = ['a','c']
find_path(query)
```

    front= a
    cur_product= 1.0
    visited {'a'}
    neighbor= b
    value= 2.0
    q= [('b', 2.0)]
    
    front= b
    cur_product= 2.0
    visited {'b', 'a'}
    neighbor= a
    value= 0.5
    neighbor= c
    value= 3.0
    q= [('c', 6.0)]
    
    front= c
    cur_product= 6.0





    6.0



Recursion

## 1192. Critical Connections in a Network (Amazon OA 232)


```python
from collections import defaultdict
class Solution:
    def criticalConnections(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: List[List[int]]
        """
        
        def dfs(rank, curr, prev):
            low[curr] = rank
            result = []
            
            for neighbor in edges[curr]:
                if neighbor == prev: 
                    continue
                    
                if not low[neighbor]:
                    result += dfs(rank + 1, neighbor, curr)
                    
                low[curr] = min(low[curr], low[neighbor])
                
                if low[neighbor] >= rank + 1:
                    result.append([curr, neighbor])
                    
            return result

        low, edges = [0] * n, defaultdict(list)
        
        for u, v in connections:
            edges[u].append(v)
            edges[v].append(u)

        return dfs(1, 0, -1)
```


```python
s = Solution()
n = 4
connections = [[0,1],[1,2],[2,0],[1,3]]

edges = defaultdict(list)
for u, v in connections:
    
    edges[v].append(u)
    edges[u].append(v)

edges
```




    defaultdict(list, {1: [0, 2, 3], 0: [1, 2], 2: [1, 0], 3: [1]})




```python
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:

		graph = [[] for _ in range(n)] ## vertex i ==> [its neighbors]
		
        currentRank = 0 ## please note this rank is NOT the num (name) of the vertex itself, it is the order of your DFS level
		
        lowestRank = [i for i in range(n)] ## here lowestRank[i] represents the lowest order of vertex that can reach this vertex i
		
        visited = [False for _ in range(n)] ## common DFS/BFS method to mark whether this node is seen before
        
        ## build graph:
        for connection in connections:
            ## this step is straightforward, build graph as you would normally do
            graph[connection[0]].append(connection[1])
            graph[connection[1]].append(connection[0])
        
        res = []
        prevVertex = -1 ## This -1 a dummy. Does not really matter in the beginning. 
		## It will be used in the following DFS because we need to know where the current DFS level comes from. 
		## You do not need to setup this parameter, I setup here ONLY because it is more clear to see what are passed on in the DFS method.
		
        currentVertex = 0 ## we start the DFS from vertex num 0 (its rank is also 0 of course)
        self._dfs(res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex)
        return res
    
    def _dfs(self, res, graph, lowestRank, visited, currentRank, prevVertex, currentVertex):

        visited[currentVertex] = True 
        lowestRank[currentVertex] = currentRank

        for nextVertex in graph[currentVertex]:
            if nextVertex == prevVertex:
                continue ## do not include the the incoming path to this vertex since this is the possible ONLY bridge (critical connection) that every vertex needs.

            if not visited[nextVertex]:
                self._dfs(res, graph, lowestRank, visited, currentRank + 1, currentVertex, nextVertex)
				# We avoid visiting visited nodes here instead of doing it at the beginning of DFS - 
				# the reason is, even that nextVertex may be visited before, we still need to update my lowestRank using the visited vertex's information.

            lowestRank[currentVertex] = min(lowestRank[currentVertex], lowestRank[nextVertex]) 
			# take the min of the current vertex's and next vertex's ranking
            if lowestRank[nextVertex] >= currentRank + 1: ####### if all the neighbors lowest rank is higher than mine + 1, then it means I am one connecting critical connection ###
                res.append([currentVertex, nextVertex])
```

## Critical Routers (Amazon OA)


```python
from collections import defaultdict
class Solution:
    def criticalRouters(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: List[List[int]]
        """
        
        def dfs(level, curr, prev):
            array[curr] = level
            res = []
            
            for neighbor in graph[curr]:
                if neighbor == prev: 
                    continue
                    
                if not array[neighbor]:
                    res += dfs(level + 1, neighbor, curr)
                    
                array[curr] = min(array[curr], array[neighbor])
                
                if array[neighbor] >= level + 1:
                    res.append(curr)
                    
            return res

        array = [0] * n
        graph = defaultdict(list)
        for parent, child in connections:
            graph[parent].append(child)
            graph[child].append(parent)

        return dfs(1, 0, -1)
```


```python
from collections import defaultdict
class Solution:
    def criticalRouters(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: List[List[int]]
        """
        
        def dfs(rank, curr, prev):
            low[curr] = rank
            result = []
            
            for neighbor in edges[curr]:
                if neighbor == prev: 
                    continue
                    
                if not low[neighbor]:
                    result += dfs(rank + 1, neighbor, curr)
                    
                low[curr] = min(low[curr], low[neighbor])
                
                if low[neighbor] >= rank + 1:
                    result.append(curr)
                    
            return result

        low, edges = [0] * n, defaultdict(list)
        
        for u, v in connections:
            edges[u].append(v)
            edges[v].append(u)

        return dfs(1, 0, -1)
```


```python
n = 7
numEdges = 7
connections = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
solution = Solution()
res = solution.criticalRouters(n, connections)
res
```




    [5, 2, 3]



## 127 Word Ladder (Graph(Dict). BFS-Queue) (Amazon 27, Microsoft 11, Facebook 6, Google 5)  
O(MN)  
O(MN)


```python
from collections import defaultdict
class Solution:
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        dic = defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                dic[word[:i] + "*" + word[i+1:]].append(word)
                
        queue = [(beginWord, 1)]
        visited = set()
        visited.add(beginWord)

        while queue:
            cur, level = queue.pop(0)  
            for i in range(len(cur)):
                potential = cur[:i] + "*" + cur[i+1:]

                for word in dic[potential]:
                    if word == endWord:
                        return level + 1

                    if word not in visited:
                        visited.add(word)
                        queue.append((word, level + 1))
                
        return 0
```


```python
from collections import defaultdict

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        dic = defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                dic[word[:i] + "*" + word[i+1:]].append(word)
               
        queue = [beginWord]
        visited = set()
        visited.add(beginWord)

        level = 1
        while queue:
            for i in range(len(queue)):
            
                cur = queue.pop(0)  

                for i in range(len(cur)):
                    potential = cur[:i] + "*" + cur[i+1:]

                    for word in dic[potential]:
                        if word == endWord:
                            return level + 1

                        if word not in visited:
                            visited.add(word)
                            queue.append(word)
                            
            level += 1    
        return 0
```


```python
from collections import defaultdict, deque
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """

        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return 0

        # Dictionary to hold combination of words that can be formed,
        # from any given word. By changing one letter at a time.
        dic = defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                # Key is the generic word
                # Value is a list of words which have the same intermediate generic word.
                dic[word[:i] + "*" + word[i+1:]].append(word)
                
        print(dic)

        queue = deque([(beginWord, 1)])
        # Visited to make sure we don't repeat processing same word.
        visited = {beginWord: True}
        while queue:
            cur, level = queue.popleft()      
            for i in range(len(beginWord)):
                # Intermediate words for current word
                potential = cur[:i] + "*" + cur[i+1:]

                # Next states are all the words which share the same intermediate state.
                for word in dic[potential]:
                    # If at any point if we find what we are looking for
                    # i.e. the end word - we can return with the answer.
                    if word == endWord:
                        return level + 1
                    # Otherwise, add it to the BFS Queue. Also mark it visited
                    if word not in visited:
                        visited[word] = True
                        queue.append((word, level + 1))
                
        return 0
```


```python
s = Solution()
s.ladderLength('hit', 'cog', ["hot","dot","dog","lot","log","cog"])

```

    defaultdict(<class 'list'>, {'*ot': ['hot', 'dot', 'lot'], 'h*t': ['hot'], 'ho*': ['hot'], 'd*t': ['dot'], 'do*': ['dot', 'dog'], '*og': ['dog', 'log', 'cog'], 'd*g': ['dog'], 'l*t': ['lot'], 'lo*': ['lot', 'log'], 'l*g': ['log'], 'c*g': ['cog'], 'co*': ['cog']})





    5




```python
from collections import defaultdict

def ladderLength(beginWord, endWord, wordList):
    """
    :type beginWord: str
    :type endWord: str
    :type wordList: List[str]
    :rtype: int
    """

    if endWord not in wordList or not endWord or not beginWord or not wordList:
        return 0

    # Since all words are of same length.
    L = len(beginWord)

    # Dictionary to hold combination of words that can be formed,
    # from any given word. By changing one letter at a time.
    all_combo_dict = defaultdict(list)
    for word in wordList:
        for i in range(L):
            # Key is the generic word
            # Value is a list of words which have the same intermediate generic word.
            all_combo_dict[word[:i] + "*" + word[i+1:]].append(word)


    # Queue for BFS
    queue = [(beginWord, 1)]
    # Visited to make sure we don't repeat processing same word.
    visited = {beginWord: True}
    while queue:
        current_word, level = queue.pop(0)      
        for i in range(L):
            # Intermediate words for current word
            intermediate_word = current_word[:i] + "*" + current_word[i+1:]

            # Next states are all the words which share the same intermediate state.
            for word in all_combo_dict[intermediate_word]:
                # If at any point if we find what we are looking for
                # i.e. the end word - we can return with the answer.
                if word == endWord:
                    return level + 1

                # Otherwise, add it to the BFS Queue. Also mark it visited
                if word not in visited:
                    visited[word] = True
                    queue.append((word, level + 1))

            all_combo_dict[intermediate_word] = []
    return 0

ladderLength("hit","cog", ["hot","dot","dog","lot","log","cog"])
```




    5



## 126. Word Ladder II (Amazon 20, Microsoft 3)


```python
# buggy 
from collections import defaultdict
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return []
    
        dic = defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                dic[word[:i] + "*" + word[i+1:]].append(word)
        
        # print(dic)
        ans = []
        
        queue = [[beginWord, [beginWord]]]
        
        # print(visited)
        length = float('inf')

        while queue:
            # print(1, queue)
            cur, res = queue.pop(0)  
            # print(res)
            for i in range(len(cur)):
                potential = cur[:i] + "*" + cur[i+1:]

                for word in dic[potential]:
                    tmp = res.copy()
                    if word == endWord:                        
                        tmp.append(word)
                        
                        if len(tmp) <= length:  
                            length = len(tmp)
                            ans.append(tmp)
                            
                    elif word not in tmp:
                        
                        tmp.append(word)
                        queue.append([word, tmp])
                
        if ans:
            return ans
                                      
        else:
            return []
```


```python
from collections import defaultdict
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        wordList = set(wordList)
        res = []
        layer = {}
        layer[beginWord] = [[beginWord]]

        while layer:
            newlayer = collections.defaultdict(list)
            for w in layer:
                if w == endWord: 
                    res.extend(k for k in layer[w])
                else:
                    for i in range(len(w)):
                        for c in 'abcdefghijklmnopqrstuvwxyz':
                            neww = w[:i]+c+w[i+1:]
                            if neww in wordList:
                                newlayer[neww]+=[j+[neww] for j in layer[w]]

            wordList -= set(newlayer.keys())
            layer = newlayer

        return res

```

## 721. Accounts Merge (Facebook 16, Amazon 8, Google 4) 


```python
class Solution(object):
    def accountsMerge(self, accounts):
        """
        :type accounts: List[List[str]]
        :rtype: List[List[str]]
        """
        email_to_name = {}
        graph = collections.defaultdict(set)
        for acc in accounts:
            # each account
            name = acc[0] # e.g. John
            for email in acc[1:]:
                # each email for an account, e.g. john1@gmail.com, john2@gmail.com
                graph[acc[1]].add(email) # draw an edge from the first email to itself and all other emails
                graph[email].add(acc[1])  # draw an edge from email to first account
                email_to_name[email] = name # map from emails to names using the same data structure
        
        # DFS
        seen = set()
        merged = []
        for email in graph:
            # each email
            if email not in seen:
                seen.add(email)
                stack = [email]
                component = []
                while stack:
                    node = stack.pop()
                    component.append(node)
                    for nei in graph[node]:
                        if nei not in seen:
                            seen.add(nei)
                            stack.append(nei)
                merged.append([email_to_name[email]] + sorted(component))
        return merged
```

## 207. Course Schedule. (Graph(List, Dict). BFS-Queue, Topological Sorting) (Amazon Onsite 25, Uber 5)  
这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。  
通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。  
拓扑排序也可以通过 BFS 完成。  

本题可约化为：课程安排图是否是 有向无环图(DAG)。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。
思路是通过 拓扑排序 判断此课程安排图是否是 有向无环图(DAG)。
拓扑排序是对 DAG 的顶点进行排序，使得对每一条有向边(u,v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。


O(V+E)  
O(V+E)


```python
from collections import defaultdict
class Solution:
    def canFinish(self, vertices, edges):
        if vertices <= 0:
            return []

        # a. Initialize the graph
        graph = defaultdict(list)  # adjacency list graph
        indegree = {i: 0 for i in range(vertices)}  # count of incoming edges

        # b. Build the graph
        for child, parent in edges:
            graph[parent].append(child)  # put the child into it's parent's list
            indegree[child] += 1  # increment child's inDegree

       # c. Find all sources i.e., all vertices with 0 in-degrees
        queue = []
        for key in indegree:
            if indegree[key] == 0:
                queue.append(key)

      # d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees
      # if a child's in-degree becomes zero, add it to the sources queue
        res = []
        while queue:
            vertex = queue.pop(0)
            res.append(vertex)
            for child in graph[vertex]:  # get the node's children to decrement their in-degrees
                indegree[child] -= 1
                if indegree[child] == 0:
                    queue.append(child)

      # topological sort is not possible as the graph has a cycle
        return len(res) == vertices
```


```python
class Solution:
    def canFinish(self, num, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        graph = collections.defaultdict(list)
        indegrees = [0] * numCourses

        for course, pre in prerequisites:
            graph[pre].append(course)
            indegrees[course] += 1

        return self.topologicalSort(graph, indegrees) == numCourses


    def topologicalSort(self, graph, indegrees):
        count = 0
        queue = []
        for i in range(len(indegrees)):
            if indegrees[i] == 0:
                queue.append(i)
        while queue:
            course = queue.pop()
            count += 1
            for i in graph[course]:
                indegrees[i] -= 1
                if indegrees[i] == 0:
                    queue.append(i)
        return count
```


```python
class Solution:
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        
        indegrees = [0 for i in range(numCourses)]
        adjacency = [[] for i in range(numCourses)]
        
        # Get the indegree and adjacency of every course.
        for cur, pre in prerequisites:
            indegrees[cur] += 1
            adjacency[pre].append(cur)
        # Get all the courses with the indegree of 0.
        
        queue = []
        for i in range(len(indegrees)):
            if not indegrees[i]: 
                queue.append(i)
        # BFS TopSort.
        while queue:
            pre = queue.pop(0)
            numCourses -= 1
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]: 
                    queue.append(cur)
        return not numCourses
```


```python
class Solution:
    def canFinish(self, num, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        
        graph = [[]] * len(num)
        visit = [0] * len(num)
        
        for x, y in prerequisites:
            graph[x].append(y)
            
        def dfs(i):
            if visit[i] == -1:
                return False
            if visit[i] == 1:
                return True
            visit[i] = -1
            for j in graph[i]:
                if not dfs(j):
                    return False
            visit[i] = 1
            return True
        
        for i in range(num):
            if not dfs(i):
                return False
        return True
```

if node v has not been visited, then mark it as 0.  
if node v is being visited, then mark it as -1. If we find a vertex marked as -1 in DFS, then their is a ring.  
if node v has been visited, then mark it as 1. If a vertex was marked as 1, then no ring contains v or its successors.  

## Course Schedule II (Amazon Onsite 14, Facebbook 5, Google 5, Microsoft 3)


```python
from collections import defaultdict
class Solution:
    def findOrder(self, vertices: int, edges: List[List[int]]) -> List[int]:      
        if vertices <= 0:
            return []
        
        # a. Initialize the graph
        graph = defaultdict(list)  # adjacency list graph
        indegree = {i: 0 for i in range(vertices)}  # count of incoming edges

        # b. Build the graph
        for child, parent in edges:
            graph[parent].append(child)  # put the child into it's parent's list
            indegree[child] += 1  # increment child's inDegree

       # c. Find all sources i.e., all vertices with 0 in-degrees
        queue = []
        for key in indegree:
            if indegree[key] == 0:
                queue.append(key)

      # d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees
      # if a child's in-degree becomes zero, add it to the sources queue
        res = []
        while queue:
            vertex = queue.pop(0)
            res.append(vertex)
            for child in graph[vertex]:  # get the node's children to decrement their in-degrees
                indegree[child] -= 1
                if indegree[child] == 0:
                    queue.append(child)
        
      # topological sort is not possible as the graph has a cycle
        if len(res) == vertices:
            return res
        
        else:
            return []
```


```python
class Solution():
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """
        graph = collections.defaultdict(list)
        indegrees = [0] * numCourses

        for course, pre in prerequisites:
            graph[pre].append(course)
            indegrees[course] += 1

        count, stack = self.topologicalSort(graph, indegrees)
        return stack if count == numCourses else []


    def topologicalSort(self, graph, indegrees):
        count = 0
        queue = []
        stack = []
        for i in range(len(indegrees)):
            if indegrees[i] == 0:
                queue.append(i)
                
        while queue:
            course = queue.pop()
            stack.append(course)
            count += 1
            for i in graph[course]:
                indegrees[i] -= 1
                if indegrees[i] == 0:
                    queue.append(i)
        return (count, stack)
```

## 269. Alien Dictionary (Graph(Dict). Queue-BFS, Topological Sorting) (Facebook 15, Amazon 14, Microsoft 6) (Hard)
O(V+E)  
O(V+E)


```python
from collections import Counter, defaultdict
class Solution:
    def alienOrder(self, words):
        if not words:
            return ""

      # a. Initialize the graph
        indegree = {}  # count of incoming edges
        graph = defaultdict(list)  # adjacency list graph
        for word in words:
            for character in word:
                indegree[character] = 0
                graph[character] = []

      # b. Build the graph
        for i in range(0, len(words)-1):
        # find ordering of characters from adjacent words
            w1, w2 = words[i], words[i + 1]
            
            for j in range(min(len(w1), len(w2))):
                parent, child = w1[j], w2[j]
                if parent != child:  # if the two characters are different
                # put the child into it's parent's list
                    graph[parent].append(child)
                    indegree[child] += 1  # increment child's inDegree
                    break  # only the first different character between the two words will help us find the order
                    
            else:
                if len(w2) < len(w1): # Check that second word isn't a prefix of first word.
                    return ""
            
      # c. Find all sources i.e., all vertices with 0 in-degrees
        queue = []
        for key in indegree:
            if indegree[key] == 0:
                queue.append(key)

      # d. For each source, add it to the sortedOrder and subtract one from all of its children's in-degrees
      # if a child's in-degree becomes zero, add it to the sources queue
        res = []
        while queue:
            vertex = queue.pop(0)
            res.append(vertex)
            for child in graph[vertex]:  # get the node's children to decrement their in-degrees
                indegree[child] -= 1
                if indegree[child] == 0:
                    queue.append(child)

      # if sortedOrder doesn't contain all characters, there is a cyclic dependency between characters, therefore, we
      # will not be able to find the correct ordering of the characters
        if len(res) != len(indegree):
            return ""

        return ''.join(res)
```


```python
words = ['ba', 'bc', 'ac', 'cab']
s = Solution()
s.alienOrder(words)
```

    {'b': 0, 'a': 1, 'c': 2}
    {'b': ['a'], 'a': ['c', 'c'], 'c': []}





    'bac'



## Project Dependencies


```python
from collections import defaultdict
class Solution:
    def find_dependencies(self, projects, dependencies, vertices):
        
        graph = defaultdict(list)
        indegree = {i:0 for i in range(vertices)}
        for parent, child in depenedencies:
            graph[parent].append(child)
            indegree[child] += 1
            
        queue = []
        for vertice in indegree:
            if indegree[graph] == 0:
                queue.append(vertice)
                
        res = []
        
        while queue:
            node = queue.pop(0)
            if node in projects:
                res.append(node)
                projects.remove(node)
                
            for child in graph[node]:
                indegree[child] -= 1
                if indegree[child] == 0:
                    queue.append(child)
            
        if len(queue) == vertices:
            return projects + res
            
        else:
            return False
        
```


```python
array =[1,2]
array.remove(2)
array
```




    [1]



## 684 Redundant Connection (Graph. Union Find) (Amazon 2, Google)


```python
class Solution:
    def findRedundantConnection(self, edges):
        def findRoot(x):
            if tree[x] == x:
                return x
            else:
                root = findRoot(tree[x])
                # tree[x] = root
                return root
        
        tree = [i for i in range(len(edges) + 1)]

        for edge in edges:
            a = findRoot(edge[0])
            b = findRoot(edge[1])
            if a != b:
                tree[a] = b
            else:
                return edge

               
# class Solution:
#     def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
#         p = [*range(len(edges) + 1)]      #并查集元素初始化
#         print(p)
#         def f(x):
#             if p[x] != x:       #递归修改所属集合
#                 p[x] = f(p[x])
#             return p[x]
#         for x, y in edges:      #遍历边
#             px, py = f(x), f(y)
#             if px != py:        #检查集合，如果集合不同就合并
#                 p[py] = px
#             else:
#                 return [x, y]   #集合相同就返回答案
```

685. Redundnat Connection II

### Design

## 384. Shuffle an Array (List. Pointer) (Amazon Onsite 7, Microsoft 3, Apple 2)


```python
from random import randint
class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums
        self.original = nums.copy()

    def reset(self) -> List[int]:
        """
        Resets the array to its original configuration and return it.
        """
        self.nums = self.original.copy()     
        return self.nums 
        

    def shuffle(self) -> List[int]:
        """
        Returns a random shuffling of the array.
        """        
        for i in range(len(self.nums)):
            rand = randint(i, len(self.nums) - 1)
            self.nums[i], self.nums[rand] = self.nums[rand], self.nums[i]
        
        return self.nums
```


```python
import random
class Deck:
    def __init__(self):
        self.suits = ['D', 'S', 'F', 'T']
        self.faces = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
        
        self.deck = []
        for face in self.faces:
            for suit in self.suits:
                self.deck.append(face + suit)
                

        
game = Deck()
game.deck
```




    ['AD',
     'AS',
     'AF',
     'AT',
     '2D',
     '2S',
     '2F',
     '2T',
     '3D',
     '3S',
     '3F',
     '3T',
     '4D',
     '4S',
     '4F',
     '4T',
     '5D',
     '5S',
     '5F',
     '5T',
     '6D',
     '6S',
     '6F',
     '6T',
     '7D',
     '7S',
     '7F',
     '7T',
     '8D',
     '8S',
     '8F',
     '8T',
     '9D',
     '9S',
     '9F',
     '9T',
     '10D',
     '10S',
     '10F',
     '10T',
     'JD',
     'JS',
     'JF',
     'JT',
     'QD',
     'QS',
     'QF',
     'QT',
     'KD',
     'KS',
     'KF',
     'KT']




```python
matrix = [[0 for n in range(2)] for n in range(3)] 
matrix
```




    [[0, 0], [0, 0], [0, 0]]



## 470. Implement Rand10() Using Rand7() (Microsoft 4)


```python
# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7

class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        row = rand7()
        col = rand7()
        index = col + (row - 1) * 7
        
        while index > 40:
            row = rand7()
            col = rand7()
            index = col + (row - 1) * 7
            
        return 1 + (index - 1) % 10
```

## 729. My Calendar I (Google 5, Amazon 2, Apple 2)


```python
class MyCalendar(object):

    def __init__(self):
        self.intervals = []

    # O(n)
    def book(self, start, end):
        """
        :type start: int
        :type end: int
        :rtype: bool
        """
        if not self.intervals or end <= self.intervals[0][0]:
            self.intervals = [[start, end]] + self.intervals
            return True
        
        if self.intervals[-1][1] <= start:
            self.intervals.append([start, end])
            return True
            
        for ind in range(1, len(self.intervals)):
            i = self.intervals[ind]
            prev = self.intervals[ind - 1]
            if start >= prev[1] and end <= i[0]:
                self.intervals.insert(ind, [start, end])
                return True
            
        return False
```

## 341. Flatten Nested List Iterator (Stack) (Amazon 16->4, Apple 5, Facebook 4)


```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger(object):
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class NestedIterator():

    def __init__(self, nestedList):
        """
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        """
        self.stack = nestedList

    def next(self):
        """
        :rtype: int
        """

        return self.stack.pop(0).getInteger()

    def hasNext(self):
        """
        :rtype: bool
        """
        if not self.stack:
            return False
        
        while self.stack:
            if self.stack[0].isInteger():
                return True
            
            self.stack = self.stack[0].getList() + self.stack[1:] 
        

# Your NestedIterator object will be instantiated and called as such:
# i, v = NestedIterator(nestedList), []
# while i.hasNext(): v.append(i.next())
```

## 281. ZigZag Iterator (Google 4, Facebook 2, Microsoft 2, Amazon 2, Apple 2)


```python
class ZigzagIterator:
    def __init__(self, v1, v2):
        """
        Initialize your data structure here.
        :type v1: List[int]
        :type v2: List[int]
        """
        self.v = collections.deque()
        i, j = 0, 0
        idx = 0
        while i < len(v1) and j < len(v2):
            if idx % 2 == 0:
                self.v.append(v1[i])
                i += 1
            else:
                self.v.append(v2[j])
                j += 1
            idx += 1
        self.v.extend(v1[i:])
        self.v.extend(v2[j:])

    def next(self):
        """
        :rtype: int
        """
        return self.v.popleft()

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.v
```

## 284. Peeking Iterator (Apple 10, Facebook 4, Google 4, Amazon 2)


```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        self._iterator = iterator
        self._peeked_value = None

    def peek(self):
        # If there's not already a peeked value, get one out and store
        # it in the _peeked_value variable. We aren't told what to do if
        # the iterator is actually empty -- here I have thrown an exception
        # but in an interview you should definitely ask! This is the kind of
        # thing they expect you to ask about.
        if not self._peeked_value:
            if not self._iterator.hasNext():
                raise StopIteration()
            self._peeked_value = self._iterator.next()
        
        return self._peeked_value

    def next(self):
        # Firstly, we need to check if we have a value already
        # stored in the _peeked_value variable. If we do, we need to
        # return it and also set _peeked_value to null so that the value
        # isn't returned again.
        if self._peeked_value: 
            to_return = self._peeked_value
            self._peeked_value = None
            return to_return
        
        if not self._iterator.hasNext():
            raise StopIteration()
        
        # Otherwise, we need to return a new value.
        return self._iterator.next()

    def hasNext(self):
        # If there's a value waiting in _peeked_value, or if there are values
        # remaining in the iterator, we should return true.
        return self._peeked_value is not None or self._iterator.hasNext()

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

## 251. Flatten 2D Vector (Apple)


```python
class Vector2D:

    def __init__(self, vec2d):
        """
        Initialize your data structure here.
        :type vec2d: List[List[int]]
        """
        self.inner = 0
        self.outer = 0
        self.vec = vec2d
        
    def move_next(self):
        while self.outer < len(self.vec) and self.inner == len(self.vec[self.outer]):

            self.inner = 0
            self.outer += 1

    def next(self):
        """
        :rtype: int
        """
        
        self.move_next()
        
        res = self.vec[self.outer][self.inner]
        self.inner += 1
        return res


    def hasNext(self):
        """
        :rtype: bool
        """
        self.move_next()

        return self.outer < len(self.vec)
```

## 232. Implement Queue using Stacks (Stack) (Microsoft Onsite 8)


```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack1 = []
        self.stack2 = []
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.stack1.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        if self.stack2:
            return self.stack2.pop()
            
        else:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
                
            return self.stack2.pop()
        

    def peek(self) -> int:
        """
        Get the top element.
        """
        if self.stack2:
            return self.stack2[-1]
        
        else:
            return self.stack1[0]
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.stack1) + len(self.stack2) == 0
```


```python
from collections import deque
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = deque()
        
    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.queue.append(x)

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns
        """
        return self.queue.popleft()
        
    def peek(self) -> int:
        """
        Get the front element.
        """
        return self.queue[0]

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return len(self.queue) == 0
```


```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack = []
        self.stack2 = []
        
    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.stack.append(x)

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns
        """
        if not self.stack:
            return
        
        while self.stack:
            self.stack2.append(self.stack.pop())
            
        res = self.stack2.pop()
        
        while self.stack2:
            self.stack.append(self.stack2.pop())
        
        return res
        
    def peek(self) -> int:
        """
        Get the front element.
        """
        return self.stack[0]

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return len(self.stack) == 0
```


```python
num = [1,2,3]
def function(num):
    if sum(num)  > 0:
        return True
    if sum(num) < 0:
        return False
    
function(num)
    
```




    True



## 225. Implement Stack using Queues (Queue) (Microsoft 6, Amazon 4)


```python
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = []
        # self.queue2 = []
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        if not self.queue:
            return 

        for n in range(len(self.queue)-1):
            self.queue.append(self.queue.pop(0))
            
        return self.queue.pop(0)
        

    def top(self) -> int:
        """
        Get the top element.
        """
#         return self.queue[-1]

        for _ in range(len(self.queue)):
            temp = self.queue.pop(0)
            self.queue.append(temp)
        return temp
        

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.queue) == 0
        
```


```python
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = []
        self.queue2 = []

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue.append(x)


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        if not self.queue:
            return 
        
        for i in range(len(self.queue)-1):
            self.queue2.append(self.queue.pop(0))
            
        res = self.queue.pop(0)
        
        while self.queue2:
            self.queue.append(self.queue2.pop(0))
        
        return res
        

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[-1]

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.queue) == 0 
```


```python
from collections import deque
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack = deque()

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.stack.append(x)
        

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.stack.pop()

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.stack[-1]

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.stack) == 0
```

## (2) 346. Moving Average from Data Stream (Amazon 5)


```python
class MovingAverage:

    def __init__(self, size):
        """
        Initialize your data structure here.
        :type size: int
        """
        self.array = []
        self.sum = 0
        
        self.cur_size = 0
        self.size = size
        

    def next(self, val):
        """
        :type val: int
        :rtype: float
        """
        
        if self.cur_size < self.size:
            self.array.append(val)
            self.sum += val
            self.cur_size += 1
        
            return self.sum / self.cur_size
            
        else:
            delete = self.array.pop(0)
            self.array.append(val)
            self.sum = self.sum - delete + val
            return self.sum / self.size
```


```python
class MovingAverage:

    def __init__(self, size):
        """
        Initialize your data structure here.
        :type size: int
        """
        self.res = []
        self.size = size

    def next(self, val):
        """
        :type val: int
        :rtype: float
        """
        self.res.append(val)
        
        if len(self.res) <= self.size:
            return sum(self.res) / len(self.res)
            
        else:
            self.res.pop(0)
            return sum(self.res) / len(self.res)
```

## 348. Design Tic Tac Toe (Matrix) (Amazon 16, Microsoft 6)
O(1)  
O(N)


```python
class TicTacToe:
    def __init__(self, n):
        """
        Initialize your data structure here.
        :type n: int
        """
        self.row = [0] * n
        self.col = [0] * n
        self.diag = 0
        self.undiag = 0
        self.n = n
        
    def move(self, row, col, player):
        """
        Player {player} makes a move at ({row}, {col}).
        @param row The row of the board.
        @param col The column of the board.
        @param player The player, can be either 1 or 2.
        @return The current winning condition, can be either:
                0: No one wins.
                1: Player 1 wins.
                2: Player 2 wins.
        :type row: int
        :type col: int
        :type player: int
        :rtype: int
        """
        if player == 1:
            p = 1
        else:
            p = -1
        
        self.row[row] += p
        self.col[col] += p
        
        if row == col:
            self.diag += p
        if row + col == self.n - 1:
            self.undiag += p
            
        if (abs(self.row[row]) == self.n or 
            abs(self.col[col]) == self.n or 
            abs(self.diag) == self.n or 
            abs(self.undiag) == self.n):
            return player
        else:
            return 0
        
# Your TicTacToe object will be instantiated and called as such:
# obj = TicTacToe(n)
# param_1 = obj.move(row,col,player)
```

## 1275. Find Winner on a Tic Tac Toe Game (Microsoft Onsite, Amazon 2)


```python
class Solution:
    def tictactoe(self, moves):
        """
        :type moves: List[List[int]]
        :rtype: str
        """
        row = [0] * 3
        col = [0] * 3
        diagonal = 0
        diagonal2 = 0
        
        count = 0
        
        for i, array in enumerate(moves):
            x = array[0]
            y = array[1]
            count += 1
            if not i % 2:
                p = 1
                
            else:
                p = -1
                
            row[x] += p
            col[y] += p

            if x == y:
                diagonal += p

            if x + y == 2:
                diagonal2 += p

            if row[x] == 3 or col[y] == 3 or diagonal == 3 or diagonal2 == 3:
                return 'A'
            
            elif row[x] == -3 or col[y] == -3 or diagonal == -3 or diagonal2 == -3:
                return 'B'
                         
        if count < 9:
            return 'Pending'
        
        else:
            return 'Draw'
```

## 155. Min Stack (List and heapq) (Amazon Onsite 16, Microsoft 8, Google 7, Apple 5)



```python
class MinStack(object):

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min = []
        

    def push(self, x):
        """
        :type x: int
        :rtype: void
        """
        self.stack.append(x)
        if not self.min:
            self.min.append(x)
        else:
            self.min.append(min(self.min[-1], x))

    def pop(self):
        """
        :rtype: void
        """
        self.stack.pop()
        self.min.pop()

    def top(self):
        """
        :rtype: int
        """
        return self.stack[-1]

    def getMin(self):
        """
        :rtype: int
        """
        return self.min[-1]
```


```python
# push O(1) + pop O(lgN) + top O(1) + getMin O(1)  
# O(N)
from heapq import *

class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.array = []
        self.heap = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        
        self.array.append(x)
        heappush(self.heap,x)

    def pop(self):
        """
        :rtype: None
        """
        
        val = self.array.pop()
        self.heap.remove(val)
        heapify(self.heap)

    def top(self):
        """
        :rtype: int
        """
        
        return self.array[-1]

    def getMin(self):
        """
        :rtype: int
        """
        return self.heap[0]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```


```python
array = [1,2,3]
array.rfind(3)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-7-983f5a03c335> in <module>
          1 array = [1,2,3]
    ----> 2 array.rfind(3)
    

    AttributeError: 'list' object has no attribute 'rfind'


## 716. Max Stack (List, heapq) (Microsoft Onsite, Linkedin 14, Amazon Onsite 4, Google Phone)


```python
from collections import deque
class MaxStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.maximo = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        
        if not self.maximo:
            self.maximo.append(x)
            
        else:
            self.maximo.append(max(x, self.maximo[-1]))

        # m = max(x, self.maximo[-1])
        # self.append((x, m))

    def pop(self) -> int:
        self.maximo.pop()
        return self.stack.pop()

    def top(self) -> int:
        if not self.stack:
            return
        
        return self.stack[-1]

    def peekMax(self) -> int:
        if not self.maximo:
            return
        
        return self.maximo[-1]
        

    def popMax(self) -> int:
        maximo = self.maximo[-1]
        
        b = deque()
        
        while self.stack[-1] != maximo:
            b.appendleft(self.pop())

        self.pop()
        for n in b:
            self.push(n)
            
        return maximo
```


```python
class MaxStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        

    def push(self, x: int) -> None:
        self.stack.append(x)

    def pop(self) -> int:
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def peekMax(self) -> int:
        maximum = max(self.stack)
        return maximum
        

    def popMax(self) -> int:
        maximum = max(self.stack)
        for i in range(len(self.stack)-1, -1, -1):
            if self.stack[i] == maximum:
                self.stack.pop(i)
                return maximum
            
            
self.maximo
insort()
```


```python
import heapq
class MaxStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.heap = []
        

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        
        self.stack.append(x)
        heapq.heappush(self.heap, -x)

    def pop(self):
        """
        :rtype: int
        """
        item = self.stack.pop()
        self.heap.remove(-item)
        heapq.heapify(self.heap)
        return item
        
    def top(self) :
        """
        :rtype: int
        """
        return self.stack[-1]

    def peekMax(self):
        """
        :rtype: int
        """
        return - self.heap[0]

    def popMax(self) :
        """
        :rtype: int
        """
#         maxi = - self.heap.pop(0)
#         heapq.heapify(self.heap)

        maxi = - heapq.heappop(self.heap)
        for i in range(len(self.stack)-1, -1,-1):
            if self.stack[i] == maxi:
                self.stack.pop(i)
                return maxi
```


```python
import heapq
class MaxStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.heap = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        
        self.stack.append(x)
        heapq.heappush(self.heap, -x)

    def pop(self):
        """
        :rtype: int
        """
        item = self.stack.pop()
        self.heap.remove(-item)
        heapq.heapify(self.heap)
        return item
        
    def top(self) :
        """
        :rtype: int
        """
        return self.stack[-1]

    def peekMax(self):
        """
        :rtype: int
        """
        return - self.heap[0]

    def popMax(self) :
        """
        :rtype: int
        """
#         maxi = - self.heap.pop(0)
#         heapq.heapify(self.heap)

        maxi = - heapq.heappop(self.heap)
        for i in range(len(self.stack)-1, -1,-1):
            if self.stack[i] == maxi:
                self.stack.pop(i)
                return maxi
```

## 295. Find Median From Data Stream (heapq) (Amazon Onsite 37-1, Google 11, Microsoft 4, Facebook 4) (Hard)


```python
# O(logN)  
# O(N)
from heapq import *
class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))
        else:
            heappush(self.small, -heappushpop(self.large, num))

    def findMedian(self):
        if len(self.small) == len(self.large):
            return (self.large[0] - self.small[0]) / 2
        else:
            return self.large[0]
        
# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```


```python
from heapq import *
class MedianFinder:
    """According to
    https://leetcode.com/discuss/64850/short-simple-java-c-python-o-log-n-o-1
    keep two heaps (or priority queues):
        1. Max-heap small has the smaller half of the numbers.
        2. Min-heap large has the larger half of the numbers.
    This gives me direct access to the one
    or two middle values (they're the tops of the heaps)
    """
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        heappush(self.small, -heappushpop(self.large, num))
        
        if len(self.small) != len(self.large):
            heappush(self.large, -heappop(self.small))
            
    def findMedian(self):
        if len(self.small) == len(self.large):
            return (self.large[0] - self.small[0]) / 2
        else:
            return self.large[0]
        
#     def __init__(self):
#         self.small, self.large = [], []
#         self.count = 0

#     def addNum(self, num):
#         self.count += 1
#         # Python has no max-heap, so we do some trick here by keep the -num in
#         # smaller half, then the max num will be at the top of the heap.
#         heappush(self.small, -heappushpop(self.large, num))
#         if self.count & 1:
#             heappush(self.large, -heappop(self.small))

#     def findMedian(self):
#         if self.count & 1:
#             return float(self.large[0])
#         else:
#             return (self.large[0] - self.small[0]) / 2.0
```

## 706. Design HashMap (list) (Amazon 10, Microsoft 3)


```python
3 % 20011
```




    3




```python
class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.hash = [[] for _ in range(20011)]  # 开辟一个大数组，长度为质数，注意这里不能用 [[]] * 20011
        # 一般定义成离2的整次幂比较远的质数，这样取模之后冲突的概率比较低。

    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        t = key % 20011
        for item in self.hash[t]:  # 遍历哈希到的链表中，查找key,并更新值
            if item[0] == key:
                item[1] = value
                return  # 更新完之后，直接返回
        self.hash[t].append((key, value))  # 如果链表中找不到对应的key，将其新添到链表中

    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        t = key % 20011
        for item in self.hash[t]:
            if item[0] == key:
                return item[1]
        return -1  # 可能哈希的位置，所对应的链表不为空，但是不存在该值

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        t = key % 20011

        for item in self.hash[t]:
            if item[0] == key:
                self.hash[t].remove(item)  # remove方法，这里可以偷懒，把对应的value值设为-1，即表示它已经删除
```


```python
class MyHashMap:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.map = {}

    def put(self, key: int, value: int) -> None:
        """
        value will always be non-negative.
        """
        self.map[key] = value

    def get(self, key: int) -> int:
        """
        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
        """
        if key not in self.map:
            return -1
        return self.map[key]

    def remove(self, key: int) -> None:
        """
        Removes the mapping of the specified value key if this map contains a mapping for the key
        """
        if key in self.map:
            del self.map[key]
```


```python
dic = {1:2}
```


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-3-6de9defdc17b> in <module>
          1 dic = {1:2}
    ----> 2 dic.pop(3)
          3 dic


    KeyError: 3


## 146. LRU cache (OrderedDict) (Amazon 60->83, Microsoft Onsite 22, Apple 13, Google 7)
时间复杂度: O(1)  
O(1)


```python
class LRUCache:
    def __init__(self, capacity):
        """
        :type capacity: int
        """
        
        self.cache = {}
        self.capacity = capacity

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.cache:
            return -1
            
        val = self.cache[key]
        self.cache.pop(key)
        self.cache[key] = val
        return val
        
    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """
        if key in self.cache:
            self.cache.pop(key)
            
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            for k in self.cache:
                self.cache.pop(k)
                break
                
        
```


```python
class Node:
    def __init__(self, k, v):
        self.key = k
        self.val = v
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.dic = dict()
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        if key not in self.dic:
            return -1

        n = self.dic[key]
        self._remove(n)
        self._add(n)
        return n.val


    def put(self, key, value):
        if key in self.dic:
            self._remove(self.dic[key])

        n = Node(key, value)
        self._add(n)
        self.dic[key] = n
        if len(self.dic) > self.capacity:
            n = self.head.next
            self._remove(n)
            self.dic.pop(n.key)

    def _remove(self, node):
        p = node.prev
        n = node.next
        p.next = n
        n.prev = p

    def _add(self, node):
        p = self.tail.prev
        p.next = node
        node.prev = p
        node.next = self.tail
        self.tail.prev = node
```


```python
class LRUCache {
  // HashMap: <key = Question, value = ListNode>
  // LinkedList: <Answer>

  public static class Node {
      int key;
      int val;
      Node next;
      Node prev;
      public Node(int key, int val) {
          this.key = key;
          this.val = val;
      }
  }

  Map<Integer, Node> map = new HashMap<>();
  private Node head;
  private Node tail;
  private int cap;

  public LRUCache(int capacity) {
      cap = capacity;
  }

  public int get(int key) {
      Node node = map.get(key);
      if(node == null) {
          return -1;
      } else {
          int res = node.val;
          remove(node);
          appendHead(node);
          return res;
      }
  }

  public void put(int key, int value) {
      // 先 check 有没有这个 key
      Node node = map.get(key);
      if(node != null) {
          node.val = value;
          // 把这个node放在最前面去
          remove(node);
          appendHead(node);
      } else {
          node = new Node(key, value);
          if(map.size() < cap) {
              appendHead(node);
              map.put(key, node);
          } else {
              // 踢走老的
              map.remove(tail.key);
              remove(tail);
              appendHead(node);
              map.put(key, node);
          }
      }
  }

  private void appendHead(Node node) {
      if(head == null) {
          head = tail = node;
      } else {
          node.next = head;
          head.prev = node;
          head = node;
      }
  }

  private void remove(Node node) {
      // 这里我写的可能不是最 elegant 的，但是是很 readable 的
      if(head == tail) {
          head = tail = null;
      } else {
          if(head == node) {
              head = head.next;
              node.next = null;
          } else if (tail == node) {
              tail = tail.prev;
              tail.next = null;
              node.prev = null;
          } else {
              node.prev.next = node.next;
              node.next.prev = node.prev;
              node.prev = null;
              node.next = null;
          }
      }
  }


}

/**
* Your LRUCache object will be instantiated and called as such:
* LRUCache obj = new LRUCache(capacity);
* int param_1 = obj.get(key);
* obj.put(key,value);
*/
```

O(1)  
O(capacity)


```python
from collections import OrderedDict
class LRUCache(OrderedDict):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self:
            return -1
        
        self.move_to_end(key)        
        return self[key]
    
    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self:
            self.move_to_end(key)
            
        self[key] = value
        
        if len(self) > self.capacity:
            self.popitem(last = False)

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

## 380. Insert Delete GetRandom O(1) (List, Dict) (Amazon 14, Facebook 11, Google 5 Microsoft 5)  
O(1)  
O(N)


```python
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.array = []
        self.dic = {}

    def insert(self, val):
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        :type val: int
        :rtype: bool
        """
        if val not in self.dic:
            self.array.append(val)
            self.dic[val] = len(self.array) - 1
            return True
        
        return False
        

    def remove(self, val):
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        :type val: int
        :rtype: bool
        """
        if val in self.dic:
            index = self.dic[val]
            self.dic[self.array[-1]] = index
            self.array[index] = self.array[-1]
            self.array.pop()
            self.dic.pop(val)
            
            return True
        
        return False
        

    def getRandom(self):
        """
        Get a random element from the set.
        :rtype: int
        """
        return random.choice(self.array)
```


```python
dic = {1:2, 2:3}
dic.pop(1, 0)
dic
```




    {2: 3}



## 359. Logger Rate Limiter (Dict) (Google 11)


```python
class Logger:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dic = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message in self.dic and timestamp - self.dic[message] < 10: 
                return False
    
        self.dic[message] = timestamp
        return True
```

## 981. Time Based Key-Value Store (Dict) (Google 10, Amazon Onsite 7-1, Apple 8)


```python
class TimeMap:
    def __init__(self):
        self.times = collections.defaultdict(list)
        self.values = collections.defaultdict(list)
        
        # self.dic = collections.defaultdict(list)

    def set(self, key, value, timestamp):
        """
        :type key: str
        :type value: str
        :type timestamp: int
        :rtype: None
        """
        self.times[key].append(timestamp)
        self.values[key].append(value)
        
        # self.dic[key].append((timestamp, value))

    def get(self, key, timestamp):
        """
        :type key: str
        :type timestamp: int
        :rtype: str
        """
        if key not in self.values:
            return ''
        
        array = self.times[key]
        
        left = 0
        right = len(array) - 1
        
        if timestamp < array[0]:
            return ''
        
        if timestamp > array[-1]:
            return self.values[key][-1]
        
        while left <= right:
            mid = left + (right - left) // 2
            
            if array[mid] == timestamp:
                return self.values[key][mid]
            
            elif array[mid] > timestamp:
                right = mid - 1
                
            elif array[mid] < timestamp:
                left = mid + 1
                
        return self.values[key][right]
```


```python
# For each key we get or set, we only care about the timestamps and values for that key. We can store this information in a HashMap.
# Now, for each key, we can binary search the sorted list of timestamps to find the relevant value for that key.
import collections

class TimeMap:
    def __init__(self):
        self.times = collections.defaultdict(list)
        self.values = collections.defaultdict(list)

    def set(self, key, value, timestamp):
        """
        :type key: str
        :type value: str
        :type timestamp: int
        :rtype: None
        """
        self.times[key].append(timestamp)
        self.values[key].append(value)

    def get(self, key, timestamp):
        """
        :type key: str
        :type timestamp: int
        :rtype: str
        """
        
        i = bisect.bisect(self.times[key], timestamp)
        return self.values[key][i - 1] if i else ''
```


```python
chr(127)
```




    '\x7f'




```python
class TimeMap(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dic = collections.defaultdict(list)

    def set(self, key, value, timestamp):
        """
        :type key: str
        :type value: str
        :type timestamp: int
        :rtype: None
        """
        self.dic[key].append((timestamp, value))

    def get(self, key, timestamp):
        """
        :type key: str
        :type timestamp: int
        :rtype: str
        """
        array = self.dic.get(key)
        if not array: 
            return ""
        
        i = bisect.bisect(array, (timestamp, '~'))
        
        return array[i-1][1] if i else ""
        
```

## Design Queue using LinkedList (Microsoft Onsite)


```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```


```python
node = Node(2)
node.data
```




    2




```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.head = None
        self.tail = None
 
    def enqueue(self, data):
        if not self.head:
            self.head = = self.tail = Node(data)

        else:
            self.tail.next = Node(data)
            self.tail = self.tail.next
 
    def dequeue(self):
        if not self.head:
            return None
        
        to_return = self.head.data
        
        if self.head is self.tail:
            self.head = self.tail = None
        
        else:
            self.head = self.head.next
            
        return to_return
    
    def print_queue(self):
        if not self.head:
            print('Empty queue')
            
        else:
            p = self.head
            while p:
                print(p)
                p = p.next
```


```python
queue = Queue()
queue.enqueue(1)
queue.enqueue(3)
queue.print_queue()

```

    <__main__.Node object at 0x7fe3ba58c670>
    <__main__.Node object at 0x7fe3ba58cbe0>


## 622. Design Circular Queue (Facebook 5, Amazon 5, Microsoft 4, Google 3)


```python
class Node:
    def __init__(self, value, nextNode=None):
        self.value = value
        self.next = nextNode

class MyCircularQueue:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.capacity = k
        self.head = None
        self.tail = None
        self.count = 0

    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        
        if self.count == 0:
            self.head = self.tail = Node(value)
        else:
            self.tail.next = Node(value)
            self.tail = self.tail.next
        self.count += 1
        return True


    def deQueue(self) -> bool:
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        """
        if self.count == 0:
            return False
        self.head = self.head.next
        self.count -= 1
        return True


    def Front(self) -> int:
        """
        Get the front item from the queue.
        """
        if self.count == 0:
            return -1
        return self.head.value

    def Rear(self) -> int:
        """
        Get the last item from the queue.
        """
        # empty queue
        if self.count == 0:
            return -1
        return self.tail.value
    
    def isEmpty(self) -> bool:
        """
        Checks whether the circular queue is empty or not.
        """
        return self.count == 0

    def isFull(self) -> bool:
        """
        Checks whether the circular queue is full or not.
        """
        return self.count == self.capacity
```

## 641. Design Circular Deque (Facebook 3)


```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class MyCircularDeque:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the deque to be k.
        """
        self.capacity = k
        self.head = None
        self.tail = None
        self.count = 0

    def insertFront(self, value: int) -> bool:
        """
        Adds an item at the front of Deque. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        
        node = Node(value)
        if not self.head:
            self.head = self.tail = node
        
        else:
            node.next = self.head
            self.head.prev = node
            self.head = self.head.prev
            
        self.count += 1
        return True
        

    def insertLast(self, value: int) -> bool:
        """
        Adds an item at the rear of Deque. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        
        node = Node(value)
        if not self.tail:
            self.head = self.tail = node
            
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = self.tail.next
            
        self.count += 1
        return True

    def deleteFront(self) -> bool:
        """
        Deletes an item from the front of Deque. Return true if the operation is successful.
        """
        if not self.head:
            return False
        
        if self.head is self.tail:
            self.head = self.tail = None
            
        else:
            self.head = self.head.next
            self.head.prev = None
 
        self.count -= 1
        return True

    def deleteLast(self) -> bool:
        """
        Deletes an item from the rear of Deque. Return true if the operation is successful.
        """
        if not self.tail:
            return False
        
        if self.head is self.tail:
            self.head = self.tail = None
            
        else:
            self.tail = self.tail.prev
            self.tail.next = None
            
        self.count -= 1
        return True
        

    def getFront(self) -> int:
        """
        Get the front item from the deque.
        """
        if not self.head:
            return -1
        
        return self.head.data
        

    def getRear(self) -> int:
        """
        Get the last item from the deque.
        """
        if not self.tail:
            return -1
        
        return self.tail.data

    def isEmpty(self) -> bool:
        """
        Checks whether the circular deque is empty or not.
        """
        return self.count == 0

    def isFull(self) -> bool:
        """
        Checks whether the circular deque is full or not.
        """
        return self.count == self.capacity
```

## Implement Double-ended Queue (Amazon Onsite)  
https://www.geeksforgeeks.org/implementation-deque-using-doubly-linked-list/


```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class Dequeue:
    def __init__(self):
        self.head = None
        self.tail = None
 
    def insert_head(self, data):
        node = Node(data)
        if not self.head:
            self.head = self.tail = node
        
        else:
            node.next = self.head
            self.head.prev = node
            self.head = self.head.prev
            
    def insert_tail(self, data):
        node = Node(data)
        if not self.tail:
            self.head = self.tail = node
            
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = self.tail.next
            
    def delete_head(self):
        if not self.head:
            return None
        
        if self.head is self.tail:
            self.head = self.tail = None
            
        else:
            self.head = self.head.next
            self.head.prev = None
 
    def delete_tail(self):
        if not self.tail:
            return None
        
        if self.head is self.tail:
            self.head = self.tail = None
            
        else:
            self.tail = self.tail.prev
            self.tail.next = None
```

## 382. Linked List Random Node 382. Linked List Random Node (Apple, Google 2)


```python
from random import random
class Solution(object):

    def __init__(self, head):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        :type head: ListNode
        """
        self.head = head

    def getRandom(self):
        """
        Returns a random node's value.
        :rtype: int
        """
        max_p = -1
        cur = self.head
        res = 0
        while cur:
            cur_p = random()
            if cur_p > max_p:
                res = cur.val
                max_p = cur_p
            cur = cur.next
                
        return res
```


```python
import random
random.random()
```




    0.8900862575479049



## 449. Serialize and Deserialize BST (Amazon 6, Microsoft 4, Facebook 3)

O(N)  
O(N)


```python
class Codec: 
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()
```


```python
''.join(['a'])
```




    'a'




```python
[1] + [2]
```




    [1, 2]




```python
str([4,3,2])
```




    '[4, 3, 2]'




```python
list(map(str, [4,3,2]))
```




    ['4', '3', '2']




```python
' '.join(map(str, [4,3,2]))
```




    '4 3 2'




```python
s = '2ss'
s.pop()
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-14-90db7ff1c2db> in <module>
          1 s = '2ss'
    ----> 2 s.pop()
    

    AttributeError: 'str' object has no attribute 'pop'


## 297. Serialize and Deserialize Binary Tree (BFS-Queue) (Facebook 29, Amazon Onsite 27-1, Linkedin 9, Microsoft 9, Google 5)

O(N)  
O(N)


```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        

        s = ""
        queue = [root]

        while queue:
            node = queue.pop(0)
            if node:
                s += str(node.val)
                queue.append(node.left)
                queue.append(node.right)
            else:
                s += "n"
            s += " "        
        return s

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        
        if not data or data[0] == 'n':
            return
 
        data = data.split()
        
        root = TreeNode(int(data[0]))
        queue = [root]
        i = 1
        
        while queue:
            node = queue.pop(0)      
            node.left = TreeNode(int(data[i])) if data[i] != 'n' else None
            node.right = TreeNode(int(data[i+1])) if data[i+1] != 'n' else None
            
            if node.left:    
                queue.append(node.left)
            if node.right:
                queue.append(node.right)           
            i += 2
        return root
        

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```


```python
dic = {1:2, 2:3}
dic.pop(1, 0)
dic
```




    {2: 3}




```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        
        self.res = ''
        self.dfs(root)
        return self.res
        
    def dfs(self, root):
        if not root:
            self.res += '#'
            self.res += ' '
            return

        self.res += str(root.val)
        self.res += ' '

        self.dfs(root.left)
        self.dfs(root.right)
            
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data or data[0] == '#':
            return 
        
        data = data.split()
        
        return self.div_conquer(data)
        
    def div_conquer(self, data):
        if not data:
            return 
    
        first = data.pop(0)
        if first == '#':
            return
        
        root = TreeNode(first)
        root.left = self.div_conquer(data)
        root.right = self.div_conquer(data)
        
        return root
```


```python
s = '1 2 3 '
s.split()
```




    ['1', '2', '3']




```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        
        self.res = ''
        self.dfs(root)
        return self.res
        
    def dfs(self, root):
        if not root:
            self.res += '#'
            self.res += ' '
            return

        self.dfs(root.left)
        self.dfs(root.right)
        
        self.res += str(root.val)
        self.res += ' '
            
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data or data[-1] == '#':
            return 
        
        data = data.split()
        
        return self.div_conquer(data)
        
    def div_conquer(self, data):
        if not data:
            return 
    
        last = data.pop()
        if last == '#':
            return
        
        root = TreeNode(last)
        root.right = self.div_conquer(data)
        root.left = self.div_conquer(data)
        
        return root
```

## 428. Serialize and Deserialize N-ary Tree (Microsoft 4->6, Apple 5)
O(N)  
O(N)


```python
"""
# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""
from collections import deque
class Codec:
    def serialize(self, root: 'Node') -> str:
        """Encodes a tree to a single string.
        
        :type root: Node
        :rtype: str
        """

        if not root: 
            return ""  
        
        queue = deque([root])
        res = []
        
        while queue:
            node = queue.popleft()
            res.append(str(node.val))
            res.append(str(len(node.children)))
            for ch in node.children:
                queue.append(ch)
        # print(res)       
        # print(",".join(res))
        return ",".join(res)

    def deserialize(self, data: str) -> 'Node':
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: Node
        """        
        if not data: 
            return 
        
        data = data.split(",")
        root = Node(int(data.pop(0)), [])
        queue = deque([[root, int(data.pop(0))]])

        while queue:
            node, num = queue.popleft()
            for _ in range(num):
                nxt_node = Node(int(data.pop(0)), [])
                node.children.append(nxt_node)
                queue.append([nxt_node, int(data.pop(0))])
        return root
```


```python
class Codec:
    def serialize(self, root):
        if not root:
            return {}
        
        # if not root.children:
        #     return root.val
        
        return {'value': root.val, 'children': [self.serialize(child) for child in root.children]} 

    def deserialize(self, data):
        if not data:
            return 
        
        return Node(data['value'], [self.deserialize(child) for child in data['children']])
```


```python
iter([1,2,3])
```




    <list_iterator at 0x7fe3ba427910>



## 431. Encode N-ary Tree to Binary Tree (Microsoft 2)

The left child of a binary node is the subtree encoding all the children of the corresponding n-ary node.  
The right child of a binary node is a chain of the binary root nodes encoding each sibling of the n-ary node.  
Hence the root node has no right binary child, because the root has no sibilings.


```python
class Codec:
    def encode(self, root):
        if not root:
            return None

        binary = TreeNode(root.val)                 # create a binary root
        if not root.children:
            return binary

        binary.left = self.encode(root.children[0]) # left child of binary is the encoding of all n-ary children,
        node = binary.left                          #     starting with the first child.
        for child in root.children[1:]:             # other children of n-ary root are right child of previous child
            node.right = self.encode(child)
            node = node.right

        return binary

    def decode(self, data):
        if not data:
            return None

        nary = Node(data.val, [])                   # create n-ary root
        node = data.left                            # move to first child of n-ary root
        while node:                                 # while more children of n-ary root
            nary.children.append(self.decode(node)) # append to list
            node = node.right                       # and move to next child
            
        return nary
```

## 173. Binary Search Tree Iterator (Stack) (Facebook 18->23, Amazon 16, Google 7, Microsoft 6)



```python
# O(N)
# O(h)
class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack = []
        
        self.leftnodes(root)
        
    def leftnodes(self, root):
        while root:
            self.stack.append(root)
            root = root.left

    def next(self) -> int:
        """
        @return the next smallest number
        """
        top = self.stack.pop()
        if top.right:
            self.leftnodes(top.right)
                
        return top.val
            

    def hasNext(self) -> bool:
        """
        @return whether we have a next smallest number
        """
        return len(self.stack) > 0
```


```python
# O(N)  
# O(N)
class BSTIterator():

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        
        def inorder(root):
            if not root:
                return 
            inorder(root.left)
            self.stack.append(root.val)
            inorder(root.right)
             
        inorder(root)
       
    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        return self.stack.pop(0)

    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return len(self.stack) != 0
```

## 208. Implement Trie (Prefix Tree) (Dict) (Amazon 8, Google 8, Facebook 3, Microsot Onsite 2)

O(N)  
O(N)


```python
class Trie:
    def __init__(self):
        self.trie = {}

    # O(n)
    # O(n)
    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        cur = self.trie
        
        for c in word:
            if c not in cur:
                cur[c] = {}
                
            cur = cur[c]
            
            # cur = cur.setdefault(c, dict())
            
        cur['#'] = {}
        
    # O(n)
    # O(1)
    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        
        cur = self.trie
        for c in word:
            if c not in cur:
                return False
            
            cur = cur[c]
            
        return True if '#' in cur else False


    # O(n)
    # O(1)
    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie
        that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        cur = self.trie
        for c in prefix:            
            if c not in cur:
                return False
            cur = cur[c]
        return True
```


```python
class TrieNode:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.childs = {}
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        node = self.root
        for c in word:
            child = node.childs.get(c)
            if not child:
                child = TrieNode()
                node.childs[c] = child
            node = child
        node.isWord = True

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        node = self.root
        for c in word:
            child = node.childs.get(c)
            if not child:
                return False
            node = child
        return node.isWord


    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie
        that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        node = self.root
        for c in prefix:
            child = node.childs.get(c)
            if not child:
                return False
            node = child
        return True

# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```


```python
chr(127)
```




    '\x7f'




```python
from collections import Counter
dic = Counter()
dic[0] = 0
0 in dic
```




    True



## 211. Add and Search Word - Data structure design (Dic) (Facebook 24, Amazon 9)


```python
class WordDictionary:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        
        self.trie = {}
        self.res = []
        
    def addWord(self, word):
        """
        Adds a word into the data structure.
        :type word: str
        :rtype: None
        """
        
        cur = self.trie
        for w in word:
            if w not in cur:
                cur[w] = {}
                
            cur = cur[w]
            
        cur["#"] = {}

    def search(self, word):
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        :type word: str
        :rtype: bool
        """
        
        cur = self.trie
        self.res = False
        self.dfs(cur, word)
        return self.res
    
    def dfs(self, cur, word):
        if not word:
            if '#' in cur:
                self.res = True
            return 
        
        if word[0] == ".":
            for nxt in cur.values():
                self.dfs(nxt, word[1:])
            
#             for key in cur: (wrong)
#                 if key != '#':
#                     nxt = cur[key]
#                     dfs(word[1:], nxt)
                
        elif word[0] in cur:            
            cur = cur[word[0]]
            self.dfs(cur, word[1:])
            
 
    def autocomplete(self, startword, path=''):
        node = self.root
        for c in startword:
            if c not in node:
                return self.res
            
            path += c
            node = node[c]
            
        def dfs(path, node):
            for c in node:
                if c == '#':
                self.res.append(path)
        
            else:
                self.autocomplete(path + c, cur[c])
                
        dfs(path, node)
        
        return self.res
```


```python
s = WordDictionary()
s.addWord('apple')
s.addWord('apply')

s.trie

s.autocomplete(s.trie, '')
s.res
```




    {'a': {'p': {'p': {'l': {'e': {'#': {}}, 'y': {'#': {}}}}}}}



    {'a': {'p': {'p': {'l': {'e': {'#': {}}, 'y': {'#': {}}}}}}} 
    {'p': {'p': {'l': {'e': {'#': {}}, 'y': {'#': {}}}}}} a
    {'p': {'l': {'e': {'#': {}}, 'y': {'#': {}}}}} ap
    {'l': {'e': {'#': {}}, 'y': {'#': {}}}} app
    {'e': {'#': {}}, 'y': {'#': {}}} appl





    ['apple', 'apply']




```python
dic = {'a': {'b':{}, 'c':{}}, 'd':{}}

res = []
for n in dic.values():
    res.append(n)
    
res

dic.values()
    
```




    [{'b': {}, 'c': {}}, {}]






    dict_values([{'b': {}, 'c': {}}, {}])




```python
s = WordDictionary()
s.addWord('bad')
s.addWord('dad')
s.addWord('mad')
s.trie
s.search('.ad')
```




    {'b': {'a': {'d': {'#': {}}}},
     'd': {'a': {'d': {'#': {}}}},
     'm': {'a': {'d': {'#': {}}}}}



    {'b': {'a': {'d': {'#': {}}}}, 'd': {'a': {'d': {'#': {}}}}, 'm': {'a': {'d': {'#': {}}}}}
    b
    {'b': {'a': {'d': {'#': {}}}}, 'd': {'a': {'d': {'#': {}}}}, 'm': {'a': {'d': {'#': {}}}}}
    d
    {'b': {'a': {'d': {'#': {}}}}, 'd': {'a': {'d': {'#': {}}}}, 'm': {'a': {'d': {'#': {}}}}}
    m





    True




```python
class TrieNode():
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.isWord = False
    
class WordDictionary(object):
    def __init__(self):
        self.root = TrieNode()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isWord = True

    def search(self, word):
        node = self.root
        self.res = False
        self.dfs(node, word)
        return self.res
    
    def dfs(self, node, word):
        if not word:
            if node.isWord:
                self.res = True
            return 
        if word[0] == ".":
            for n in node.children.values():
                self.dfs(n, word[1:])
        else:
            node = node.children.get(word[0])
            if not node:
                return 
            self.dfs(node, word[1:])
```


```python
class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie = {}

    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        cur = self.trie
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
            
        cur['#'] = {}                

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """

        stack = [(self.trie, word)]
        while stack:
            node, w = stack.pop(0)
            if not w:
                if '#' in node:
                    return True
                
            elif w[0] == '.':
                for child in node.values():
                    stack.append((child, w[1:]))
                    
            else:
                if w[0] in node:
                    stack.append((node[w[0]], w[1:]))
                    
        return False
```


```python
class WordNode:
    def __init__(self):
        self.children = collections.defaultdict(WordNode)
        self.isEnd = False

class WordDictionary:
    def __init__(self):
        self.root = WordNode()
        
    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]

        node.isEnd = True
                
    def search(self, word):
        stack = [(self.root, word)]
        while stack:
            node, w = stack.pop()
            if not w:
                if node.isEnd:
                    return True
            elif w[0]=='.':
                for child in node.children.values():
                    stack.append((child, w[1:]))
            else:
                if w[0] in node.children:
                    stack.append((node.children[w[0]], w[1:]))
        return False
```

## 642. Design Search Autocomplete System (Dict) (Amazon 14, Google 12, Microsoft 4)


```python
class AutocompleteSystem():
    def __init__(self, sentences, times):
        self.root = {}
        self.searchTerm = ""
        # 1. add historical data
        
        for i, sentence in enumerate(sentences):
            self.add(sentence, times[i])
            
    def input(self, c):
        if c != "#":
            # 5. if input is not "#" add c to self.searchTerm and do self.search each time
            self.searchTerm +=c
            # print(self.searchTerm)
            # print()
            return self.search()
        
        else:
            self.add(self.searchTerm, 1)
            # print(self.root)
            # print()
            self.searchTerm = ""
    
    def add(self, sentence, hot):
        node = self.root
        #2. for each character in sentence
        for c in sentence: 
            if c not in node:
                node[c] = {}
                
            node = node[c]
        #3. when last character is added,
        #   make node.isEnd = True indicate that the current node is end of the sentence
        if '*' not in node:
            node['*'] = -hot
        else:
            node['*'] -= hot
        
        #4. do -= because by negating, we can sort as ascending order later
        
    def search(self):
        node = self.root
        res = []
        path = ""
    
        for c in self.searchTerm:
            if c not in node:
                return res
            # 6. add each character to path variable, path will added to res when we found node.isEnd ==True
            path += c
            node = node[c]
        # 7. at this point, node is at the given searchTerm.
        # for ex. if search term is "i_a", we are at "a" node.
        # from this point, we need to search all the possible sentence by using DFS
        
        def dfs(path, node):
            for c in node:
                if c == '*':
                    res.append((node['*'], path))

                else:
                    dfs(path+c, node[c])
        
        dfs(node, path)
        # 11. variable res has result of all the relevant sentences
        # we just need to do sort and return [1] element of first 3
        return [item[1] for item in sorted(res)[:3]]
```


```python
class TrieNode():
    def __init__(self):
        self.isEnd = False
        self.children = {}
        self.hot = 0
    
class AutocompleteSystem(object):
    def __init__(self, sentences, times):
        self.root = TrieNode()
        self.searchTerm = ""
        # 1. add historical data
        for i, sentence in enumerate(sentences):
            self.add(sentence, times[i])
            
    def input(self, c):
        if c != "#":
            # 5. if input is not "#" add c to self.searchTerm and do self.search each time
            self.searchTerm +=c
            return self.search()
        
        else:
            self.add(self.searchTerm, 1)
            self.searchTerm =""
            
    def add(self,sentence, hot):
        node = self.root
        #2. for each character in sentence
        for c in sentence: 
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        #3. when last character is added,
        #   make node.isEnd = True indicate that the current node is end of the sentence
        node.isEnd = True
        #4. do -= because by negating, we can sort as ascending order later
        node.hot-= hot
        
    def search(self):
        node = self.root
        res = []
        path = ""

        for c in self.searchTerm:
            if c not in node.children:
                return res
            # 6. add each character to path variable, path will added to res when we found node.isEnd ==True
            path +=c
            node = node.children[c]
        # 7. at this point, node is at the given searchTerm.
        # for ex. if search term is "i_a", we are at "a" node.
        # from this point, we need to search all the possible sentence by using DFS
        self.dfs(node, path,res)
        # 11. variable res has result of all the relevant sentences
        # we just need to do sort and return [1] element of first 3
        return [item[1] for item in sorted(res)[:3]]
            
    def dfs(self,node, path, res):
        # 8. Check if node is end of the sentence
        # if so, add path to res
        if node.isEnd:
            # 9. when add to res, we also want to add hot for sorting
            res.append((node.hot,path))
        # 10. keep going if the node has child
        # until there is no more child (reached to bottom)
        for c in node.children:
            self.dfs(node.children[c], path+c,res)
```

## 588. Design In-memory File System (Amazon 6)


```python
class FileSystem:
    def __init__(self):
        self.root = {}
        self.fileinfo = collections.defaultdict(str)
        
    def ls(self, path):
        if path in self.fileinfo:
            return path.split('/')[-1:]

        cur = self.root
        if path == '/':
            return sorted(cur.keys())
             
        for token in path.split('/')[1:]:
            # if cur and token:
            cur = cur[token]

        return sorted(cur.keys())

    def mkdir(self, path):
        cur = self.root
        for token in path.split('/')[1:]:
            # cur = cur.setdefault(token, dict())
            if token not in cur:
                cur[token] = {}
                
            cur = cur[token]
                
    def addContentToFile(self, filePath, content):
        self.mkdir(filePath)
        self.fileinfo[filePath] += content

    def readContentFromFile(self, filePath):
        return self.fileinfo[filePath]
```


```python
s = '/a/b/c'
new = s.split('/')[-1:]
new
```




    ['c']




```python
from collections import defaultdict

class Node(object):
    def __init__(self):
        self.children = {}
        
    def setdefault(self, token):
        return self.children.setdefault(token, Node())
        
    def get(self, token):
        return self.children.get(token)
                          
class FileSystem(object):
    def __init__(self):
        self.root = Node()
        self.fileinfo = collections.defaultdict(str)
        
    def ls(self, path):
        if path in self.fileinfo:
            return path.split('/')[-1:]

        cur = self.root
        for token in path.split('/'):
            if cur and token:
                cur = cur.get(token)

        return sorted(cur.children.keys()) if cur else []

    def mkdir(self, path):
        cur = self.root
        for token in path.split('/'):
            if token: 
                cur = cur.setdefault(token)
                
    def addContentToFile(self, filePath, content):
        self.mkdir(filePath)
        self.fileinfo[filePath] += content

    def readContentFromFile(self, filePath):
        return self.fileinfo[filePath]
```

## Find funtion in Linux System (Amazon)  
Write a program to implement the find function used in the Linux system.  
Two criteria :  
find all files in the given directory and its subdirectory with .xml extension  
find all files in the given directory and its subdirectory with size greater than given size  

he did not give me any specifics what is the input or output and told me to think as if you are writing the library and someone else is going to use it. So you can decide what input and output you want.

so I just created two functions findByName() and findBySize()
the code I wrote for findByName()


```python
s = '/root/file'
s.split('/')
```




    ['', 'root', 'file']




```python
public List<String> findByName(File directory){
	List<String> result = new ArryList<>();
	if(directory==null) return 
	if(directory.isDirectory()){
		List<File> list = direcoty.getList();
		for(File f: list){
			if(f.isDirectory()){
				List<String> sub = findByName(f);
				result.addAll(sub);
			}
			else{
				String name = f.name();
				String[] parts = name.split(".");
				if(parts[parts.length-1].equals("xml")){
					result.add(name);
				}
			}
		}
	}
	return result;
}
```


```python
findByName(directory):
    result = []
    if directory == None:
        return
    
    if directory.isDirectory():
        for f in directory.getList():
            if f.isDirectory():
                sub = findByName(f)
                result.addAll(sub)
                
            else:
                name = f.name()
                parts = name.split('.')
                if parts[-1] == 'xml':
                    result.append(name)
                    
                    
    return result
```

## Skip Iterator (Google Phone)
https://leetcode.com/discuss/interview-question/341818/Google-or-Skip-Iterator 


```python
from collections import defaultdict, Counter

class SkipIterator:
    def __init__(self, nums):
        self.nums = deque(nums)
        self.cnt = Counter()

    def hasNext(self):
        return len(self.nums) > 0
    
    def skip(self, i):
        self.cnt[i] += 1

    def next(self):
        if not self.hasNext():
            raise Exception('Error')
        
        if self.cnt[self.nums[0]] > 0:
            self.cnt[self.nums[0]] -= 1
            self.nums.popleft()
            
        return self.nums.popleft()
```


```python
itr = SkipIterator([2, 3, 5, 6, 5, 7, 5, -1, 5, 10])
itr.hasNext() # true
itr.next() # returns 2
itr.skip(5)
itr.next() # returns 3
itr.next() # returns 6 because 5 should be skipped
itr.next() # returns 5
itr.skip(5)
itr.skip(5)
itr.next() # returns 7
itr.next() # returns -1
itr.next()  #returns 10
itr.hasNext() # false
itr.next() # error

```




    True






    2






    3






    6






    5






    7






    -1






    10






    False




    ---------------------------------------------------------------------------

    Exception                                 Traceback (most recent call last)

    <ipython-input-22-14a4c840adb5> in <module>
         12 itr.next()  #returns 10
         13 itr.hasNext() # false
    ---> 14 itr.next() # error
    

    <ipython-input-21-2fd4149f8f3a> in next(self)
         14     def next(self):
         15         if not self.hasNext():
    ---> 16             raise Exception('Error')
         17 
         18         if self.cnt[self.nums[0]] > 0:


    Exception: Error


## Implement Logger (Google Onsite)


```python
import heapq

class Logger:
    def __init__(self):
        self.store = {}
        self.heap = []
        
    def start(self, pid, ts):
        if pid not in self.store:
            self.store[pid] = ts
        
    def end(self, pid, ts):
        if pid in self.store:
            heapq.heappush(self.heap, (self.store[pid], ts, pid))
            del self.store[pid]
    
    def print(self):
        tmp = self.heap[:]
        
        while len(tmp) > 0:
            start, end, pid = heapq.heappop(tmp)
            
            print('{} started at {} and ended at {}'.format(pid, start, end))
```

## 1146. Snapshot Array(Google 4 Phone, Apple 2)


```python
from collections import defaultdict
from copy import deepcopy
class SnapshotArray:

    def __init__(self, length):
        """
        :type length: int
        """
        self.arr = defaultdict(int)
        self.snaps = []

    def set(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        self.arr[index] = val

    def snap(self):
        """
        :rtype: int
        """
        self.snaps.append(deepcopy(self.arr))
        return len(self.snaps) - 1

    def get(self, index, snap_id):
        """
        :type index: int
        :type snap_id: int
        :rtype: int
        """
        return self.snaps[snap_id][index]  
```

## 855. Examn Room (Google 3, Facebook 5)

Use a list L to record the index of seats where people sit.    
seat():  
1. find the biggest distance at the start, at the end and in the middle.  
2. insert index of seat  
3. return index  


```python
class ExamRoom:
    def __init__(self, N):
        self.N = N
        self.students = []

    def seat(self):
        if not self.students: 
            index = 0
        else:
            d = self.students[0]
            index = 0
            for a, b in zip(self.students, self.students[1:]):
                if (b - a) // 2 > d:
                    d = (b - a) // 2
                    index = (b + a) // 2
                    
            if self.N - 1 - self.students[-1] > d: 
                index = self.N - 1
                
        bisect.insort(self.students, index)
        return index

    def leave(self, p):
        self.students.remove(p)
```


```python
class ExamRoom:
    def __init__(self, N):
        self.N = N
        self.students = []

    def seat(self):
        # Let's determine student, the position of the next
        # student to sit down.
        if not self.students:
            student = 0
        else:
            # Tenatively, dist is the distance to the closest student,
            # which is achieved by sitting in the position 'student'.
            # We start by considering the left-most seat.
            dist, student = self.students[0], 0
            for i, s in enumerate(self.students):
                if i:
                    prev = self.students[i-1]
                    # For each pair of adjacent students in positions (prev, s),
                    # d is the distance to the closest student;
                    # achieved at position prev + d.
                    d = (s - prev) // 2
                    if d > dist:
                        dist, student = d, prev + d

            # Considering the right-most seat.
            d = self.N - 1 - self.students[-1]
            if d > dist:
                student = self.N - 1

        # Add the student to our sorted list of positions.
        bisect.insort(self.students, student)
        return student

    def leave(self, p):
        self.students.remove(p)
```

### Others

## 904. Fruit Into Baskets (2 Pointers) (Googe 4)
Google 
O(N)

What is the length of longest subarray that contains up to two distinct integers?


```python
class Solution(object):
    def totalFruit(self, tree):
        ans = i = 0
        count = collections.Counter()
        for j, x in enumerate(tree):
            count[x] += 1
            while len(count) >= 3:
                count[tree[i]] -= 1
                if count[tree[i]] == 0:
                    del count[tree[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

## 425. Word Square


```python
from collections import defaultdict

class Solution:
    def wordSquares(self, words):
        """
        :type words: List[str]
        :rtype: List[List[str]]
        """
        
        n = len(words[0]) # all words same length
        output = []
        prefixes = defaultdict(list)
        
        for word in words:
            for i in range(len(word)):
                prefixes[word[:i]].append(word)
                
        print(prefixes)        
        
        def helper(cur):
            if len(cur) == n:
                print('len=', len(cur))
                output.append(cur)
                return
        
            prefix = ''
            for word in cur:
                prefix += word[len(cur)]
                print('prefix=', prefix)

            for word in prefixes[prefix]:
                helper(cur + [word])
                
            print()
        for word in words:
            helper([word])
            
        return output
```


```python
words = ["area","lead","wall","lady","ball"]
s = Solution()
s.wordSquares(words)
```

    defaultdict(<class 'list'>, {'': ['area', 'lead', 'wall', 'lady', 'ball'], 'a': ['area'], 'ar': ['area'], 'are': ['area'], 'l': ['lead', 'lady'], 'le': ['lead'], 'lea': ['lead'], 'w': ['wall'], 'wa': ['wall'], 'wal': ['wall'], 'la': ['lady'], 'lad': ['lady'], 'b': ['ball'], 'ba': ['ball'], 'bal': ['ball']})
    prefix= r
    
    prefix= e
    
    prefix= a
    prefix= l
    prefix= le
    prefix= l
    prefix= la
    prefix= lad
    len= 4
    
    
    
    prefix= a
    prefix= d
    prefix= de
    
    
    prefix= a
    prefix= l
    prefix= le
    prefix= l
    prefix= la
    prefix= lad
    len= 4
    
    
    





    [['wall', 'area', 'lead', 'lady'], ['ball', 'area', 'lead', 'lady']]



## 247. Strobogrammatic Number II


```python
class Solution:
    def findStrobogrammatic(self, n):
        nums = n%2 * list('018') or ['']
        print('nums=', nums)
        while n > 1:
            n -= 2
            for a, b in '00 11 88 69 96'.split()[n<2:]:
                print(a, b)
            nums = [a + num + b for a, b in '00 11 88 69 96'.split()[n<2:] for num in nums]
        return nums
        
```


```python
s = Solution()
s.findStrobogrammatic(2)
```

    nums= ['']
    1 1
    8 8
    6 9
    9 6





    ['11', '88', '69', '96']


