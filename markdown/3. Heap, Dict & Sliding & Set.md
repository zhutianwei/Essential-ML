```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

### (String) List. Heap Sort, Dict, Set

### 八大排序  
O(N^2), Bubble sort, Selection sort, Insertion Sort  
O(NlgN), 那么范围缩小到 quick sort，merge sort 和 heap sort

## Bubble Sort


```python
# O(N^2)
def bubble_sort(array):
    for i in range(len(array)-1):
        for j in range(len(array) - i - 1):
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
                print(array)
                
    return array
                
bubble_sort([6,3,8,0,2])
```

    [3, 6, 8, 0, 2]
    [3, 6, 0, 8, 2]
    [3, 6, 0, 2, 8]
    [3, 0, 6, 2, 8]
    [3, 0, 2, 6, 8]
    [0, 3, 2, 6, 8]
    [0, 2, 3, 6, 8]





    [0, 2, 3, 6, 8]



## Merge Sort (Amazon)


```python
# O(nlogn)
def merge_sort(nums):
    # bottom cases: empty or list of a single element.
    if len(nums) <= 1:
        return nums

    pivot = len(nums) // 2
    left = merge_sort(nums[:pivot])
    right = merge_sort(nums[pivot:])
    return mergeTwoSortedArray(left, right)
    
def mergeTwoSortedArray(left, right):
    l = r = 0
    res = []
    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            ret.append(left[l])
            l += 1
        else:
            ret.append(right[r])
            r += 1
    
    # append what is remained in either of the lists
    res.extend(left[l:])
    res.extend(right[r:])
    
    return res

array = [5, 3, 2, 6]
merge_sort(array)
```




    [2, 3, 5, 6]




```python
array = [1,3]
array[2]
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-2-da99f3da4cde> in <module>
          1 array = [1,3]
    ----> 2 array[2]
    

    IndexError: list index out of range


## Quick Sort  
O(NlogN)  
O(N)


```python
def quick_sort(array):
    if len(array) <= 1:
        return array
     
    pivot = array[0]
    smaller = [n for n in array[1:] if n <= pivot]
    greater = [n for n in array[1:] if n > pivot]

    return quick_sort(smaller) + [pivot] + quick_sort(greater)    

array = [5, 3, 2, 6, 8]
quick_sort(array)
```




    [2, 3, 5, 6, 8]




```python
[3] + []
```




    [3]




```python
a = [1,2]
b = [4,5]
a.extend(b)
a
```




    [1, 2, 4, 5]



### Heap Sort


```python
import heapq

l = [1,5,3,2]
heapq.nlargest(2, l)
```




    [5, 3]



## 937. Reorder Data in Log Files (String List) (Amazon OA 142)

O(Alog(A))  
O(A)


```python
class Solution:
    def reorderLogFiles(self, logs):
        """
        :type logs: List[str]
        :rtype: List[str]
        """
        
        def helper(log):
            iden, rest = log.split(" ", 1)
            
            if rest[0].isalpha():
                return (0, rest, iden)
            
            else:
                return (1,)
            
        return sorted(logs, key = helper)
```


```python
logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]

for log in logs:
#     ids, rest = log.split(' ', 1)
#     print(ids, ',', type(rest))
    s = log.split(' ', 2)
    print(s)
```


```python
logs = ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]

for log in logs:
    ids = log.split(' ', 1)
    print(ids)
```

## Sort 2D Array (Matrix. heapq) (Google Phone)


```python
import heapq

def sort(matrix):
    
    row = len(matrix)
    col = len(matrix[0])
#     array = matrix[0]
#     for i in range(1, len(matrix)):
#         array = heapq.merge(array, matrix[i])
        
#     array = list(heapq.merge(*matrix))

    heap = []
    
    for array in matrix:
        for n in array:
            heapq.heappush(heap, n)

    
    for m in range(row):
        for n in range(col):
            value = heapq.heappop(heap)
            matrix[m][n] = value
            
```


```python
import heapq
matrix = [[ 5, 12, 17, 21, 23],
             [ 1,  2,  4,  6,  8],
             [12, 14, 18, 19, 27],
             [ 3,  7,  9, 15, 25]]


sort(matrix)
matrix
```




    [[1, 2, 3, 4, 5], [6, 7, 8, 9, 12], [12, 14, 15, 17, 18], [19, 21, 23, 25, 27]]




```python
a = [3,2,1,4,5,6,4,2]
heapq.heapify(a)

a 
```




    [1, 2, 3, 2, 5, 6, 4, 4]



##  Partition array into N subsets with balanced sum (List. heapq) (Microsoft OA)


```python
import heapq

def subset(arr, k):
    heap = [(0, i) for i in range(k)]
    print('heap', heap)
    res = [[] for _ in range(k)]
    
    arr.sort(reverse = True)

    for each in arr:
        val, idx = heapq.heappop(heap)
        res[idx].append(each)
        
        heapq.heappush(heap, (val + each, idx))

    return res

c = [1, 2, 3, 4, 5, 2, 2, 3, 9]
a = [1,2,3,4,5]
b = [1,2,3,4,5,6,7,8,9,10]
k = 3
print(subset(a, k))
```

    heap [(0, 0), (0, 1), (0, 2)]
    [[5], [4, 1], [3, 2]]


## 1167. Minimum Cost to Connect Sticks (Amazon OA 15)


```python
import heapq
class Solution:
    def connectSticks(self, s):
        """
        :type sticks: List[int]
        :rtype: int
        """
        
        heapq.heapify(s)
        res = 0
        while len(s) > 1:
            a = heapq.heappop(s)
            b = heapq.heappop(s)
            res += a + b
            heapq.heappush(s, a + b)
        return res
```

## 253. Meeting Room II（List. heapq sort) (Facebook 26, Amazon 23, Uber 11, Microsoft Onsite 8, Google 9, Apple 5)

时间复杂度: O(NlogN)  

想象一下，现实生活中，先开始的会议还没结束前我们就又要开始一个会议的话，此时我们需要一个新的会议室

如果前面一堆先开始的会议都先于我们的新会议开始之前结束了，我们不需要新会议室

换句话说，如果前面一堆新开始的会议中结束最早的那个会议如果在新开始的会议之前结束了的话，我们不需要会议室

所以我们的思路是，先按照会议开始的时间排序，然后维护一个会议结束时间的最小堆，堆顶就是前面结束最早的那个会议的结束时间

那么对于一个新的会议出现时：

如果堆顶元素比新会议的开始时间更小的话，我们不需要新会议室。同时因为后面出现的新会议的开始时间更大了，
所以目前最先结束的会议永远不可能比后面新出现的会议的开始时间更大，因此我们可以pop目前最先结束的会议，即pop堆顶元素，并且将新会议的结束时间放进堆中

如果堆顶元素比新会议的开始时间更大的话，我们知道我们需要一个新的会议室，此时直接将新会议的结束时间放进堆中

最终堆的size就是我们需要的会议室数量


```python
import heapq 
class Solution:
    def minMeetingRooms(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """

        if not intervals:
            return 0
        
        intervals.sort()
        
        heap = []
        heapq.heappush(heap, intervals.pop(0)[-1])
        
        for array in intervals:
            if array[0] >= heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, array[-1])
                
            else:
                heapq.heappush(heap, array[-1])
                
        return len(heap)
```


```python
import heapq 
class Solution:
    def minMeetingRooms(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: int
        """

        # If there is no meeting to schedule then no room needs to be allocated.
        if not intervals:
            return 0

        # The heap initialization
        heap = []

        # Sort the meetings in increasing order of their start time.
        intervals.sort()

        # Add the first meeting. We have to give a new room to the first meeting.
        heapq.heappush(heap, intervals[0][-1])

        # For all the remaining meeting rooms
        for interval in intervals[1:]:

            # If the room due to free up the earliest is free, assign that room to this meeting.
            if heap[0] <= interval[0]:
                heapq.heapreplace(heap, interval[-1])

            # If a new room is to be assigned, then also we add to the heap,
            # If an old room is allocated, then also we have to add to the heap with updated end time.
            elif heap[0] > interval[0]:
                heapq.heappush(heap, interval[-1])

        # The size of the heap tells us the minimum rooms required for all the meetings.
        return len(heap)
```


```python
import heapq 
class Solution():
    def minMeetingRooms(self, lists):
        """
        :type intervals: List[Interval]
        :rtype: int
        """
        if not lists:
            return 0
        
        lists.sort()

        heap = []  # stores the end time of intervals
    
        for i in lists:
#             print('i =', i)
            if heap and i[0] >= heap[0]: 
                # means two intervals can use the same room
                heapq.heapreplace(heap, i[-1])
#                 print('heap1 =', heap)

            else:
                # a new room is allocated
                heapq.heappush(heap, i[-1])
#                 print('heap2 =', heap)
            
#             print()

        return len(heap)
```


```python
s = Solution()
intervals = [[0, 30],[5, 10],[15, 20]]
s.minMeetingRooms(intervals)
```


```python
dic = {'yes':1}
dic.pop('s', 0)
dic
```

## 215. Kth Largest Element in an Array (List. heapq, Quick Sorting, Recursion) (Facebook 26, Amazon 12, Google 6, Microsoft Onsite 3, Linkedin 5)


```python
# nlog(k)
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        heap = []
        for n in nums[:k]:
            heapq.heappush(heap, n)
            
        for n in nums[k:]:
            if n > heap[0]:
                heapq.heappop(heap)
                heapq.heappush(heap, n)

        return heap[0]
```


```python
# O(nlogk)
# O(k)
class Solution:
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        return heapq.nlargest(k, nums)[-1]
```


```python
# Time Complexity：Heapify用了O(N)，然后一共pop了k个元素，每个元素使用logn的时间复杂，所以一共是O(n + klog(n))
# O(n)
import heapq
class Solution:
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """

        heap = []
        for n in nums:
            heapq.heappush(heap, -n)
            
        for i in range(k):
            res = heapq.heappop(heap)
            
        return -res
```


```python
x = (1, [1,2])

heap = []
import heapq
heapq.heappush(heap, (1,[1,2]))
heap
```


```python
# 时间复杂度: O(N)  
# O(1)
class Solution:
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        pivot = nums[0]
        smaller  = [n for n in nums if n < pivot]
        equal = [n for n in nums if n == pivot]
        greater = [n for n in nums if n > pivot]

        if len(greater) >= k:
            return self.findKthLargest(greater, k) #k may be there
        elif len(equal) >= (k - len(greater)): # k may be in equal or smaller
            return equal[0] # any number from equal
        else:
            return self.findKthLargest(smaller, k - len(greater) - len(equal))
```

## 973. K Closest Point to Origin (Lists. heapq) (Amazon OA 77, Facebook 35)  
O(NlogN)  
O(N)


```python
import heapq
class Solution:
    def kClosest(self, points, K):
        """
        :type points: List[List[int]]
        :type K: int
        :rtype: List[List[int]]
        """
        
        # dic = {}
        # for point in points:       
        heap = []
        
        for n in points:
            distance, point = n[0]**2 + n[1]**2, n
            heapq.heappush(heap, (distance, point))
                                  
        res = []
        for i in range(K):
            distance, point = heapq.heappop(heap)
            res.append(point)
                           
        return res
```


```python
class Solution:
    def kClosest(self, points, k):
        """
        :type points: List[List[int]]
        :type K: int
        :rtype: List[List[int]]
        """
        
        points.sort(key = lambda p: p[0]**2 + p[1]**2)
        return points[:k]
```

## Top K Frequently Mentioned Keywords (heap) (Amazon OA)


```python
from collections import Counter
import heapq
class Solution:
    def topKFrequent(self, words, k):   
                
        heap = []
        res = []
        dic = Counter(words)
                
        for key, value in dic.items():
            heapq.heappush(heap,(-value, key))
            
        for i in range(k):
            key, value = heapq.heappop(heap)
            res.append(value)
        return res
```

## 692. Top K Frequent Words (heap) (Amazon 13)


```python
# O(N + klogN)  
# O(N)
from collections import Counter
import heapq
class Solution:
    def topKFrequent(self, words, k):   
        
        dic = Counter(words)
                
        heap = [(-freq, word) for word, freq in dic.items()]
        heapq.heapify(heap)
        
        return [heapq.heappop(heap)[1] for i in range(k)]
```


```python
# O(nlogk)  
# O(N)
from collections import Counter
import heapq
class Solution:
    def topKFrequent(self, words, k):                   
        heap = []
        res = []
        dic = Counter(words)
                
        for key, value in dic.items():
            heapq.heappush(heap,(-value, key))
            
        for i in range(k):
            key, value = heapq.heappop(heap)
            res.append(value)
        return res
```


```python
# O(nlogn)
# O(n)

from collections import Counter
class Solution():
    def topKFrequent(self, words, k):
        """
        :type words: List[str]
        :type k: int
        :rtype: List[str]
        """
        count = Counter(words)
#         print(count)
         candidates = sorted(count.keys(), key = lambda x: (-count[x], x))

        
        return candidates[:k] 
```


```python
words = ["i", "love", "leetcode", "i", "love", "coding"]
k = 2
s = Solution()
s.topKFrequent(words, k)
```

    Counter({'i': 2, 'love': 2, 'leetcode': 1, 'coding': 1})
    candidates= ['i', 'love', 'coding', 'leetcode']





    ['i', 'love']



## 347. Top K Frequent Elements (heap) (Amazon 16, Google 6, Microsoft 6)

O(N + klog(n))  
O(N)


```python
import heapq
class Solution:
    def topKFrequent(self, nums, k):
#         dic = {}       
#         for n in nums:
#             if n in dic:
#                 dic[n] += 1
#             else:
#                 dic[n] = 1
          
        heap = []
        res = []
        dic = Counter(nums)
                
        for key, value in dic.items():
            heapq.heappush(heap,(-value, key))
            
        for i in range(k):
            key, value = heapq.heappop(heap)
            res.append(value)
        return res
```


```python
import heapq
from collections import Counter
class Solution:
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """ 
        count = Counter(nums)   
        return heapq.nlargest(k, count.keys(), key=count.get) 
#       return sorted(count.keys(), key = count.get, reverse = True)[:k]
```

## 819. Most Common Word (String. Counter) (Amazon OA 65)

O(N)  
O(P) P个words


```python
from collections import Counter
class Solution:
    def mostCommonWord(self, paragraph, banned):
        """
        :type paragraph: str
        :type banned: List[str]
        :rtype: str
        """
        
        for c in "!?',;.": 
            paragraph = paragraph.replace(c, " ")
            
        paragraph = paragraph.lower().split()
        
        dic = Counter()
        res = '' 
        count = 0
        
        for word in paragraph:
            if word in banned:
                continue
                
            if word in dic:
                dic[word] += 1
                
                
#             elif word not in dic:
#                 dic[word] = 1
#             else:
#                 dic[word] += 1
                
            if dic[word] > count:
                count = dic[word]
                res = word
        return res
        
```


```python
s = Solution()
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
s.mostCommonWord(paragraph, banned)
```


```python
s = 'Sjks'
s.split()
s
```


```python
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
for c in "!?',;.": 
    paragraph = paragraph.replace(c, "")
    
paragraph.split()
```

### Counter

## 389. Find Difference (Google 2 last year)


```python
from collections import Counter
class Solution:
    def findTheDifference(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        dic = Counter(s)
        dic2 = Counter(t)
        for c in t:
            if dic[c] != dic2[c]:
                return c
```

## Min Deletions to Make Frequency of Each Letter Unique (String. Counter) (Microsoft OA)


```python
from collections import Counter

def solution(s):
    dic = Counter(s)
    
    array = list(dic.values())
    array.sort()
    print(array)
    
    count = 0
    for i in range(len(array)-2, -1, -1):
        print('i', i)
        if array[i] == array[i + 1]:
            array[i] -= 1
            count += 1
            
            if array[i] == 1:
                count += sum(array[:i])
                break
                
    return count
                
solution("aabbffddeaee")
```

    [2, 2, 2, 3, 3]
    i 3
    i 2





    6




```python
array = [2, 2, 2, 3, 3]
for i in range(len(array)-2, -1, -1):
    print(i)
```

    3
    2
    1
    0


## Min Deletions To Obtain String in Right Format (Counter) (Microsoft OA)


```python
from collections import Counter

class Solution:
    def solution(self, s):
        right = Counter(s)
        left = Counter()
        ans = left['B'] + right['A']
        for c in s:
            left[c] += 1
            right[c] -= 1
            ans = min(ans, left['B'] + right['A'])
        return ans

s = Solution()
s.solution("BAAABAB") # 2
s.solution("BBABAA") # 3
s.solution("B") # 0
s.solution("BAAABBBB") # 1
s.solution("BBBBABBB") # 1
s.solution("AAAAA") # 0
```




    2






    3






    0






    1






    1






    0




```python
def solution(s):
    r_A = Counter(s)
    l_B = Counter()
    
    res = l_B['B'] + r_A['A']
    
    for c in s:

        if c == 'B':
            l_B[c] += 1

        elif c == 'A':
            r_A[c] -= 1

        res = min(res, l_B['B'] + r_A['A'])
            
    return res
    
solution("BAAABAB") # 2
solution("BBABAA") # 3
solution("B") # 0
solution("BAAABBBB") # 1
solution("BBBBABBB") # 1
solution("AAAAA") # 0
```




    2






    3






    0






    1






    1






    0



## Max Network rank (Counter) (Microsoft OA)


```python
from collections import Counter
def solution(arr1, arr2):
    dic = Counter()
    
    for i in range(len(arr1)):
        dic[arr1[i]] += 1
        dic[arr2[i]] += 1
        
    res = 0
    for i in range(len(arr1)):
        res = max(res, dic[arr1[i]] + dic[arr2[i]] - 1)
        
    return res

a = [1,2,3,3]
b = [2,3,1,4]

c = [1,2,4,5]
d = [2,3,5,6]

solution(a, b)
```




    4



## Min Steps to Make Piles Equal Height (List. Counter) (Microsoft OA)


```python
def solution(piles):
    length = len(piles)
    
    if length <= 1:
        return 0
    
    piles.sort(reverse = True)
    
    res = 0
    count = 0
    
    for i in range(1, len(piles)):
        if piles[i] != piles[i-1]:
            res += i
            
    return res

a = [5,2,1]
b = [4,5,5,4,2]
solution(b)
```




    6




```python
public int minSteps(int[] piles){
        int len = piles.length;
        if(len <= 1) return 0;
        Arrays.sort(piles);
        int res = 0, distinctNums = 0;
        for(int i = 1; i < len; ++i){
            if(piles[i] == piles[i - 1]){
                res += distinctNums;
            }
            else{
                ++distinctNums;
                res += distinctNums;
            }
        }
        return res;
    }
```


```python
from collections import Counter
def minStepEqualPiles(array):
    cnt = Counter(array)
    print('cnt', cnt)
    nums = sorted(cnt.keys(), reverse=True)
    print('nums', nums)
    
    dp = [0] * (len(array) + 1)
#     k, ans = 0, 0
#     for i in range(len(nums)-1):
#         k += cnt[nums[i]]
#         ans += k

    for i in range(len(nums)):
        dp[i+1] = dp[i] + cnt[nums[i]]

    return dp[-1]

A = [5, 2, 1]
print(minStepEqualPiles(A))

A = [4, 5, 5, 4, 2]
print(minStepEqualPiles(A))
```

    cnt Counter({5: 1, 2: 1, 1: 1})
    nums [5, 2, 1]
    3
    cnt Counter({4: 2, 5: 2, 2: 1})
    nums [5, 4, 2]
    0


## Min Swaps to Group Red Balls (Counter) (Microsoft OA)


```python
from collections import Counter
def solution(s):
            
    dic = Counter(s)
    red = dic['R']
    
    res = 0
    i = 0
    j = len(s) - 1
    
    while i < j:
        if s[i] == 'R' and s[j] == 'R':
            red -= 2
            res += j - i - 1 - red
            i += 1
            j -= 1
            
        elif s[i] == 'R' and s[j] == 'W':
            j -= 1
            
        elif s[i] == 'W' and s[j] == 'R':
            i += 1
            
        else:
            i += 1
            j -= 1
            
    return res


a = 'WRRWWR' #2
b = 'WWRWWWRWR' #4
c = "RRRWRR" #2
    
solution(a)
```




    2



## Maximum Length of a Concatenated String with Unique Characters (Counter) (Microsoft OA)


```python
from collections import Counter
class Solution:
    def maxLength(self, arr):
        """
        :type arr: List[str]
        :rtype: int
        """
        
        arr = [s for s in arr if len(s) == len(set(s))]
        if not arr:
            return 0
        
        arr.sort(key=len, reverse=True)
        print(arr)
        max_len = 0
        
        for i in range(len(arr)):
            tmp = arr[i]
            for j in range(len(arr)):
                if not set(tmp) & set(arr[j]):
                    tmp += arr[j]
            max_len = max(max_len, len(tmp))
        
        return max_len
```

## 767. Reorganize String (Facebook 16, Amazon 12, Google 8, Microsoft Onsite 5)


```python
from collections import Counter
class Solution():
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        tmp = []
        
        dic = Counter(S)
        sort = []
        for key, value in dic.items():
            sort.append((value, key))
            if value > (len(S) + 1) // 2:
                return ''
                
        sort.sort()
        
        for c, x in sort:
            tmp += [x] * c
            
        res = [0] * len(S)
        res[::2], res[1::2] = tmp[len(S)//2:], tmp[:len(S)//2]
        return ''.join(res)
```

## 266. Palindrome Permutation (Facebook 4, Microsoft 2, Amazon 2)


```python
from collections import Counter
class Solution():
    def canPermutePalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        dic = Counter(s)
        count = 0
        for value in dic.values():
            count += value % 2
            
        return count <= 1
```

## 409. Longest Palindrome (Counter) (Amazon 6->2)


```python
# Imagine we built our palindrome. It consists of as many partnered letters as possible, plus a unique center if possible. 
# This motivates a greedy approach.
# For each letter, say it occurs v times. We know we have v // 2 * 2 letters that can be partnered for sure.
from collections import Counter
class Solution:
    def longestPalindrome(self, s: str) -> int:
        d = Counter(s)
            
        count = 0
        for v in d.values():
            n = v // 2 * 2
            count += n
            
        if len(s) > count:
            count += 1
            
        return count

```

## 242. Valid Anagram (String, Counter) (Microsoft 4)

时间复杂度: O(s+t)  
O(s+t)


```python
from collections import Counter
class Solution:
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        return Counter(s) == Counter(t)
```


```python
collections.Counter('ancn')
```


```python
class Solution:
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        dic1 = {}
        for i in s:
            if i not in dic1:
                dic1[i] = 1
            else:
                dic1[i] += 1
                
        dic2 = {}
        for i in t:
            if i not in dic2:
                dic2[i] = 1
            else:
                dic2[i] += 1
                
        return dic1 == dic2
```


```python
a = {1:2, 3:4, 2:3}
b = {1:2, 2:3, 3:4}

for k in a:
    print(k)

for k in b:
    print(k)
    
c = {3,4,5}
for n in c:
    print(n)
```


```python
from collections import Counter
# Complete the commonChild function below.
def commonChild(s1, s2):
    dic1 = Counter(s1)
    dic2 = Counter(s2)
    print(dic1)
    print(dic2)
    for c in dic1:
        print(c)

    count = 0
    for c in dic1:
        if c in dic2:
            if dic1[c] >= dic2[c]:
                count += dic2[c]

            else:
                count += dic1[c]

    return count

s1 = "OUDFRMYMAW"
s2 = "AWHYFCCMQX"

commonChild(s1, s2)
```

    Counter({'M': 2, 'O': 1, 'U': 1, 'D': 1, 'F': 1, 'R': 1, 'Y': 1, 'A': 1, 'W': 1})
    Counter({'C': 2, 'A': 1, 'W': 1, 'H': 1, 'Y': 1, 'F': 1, 'M': 1, 'Q': 1, 'X': 1})
    O
    U
    D
    F
    R
    M
    Y
    A
    W





    5




```python
s1 = "HNHAN"
s2 = "NHAAAA"
set(s1) & set(s2)
```




    {'A', 'H', 'N'}



## 387. First Unique Character in a String (String, Counter) (Amazon Onsite 13, Microsoft 7, Facebbook 4)

O(N)  
O(N)


```python
from collections import Counter
class Solution:
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        # build hash map : character and how often it appears
        dic = Counter(s)
        
        # find the index
        for i, c in enumerate(s):
            if dic[c] == 1:
                return i
        return -1
```


```python
from collections import Counter
class Solution(object):
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s:
            return -1
        
        dic = Counter(s)
        
        for c in s:
            if dic[c] == 1:
                return s.index(c)
            
        return -1
```

## 350. Intersection of Two Arrays II (List, Counter) (Facebook 16)  
O(N)  
O(N)


```python
from collections import Counter
class Solution():
    def intersect(self, A, B):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """  
        counts = Counter(A)
       
        res = []    
        for n in B:
            if counts[n] > 0:
                res.append(n)
                counts[n] -= 1

        return res
```

## 560. Subarray Sum Equals K (List, Counter) (Facebook 32-88, Amazon 12, Microsoft 8)  
O(N)  
O(N)  
2 - 0 = k  
3 - 1 = k

Let's remember count[V], the number of previous prefix sums with value V. If our newest prefix sum has value W, and W-V == K, then we add count[V] to our answer.

This is because at time t, nums[0] + nums[1] + ... + nums[t-1] = W, and there are count[V] indices j with j < t-1 and nums[0] + nums[1] + ... + nums[j] = V. Thus, there are count[V] subarrays nums[j+1] + nums[j+2] + ... + nums[t-1] = K.


```python
from collections import Counter
class Solution:
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        
        dic = Counter()
        dic[0] = 1
        sums = 0
        res = 0
        
        for n in nums:
            sums += n
#             print('sums =', sums)

            if sums - k in dic:
                res += dic[sums-k]
#             print('ans =', ans)
            dic[sums] += 1
#             print(f'count{sums}', count[sums])
        return res
        
```


```python
s = Solution()
nums = [1,2,3]
k = 3
s.subarraySum(nums, k)
```


```python
class Solution:
    def subarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        if not nums:
            return 0
        
        dic = {0:1}
        count = 0
        sums = 0
        for num in nums:
            sums += num
            
            if sums - k in dic:
                count += dic[sums-k]
            
            if sums not in dic:
                dic[sums] = 1
            else:
                dic[sums] += 1
            
        return count
```

## 659. Split Array into Consecutive Subsequences (List) (Google Onsite 5->15)

这道题让将数组分割成多个连续递增的子序列，注意这里可能会产生歧义，实际上应该是分割成一个或多个连续递增的子序列，因为 [1,2,3,4,5] 也是正确的解。这道题就用贪婪解法就可以了，使用两个 HashMap，第一个 HashMap 用来建立数字和其出现次数之间的映射 count，第二个用来建立可以加在某个连续子序列后的数字与其可以出现的次数之间的映射 tails。对于第二个 HashMap，举个例子来说，就是假如有个连牌，比如对于数字1，此时检测数字2和3是否存在，若存在的话，表明有连牌 [1,2,3] 存在，由于后面可以加上4，组成更长的连牌，所以不管此时牌里有没有4，都可以建立 4->1 的映射，表明此时需要一个4。这样首先遍历一遍数组，统计每个数字出现的频率，然后开始遍历数组，对于每个遍历到的数字，首先看其当前出现的次数，如果为0，则继续循环；如果 tails 中存在这个数字的非0映射，那么表示当前的数字可以加到某个连的末尾，将当前数字在 tails 中的映射值自减1，然后将下一个连续数字的映射值加1，因为当 [1,2,3] 连上4后变成 [1,2,3,4] 之后，就可以连上5了，说明此时还需要一个5；如果不能连到其他子序列后面，则来看其是否可以成为新的子序列的起点，可以通过看后面两个数字的映射值是否大于0，都大于0的话，说明可以组成3连儿，于是将后面两个数字的映射值都自减1，还有由于组成了3连儿，在 tails 中将末尾的下一位数字的映射值自增1；如果上面情况都不满足，说明该数字是单牌，只能划单儿，直接返回 false。最后别忘了将当前数字的 count 映射值自减1。退出 for 循环后返回 true，参见代码如下：


```python
# O(N)
# O(N)
class Solution:
    def isPossible(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        count = collections.Counter(nums)
        tails = collections.Counter()
        for n in nums:
            if count[n] == 0:
                continue
                
            elif tails[n] > 0:
                tails[n] -= 1
                tails[n+1] += 1
                
            elif count[n+1] > 0 and count[n+2] > 0:
                count[n+1] -= 1
                count[n+2] -= 1
                tails[n+3] += 1
                
            else:
                return False
            
            count[n] -= 1
        return True 
```

## Favorite Genres (Amazon OA)


```python
from collections import Counter

def favGenres(userSongs, songGenres):
    
    dic = {}
    for genre in songGenres:
        for song in songGenres[genre]:
            dic[song] = genre
            
    for singer in userSongs:
        array = userSongs[singer]
        for i in range(len(array)):
            array[i] = dic[array[i]]
    
    for singer in userSongs:
        res = []
        counter = Counter(userSongs[singer])
        
        for key, value in counter.items():
            if not res:
                res.append(key)
                maximo = value
            
            elif value > maximo:
                res.pop()
                res.append(key)
                maximo = value
                
            elif value == maximo:
                res.append(key)
                
        userSongs[singer] = res
        
    return userSongs
```


```python
userSongs = {  
   "David": ["song1", "song2", "song3", "song4", "song8"],
   "Emma":  ["song5", "song6", "song7"]
}

songGenres = {  
   "Rock":    ["song1", "song3"],
   "Dubstep": ["song7"],
   "Techno":  ["song2", "song4"],
   "Pop":     ["song5", "song6"],
   "Jazz":    ["song8", "song9"]
}

favGenres(userSongs, songGenres)
```

    defaultdict(<class 'int'>, {'Rock': 2, 'Techno': 2, 'Jazz': 1})
    defaultdict(<class 'int'>, {'Pop': 2, 'Dubstep': 1})





    {'David': ['Rock', 'Techno'], 'Emma': ['Pop']}




```python
from collections import defaultdict
def favGenres(userSongs, songGenres):
    output={}
    for i in userSongs:
        list=userSongs[i]
        count= defaultdict(int)
        for j in list:
            for k,v in songGenres.items():
                if j in v:
                    count[k]+=1

        print(count)
        output[i]=[key for key,val in count.items() if val ==max(count.values())]
                
    
    return output
```

### defaultdict

## 49. Group Anagrams (String List, defaultdict) (Amazon 25, Microsoft 8, Facebook 3, Google 3)
 
O(N*KlogK)  
O(N*K)


```python
from collections import defaultdict
class Solution:
    def groupAnagrams(self, words):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        dic = defaultdict(list)
        for s in words:
            tmp = ''.join(sorted(list(s)))
            dic[tmp].append(s)
        return dic.values()
```


```python
class Solution:
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        dic = {}
        for s in strs:
            tmp = ''.join(sorted(list(s)))
            if tmp not in dic:
                dic[tmp] = [s]
            else:
                dic[tmp].append(s)
        return dic.values()
```


```python
from collections import Counter, defaultdict
dic = defaultdict(int)
dic[0]
```


```python
s = 'ab  '
list(s)
```

## 219. Contains Duplicate II (List. defaultdict) (Google 2, Amazon 2)


```python
from collections import defaultdict

class Solution:
    def containsNearbyDuplicate(self, nums, k):
        if not nums:
            return False
               
        dic = defaultdict(list) 
        for i, n in enumerate(nums):
            dic[n].append(i)

            if len(dic[n]) > 1:
                if dic[n][1] - dic[n][0] <= k:
                    return True

                else:
                    dic[n].pop(0)


        return False
```


```python
class Solution:
    def containsNearbyDuplicate(self, nums, k):
        if not nums:
            return False
        
        dic = {}
        for i, n in enumerate(nums):
            if n not in dic:
                dic[n] = [1, i]
                
            else:
                dic[n][0] += 1
                dic[n].append(i)
                
                if dic[n][2] - dic[n][1] <= k:
                    return True
                
                else:
                    dic[n].pop(1)
                
        return False
```

## 1152. Analyze User Website Visit Pattern (List, defaultdict) (Amazon 9)


```python
from collections import defaultdict, Counter
from itertools import combinations

class Solution:
    def mostVisitedPattern(self, username, timestamp, website):
        """
        username: List[str]
        timestamp: List[int]
        website: List[str]
        """
        
        users = defaultdict(list)
        for i in range(0, len(username)):
            users[username[i]].append((timestamp[i], website[i]))

        three_sequence = Counter()
        for u in users:
            webs = [web for time, web in sorted(users[u])]
            user_set = {c for c in combinations(webs, 3)}

            for item in user_set:
                three_sequence[item] += 1

        ans = sorted(three_sequence.items(), key=lambda x: (-x[1], x[0][0], x[0][1], x[0][2]))
        return list(ans[0][0])
```


```python
# Log file where each line of the log contains a tuple like one below:
# Tuple: Timestamp, CustomerId, PageId



# 10:01:01    Customer-1  Page1
# Customer                Page1
# 10:01:03    Customer-3  Page2
# 10:01:04    Customer-2  Page4
# 10:01:05    Customer-1  Page5
# 10:01:06    Customer-2  Page9
# 10:01:07    Customer-3  Page7
# 10:01:07    Customer-1  Page8

# Customer-1: Page1, Page5, Page8, Page9, Page6
# Customer-2: Page5, Page8, Page9, Page1

# Page5, Page8, Page9 is the most favorite 3-page sequence visited by customers

# dic = {CustomerId: [(Timestamp, PageId), (s)] }


from collections import defaultdict, Counter
from itertools import combinations

Tuple resultTuple = 3mostVisitedPageId(inputTuples);

class Main:
    def 3mostVisitedPageId(self, inputTuples, n, k):
        
        Timestamp, CustomerId, PageId = zip(inputTuples)
        
        users = defaultdict(list)
        for i in range(0, len(CustomerId)):
            users[CustomerId[i]].append((Timestamp[i]), PageId[i])
            
        most_visited_pages = Counter()
        for user in users:
            pages = [pageid for timestamp, pageid in sorted(users[user])] # pageid start from earlier to latter of one user
            
            for item in {sequence for sequence in combinations(pages, n):
                most_visited_pages[item] += 1
                
        ans = sorted(most_visited_pages.items(), key = lambda x: (-x[1], x[0][0], x[0][1], x[0][2]))
        
        res = [ans[0] for i in range(k)]
            
        return res
            
            
        most_visited_pages = {(Page1, Page2, Page3) : 2,
                            (Page1, Page2, Page3) : 3,
                            (Page1, Page2, Page3) : 1
        } 
        
        most_visited_pages.items() = [((Page1, Page2, Page3), 2), ((Page1, Page2, Page3), 3), ((Page1, Page2, Page3), 1)]
```


```python
def hello2():
    print('yes')
    
hello2()
```

    yes


## 1153 String Transforms Into Another String (defaultdict) (Google 20)


```python
from collections import defaultdict
class Solution:
    def canConvert(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: bool
        """
        s1 = defaultdict(list)
        for i, ch in enumerate(str1):
            s1[ch].append(i)
            
        s2 = defaultdict(list)
        for i, ch in enumerate(str2):
            s2[ch].append(i)
            
        if len(s1) == len(s2) == 26 and str1 != str2:
            return False

        for v in s1.values():
            pivot = str2[v[0]]
            for pos in v:
                if str2[pos] != pivot:
                    return False

        return True

```

### Dict

## 205 Isomorphic String (String. Dic) (Amazon 4, Google Phone new grad)


```python
class Solution:
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """

        def convert(word):
            num = 0
            dic = {}
            res = ''
            for i in word:
                if i not in dic:                # 第一次出现这个字符
                    num += 1                       # 用一个全新的num来对应它
                    dic[i] = num                # 存进dict供给后面用
                    res += str(num) 
                else:
                    res += str(dic[i]) # 之前出现过了这个字符那么就加上它之前对应的数字
            return res
        
        return convert(s) == convert(t)
```


```python
class Solution:
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        return len(set(zip(s,t))) == len(set(s)) == len(set(t))
```

## 890. Find and Replace Pattern (String. Dic) (Google 3)  
定义一个convert函数  
首先对于传进来的word做一个for loop  
只要字符没有出现过就用一个全新的num来对应它  
否则就用之前存在dict里面的它所对应num来对应它  
比较每个word convert之后是否于pattern convert之后相等，相等就加入最终结果  
返回最终结果  


```python
class Solution:
    def findAndReplacePattern(self, words, pattern):
        """
        :type words: List[str]
        :type pattern: str
        :rtype: List[str]
        """
        def convert(word):
            num = 0
            dic = {}
            res = ''
            for i in word:
                if i not in dic:                # 第一次出现这个字符
                    num += 1                       # 用一个全新的num来对应它
                    dic[i] = num                # 存进dict供给后面用
                    res += str(num) 
                else:
                    res += str(dic[i]) # 之前出现过了这个字符那么就加上它之前对应的数字
            return res
        
        res = []
        for word in words:
            if convert(word) == convert(pattern):
                res.append(word)
        return res
```

## 1056. Confusing Number (String. Dict) (Google 3 Phone)


```python
class Solution:
    def confusingNumber(self, N):
        """
        :type N: int
        :rtype: bool
        """
        
        s = str(N)
        dic = {'0':'0',
               '1':'1',
               '8':'8',
               '6':'9',
               '9':'6'}

        notSame = False
        
        for i in range(0, len(s)):
            if s[i] not in dic:
                return False
            
            if dic[s[i]] != s[len(s)-1-i]:
                notSame=True
        return notSame
```

## 1088. Confusing Number II (String) (Google Phone 15)


```python
class Solution:
    def confusingNumberII(self, N):
        valid = [0,1,6,8,9]
        mapping = {0: 0,1: 1,6: 9,8: 8, 9: 6}
        
        self.count = 0
        def backtrack(v, rotation, digit):
            if v != rotation:
                self.count += 1
            
            # self.count += v != rotation
            for i in valid: 
                if v*10 + i <= N:
                    backtrack(v*10+i, mapping[i]*digit + rotation, digit*10)
                    
        if N >= 1: 
            backtrack(1,1,10)
        if N >= 6: 
            backtrack(6,9,10)
        if N >= 8: 
            backtrack(8,8,10)
        if N >= 9: 
            backtrack(9,6,10)
            
        return self.count 
```

## 788. Rotated Digits (Google Phone)


```python
class Solution:
    def rotatedDigits(self, N):
        """
        :type N: int
        :rtype: int
        """
        count = 0
        for n in range(1, N+1):
            ok = False
            for c in str(n):
                if c in "2569":
                    ok = True
                elif c in "347":
                    ok = False
                    break
            if ok:
                count += 1
        return count
```

## 957. Prison Cells After N Days (List, Dict) (Amazon OA 20)

时间复杂度: O(1)


```python
class Solution:
    def prisonAfterNDays(self, cells, N):
        """
        :type cells: List[int]
        :type N: int
        :rtype: List[int]
        """
        cache = {str(cells): 0}
        states = [cells]

        for i in range(1, N+1):
            cells = [0] + [int(cells[i - 1] == cells[i + 1]) for i in range(1, 7)] + [0]
#             print('cells =', cells)
#             print('i =', i)
            
            if str(cells) in cache:
                
                idx = cache[str(cells)]
                return states[idx+(N-idx)%(i-idx)] # why?
            
            cache[str(cells)] = i
            states.append(cells)
        return cells
```


```python
cells = [1,0,0,1,0,0,1,0]
N = 16

s = Solution()
s.prisonAfterNDays(cells, N)
```


```python
1 + (1000000000 - 1) % (15 - 1)
```

## 1. Two Sum (List. Dict) (Amazon 213, Google 109, Apple 72, Microsoft 34, Facebook 32)

时间复杂度: O(N)  
O(N)


```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        dic = {}
        for i, n in enumerate(nums):
            tmp = target - n
            if tmp not in dic:
                dic[n] = i
            else:
                return [dic[tmp], i]
            
x = Solution()
x.twoSum([2,7,11,15],13)
```

## Two Sum - Unique Pairs (Amazon OA)


```python
def uniquePairs(nums, target):
    seen = set()
    count = 0
    for num in nums:
        if num not in seen:
            seen.add(num)
            if target - num in seen:
                count += 1
                
#         if target - num in seen and num not in seen:
#             count += 1
#             seen.add(num)
        
        
#         elif num not in seen:
#             seen.add(num)
            
    print(seen)  
    return count

nums = [1, 1, 2, 45, 46, 46]
target = 47

# nums = [1, 1]
# target = 2
uniquePairs(nums, target)

```

    {1, 2, 45, 46}





    2



## Find Pair With Given Sum (Amazon OA)


```python
def findSum(nums, target):
    target -= 30
    map = {}
    maximum = -1
    ans = [-1,-1]
    for i in range(len(nums)):
        if nums[i] not in map:
            map[target - nums[i]] = i
        else:
            if nums[i] > maximum or target - nums[i] > maximum:
                ans[0] = map[nums[i]]
                ans[1] = i
                maximum = max(nums[i],target - nums[i])
    if ans != [-1,-1]:
        return ans
    else:
        return []
```

## 13. Roman to Integer(String. Dic) (Amazon 13, Microsoft 6, Facebook 6)

O(N)  
O(1)


```python
class Solution:
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        dic = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        
        res = 0
        res += dic[s[0]]
        
        for i in range(1, len(s)):
            if dic[s[i]] <= dic[s[i-1]]:
                res += dic[s[i]]
            else:
                res += dic[s[i]] - 2 * dic[s[i-1]]
        return res
```


```python
class Solution:
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        dic = {'I':1, 
               'V':5, 
               'X':10, 
               'L':50, 
               'C':100, 
               'D':500, 
               'M':1000}        
        ans = 0
        for i in range(len(s)):            
            if i < len(s) - 1 and dic[s[i]] < dic[s[i+1]]:                
                ans -= dic[s[i]]
            else:
                ans += dic[s[i]]
        return ans
```

## 12. Integer to Roman (Int. List, Dic) (Amazon 12)

O(1)  
O(1)


```python
class Solution:
    def intToRoman(self, num):
        """
        :type num: int
        :rtype: str
        """
        M = ["", "M", "MM", "MMM"];
        C = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]
        X = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]
        I = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]
        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]
```


```python
s = Solution()
num = 3999
s.intToRoman(num)
```


```python
3999 % 10
```


```python
class Solution:
    def intToRoman(self, num):
        """
        :type num: int
        :rtype: str
        """
        dic = {
            'M': 1000, 
            'CM': 900, 
            'D': 500, 
            'CD': 400, 
            'C': 100, 
            'XC': 90, 
            'L': 50, 
            'XL': 40, 
            'X': 10, 
            'IX': 9, 
            'V': 5, 
            'IV': 4, 
            'I': 1 
        }
        
        res = ''
#         slookup = sorted(lookup.items(), key = lambda x: x[1], reverse = True)
        for k, v in dic.items():
            while num >= v:
                res += k
                num -= v
        return res
```


```python
s = Solution()
s.intToRoman(4)
```

## Integer to English Words (Facebbook 49, Amazon 21, Microsoft 20)


```python
class Solution(object):
    def numberToWords(self, num):
        """
        :type num: int
        :rtype: str
        """
        def one(num):
            switcher = {
                1: 'One',
                2: 'Two',
                3: 'Three',
                4: 'Four',
                5: 'Five',
                6: 'Six',
                7: 'Seven',
                8: 'Eight',
                9: 'Nine'
            }
            return switcher.get(num)

        def two_less_20(num):
            switcher = {
                10: 'Ten',
                11: 'Eleven',
                12: 'Twelve',
                13: 'Thirteen',
                14: 'Fourteen',
                15: 'Fifteen',
                16: 'Sixteen',
                17: 'Seventeen',
                18: 'Eighteen',
                19: 'Nineteen'
            }
            return switcher.get(num)
        
        def ten(num):
            switcher = {
                2: 'Twenty',
                3: 'Thirty',
                4: 'Forty',
                5: 'Fifty',
                6: 'Sixty',
                7: 'Seventy',
                8: 'Eighty',
                9: 'Ninety'
            }
            return switcher.get(num)
        

        def two(num):
            if not num:
                return ''
            elif num < 10:
                return one(num)
            elif num < 20:
                return two_less_20(num)
            else:
                tenner = num // 10
                rest = num - tenner * 10
                return ten(tenner) + ' ' + one(rest) if rest else ten(tenner)
        
        def three(num):
            hundred = num // 100
            rest = num - hundred * 100
            if hundred and rest:
                return one(hundred) + ' Hundred ' + two(rest) 
            elif not hundred and rest: 
                return two(rest)
            elif hundred and not rest:
                return one(hundred) + ' Hundred'
        
        billion = num // 1000000000
        million = (num - billion * 1000000000) // 1000000
        thousand = (num - billion * 1000000000 - million * 1000000) // 1000
        rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000
        
        if not num:
            return 'Zero'
        
        result = ''
        if billion:        
            result = three(billion) + ' Billion'
        if million:
            result += ' ' if result else ''    
            result += three(million) + ' Million'
        if thousand:
            result += ' ' if result else ''
            result += three(thousand) + ' Thousand'
        if rest:
            result += ' ' if result else ''
            result += three(rest)
        return result
```

## 136. Single Number (List. Dic, Set) (Amazon 7)

O(N)  
O(N)


```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        seen = set()
        
        for n in nums:
            if n not in senn:
                seen.add(n)
            else:
                seen.remove(n)
                
        for n in seen:
            return n
        
```


```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        for n in nums:
            if n not in dic:
                dic[n] = 1
            else:
                dic.pop(n)
#         return dic.popitem()[0]
        for n in dic:
            return n
```


```python
dic = {0:1, 
      1:2}
dic.keys()[0]
```


```python
2 ^ 3
```




    1




```python
def xor(nums):
    a = 0
    for i in nums:
        a ^= i
    return a
```


```python
0 ^ 0
```




    0



## 953. Verifying an Alien Dictionary (String List. Dic) (Facebook 74->94, Microsoft 2, Google)


```python
class Solution:
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        
        order_index = {c: i for i, c in enumerate(order)}

        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]

            # Find the first difference word1[k] != word2[k].
            for k in range(min(len(word1), len(word2))):
                # If they compare badly, it's not sorted.
                if word1[k] != word2[k]:
                    if order_index[word1[k]] > order_index[word2[k]]:
                        return False
                    break
            
                # If we didn't find a first difference, the
                # words are like ("app", "apple").
                if len(word1) > len(word2):
                    return False

        return True
```

## 349. Intersection of Two Arrays (List, Set) (Facebook 14, Amazon 6)

O(M+N)  
O(M+N)


```python
class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """  
        return list(set(nums1) & set(nums2))
```


```python
class Solution(object):
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        res = set()
        set1 = set(nums1)
                
        for n in nums2:
            if n in set1:
                res.add(n)
                
        return res
```


```python
class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        res = set()
        set1 = set()
        
        for n in nums1:
            set1.add(n)    
        
        for n in nums2:
            if n in set1:
                res.add(n)
                
        return res
```

## 268. Missing Number (List, Set) (Amazon 5, Microsoft 5, Apple 3)


```python
# O(n)
# O(1)
class Solution:
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # Gauss' Formula
        expected_sum = len(nums)*(len(nums)+1)//2
        actual_sum = sum(nums)
        return expected_sum - actual_sum
```


```python
array = [1,2,3,4]
for i in range(len(array)):
    for j in range(i+1, len(array)):
        print(i+j)
```

    1
    2
    3
    3
    4
    5



```python
# O(N)  
# O(N)
class Solution:
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        set1 = set(nums)
        for n in range(len(nums)+1):
            if n not in set1:
                return n
```


```python
array = [1,2,2,4]
set1 = set(array)
set2 = set([1,2,4])
array2 = [1,2,4]

array == array2
```

## 202. Happy Number (Int, Set) (Amazon 4, Google 4, Apple 5)

O(N)  
O(N)


```python
class Solution:
    def isHappy(self, n):
        seen = set()
        while n not in seen:
            seen.add(n)
            n = sum([int(x) **2 for x in str(n)])
        return n == 1
```

## 771. Jewesl and Stones (Int, Set) (Google 5, Apple 4)

O(J+S)  
O(J)


```python
class Solution:
    def numJewelsInStones(self, J, S):
        """
        :type J: str
        :type S: str
        :rtype: int
        """
        Jset = set(J)
        return sum(s in Jset for s in S)
    
s = Solution()
s.numJewelsInStones("aA", "aAAbbbb")
```


```python
J = 'aA'
S = 'aAAbbbb'
[s in J for s in S]

Jset = set(J)
Jset

Sset = set(S)
Sset
```




    [True, True, True, False, False, False, False]






    {'A', 'a'}






    {'A', 'a', 'b'}




```python

```

## 929. Unique Email Adress (List, Set) (Google 2)
O(N)  
O(N)


```python
class Solution:
    def numUniqueEmails(self, emails):
        """
        :type emails: List[str]
        :rtype: int
        """
        seen = set()
        for email in emails:
            local, domain = email.split('@')
            if '+' in local:
                local = local[:local.index('+')]
            seen.add(local.replace('.','') + '@' + domain)
        return len(seen)
```
