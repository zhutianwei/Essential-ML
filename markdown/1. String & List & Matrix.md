```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

# Leetcode

~ means revert every bit.  
Therefore, ~x means -x-1.  
An elegant (but confusing) way to choose the rightest element of the middle part.


```python
'/root/home/'.split('/')
```




    ['', 'root', 'home', '']



## Microsoft Codility Demo


```python
def solution(A):
    array = sorted(A)
    print(array)
    
    i = 0
    while i < len(array) - 1:
        if array[i] <= 0:
            i += 1
            continue
            
        if array[i+1] - array[i] > 1:
            return array[i] + 1
        
        i += 1
        
    if array[-1] <= 0:
        return 1
    
    else:
        return array[-1] + 1
    
a = [1,3,6,4,1,2]
solution(a)
```

    [1, 1, 2, 3, 4, 6]





    5




```python
def f():
    i = 0
    array = [1,2,3]
    
    while i < len(array):
        if array[i] == 1:
            i += 1
        
        print(array[i])
        i += 1
            
f()
```

    2
    3



```python
def f():
    i = 0
    array = [1,2,3]
    
    while i < len(array):
        if array[i] == 3:            
            print('yes')
            

        i += 1
            
f()
```

    yes


### General

### Math


```python
math.floor(-345.5)

int(-3.6)

round(-3.6)

divmod(351, 10) # (a // b, a % b)

math.log10(19876)
```




    -346






    -3






    -4






    (35, 1)






    4.298328988073496




```python
import math
def vertical_print(a):
    if a == 0:

        return


    n = math.floor(math.log10(a))

    while n>=0:
        d,m = divmod(a, 10**n)

        a = m
        n-=1
        
    return a
        

vertical_print(1234)
```




    0



## 191. Number of 1 Bits (Facebook 5, Apple 2)


```python
class Solution:
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        bits = 0
        for i in range(32):
            if n & 1 != 0:
                bits += 1
                
            n >>= 1
            
        return bits
```


```python
class Solution:
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        bits = 0
        mask = 1
        for i in range(32):
            if n & mask != 0:
                bits += 1
                
            mask <<= 1
            
        return bits
```


```python
mask = 1
for i in range(2):
    mask <<= 1
    
mask
bin(mask)

```




    4



## 190. Reverse Bits (Apple 3)

As easy as it sounds, the above intuition could lead to quite some variants of implementation. For instance, to retrieve the right-most bit in an integer n, one could either apply the modulo operation (i.e. n % 2) or the bit AND operation (i.e. n & 1). 


```python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):    
        ret, power = 0, 31
        while n:
            ret += (n & 1) << power

            n >>= 1
            power -= 1
        return ret
```

## 401. Binary Watch (Apple 2)


```python
class Solution(object):
    def readBinaryWatch(self, num):
        """
        :type num: int
        :rtype: List[str]
        """
        ans = []
        
        def bitCount(n):            
            count = 0
            while n > 0:
                if n % 2 == 1:
                    count += 1
                n = n >> 1
            
            return count
        
        def convert(H, M):
            # convert to string time 0 <= H < 12 
            if M < 10:
                return str(H) + ':' + '0' + str(M)
            
            else:
                return str(H) + ':' + str(M)
            
            # return str(H) + ":" + ("0" if M < 10 else "") + str(M)
        
        for H in range(0, 12):
            for M in range(0, 60):
                if bitCount(H) + bitCount(M) == num:
                    ans.append(convert(H, M))
        return ans
```

## 67 Add Binary (Facebook 45, Google 2)


```python
class Solution:
    def addBinary(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: str
        """
        
        def convert(num):
            res = 0

            for exp, n in enumerate(num[::-1]):
                if n == '1':
                    res += pow(2, exp)
           
            return res
        
        x = convert(a)
        y = convert(b)
            
        res = x + y
        
        return bin(res).replace("0b", "") 
        
        x = convert(a)
        y = convert(b)
            
        res = x + y
        
        return bin(res).replace("0b", "") 
    
    # "{0:#b}".format(my_int)
    # int('11111111', 2)
```


```python
int('11111', 2)
```




    31




```python
bin(11111)
```




    '0b10101101100111'




```python
ord('0')
ord('1')
```




    48






    49



## 393. UTF-8 Validation (Apple?)


```python
class Solution(object):
    def validUtf8(self, data):
        """
        :type data: List[int]
        :rtype: bool
        """
        # Number of bytes in the current UTF-8 character
        n_bytes = 0

        # Mask to check if the most significant bit (8th bit from the left) is set or not
        mask1 = 1 << 7

        # Mask to check if the second most significant bit is set or not
        mask2 = 1 << 6
        for num in data:

            # Get the number of set most significant bits in the byte if
            # this is the starting byte of an UTF-8 character.
            mask = 1 << 7
            if n_bytes == 0:
                while mask & num:
                    n_bytes += 1
                    mask = mask >> 1

                # 1 byte characters
                if n_bytes == 0:
                    continue

                # Invalid scenarios according to the rules of the problem.
                if n_bytes == 1 or n_bytes > 4:
                    return False
            else:

                # If this byte is a part of an existing UTF-8 character, then we
                # simply have to look at the two most significant bits and we make
                # use of the masks we defined before.
                if not (num & mask1 and not (num & mask2)):
                    return False
            n_bytes -= 1
        return n_bytes == 0 
```

## 171. Excel Sheet Column Number (Microsoft 3)  
This reverses the string, starts a sum at 0, creates a list of tuples of the index of each character in the reversed string (which corresponds to the exponent) and character itself. Add them up. We take ord(char) to turn the character to an integer, subtract 65 = ord('A') from it, and add one because we want A to equal 1, not 0.


```python
class Solution(object):
    def titleToNumber(self, s):
        """
        :type s: str
        :rtype: int
        """
        s = s[::-1]
        sum = 0
        for exp, char in enumerate(s):
            sum += (ord(char) - 64) * (26 ** exp)
        return sum
```


```python
chr(20)
ord('A')
```




    '\x14'






    65




```python
class Solution(object):
    def titleToNumber(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s:
            return 
        
        
        dic = dict([(chr(i), i-64) for i in range(65,91)])
        
        res = 0
        for i, c in enumerate(s[::-1]):
            
            res += dic[c] * 26**i
            
        return res
```


```python
import string
d = dict.fromkeys(string.ascii_uppercase, 0)
d
```




    {'A': 0,
     'B': 0,
     'C': 0,
     'D': 0,
     'E': 0,
     'F': 0,
     'G': 0,
     'H': 0,
     'I': 0,
     'J': 0,
     'K': 0,
     'L': 0,
     'M': 0,
     'N': 0,
     'O': 0,
     'P': 0,
     'Q': 0,
     'R': 0,
     'S': 0,
     'T': 0,
     'U': 0,
     'V': 0,
     'W': 0,
     'X': 0,
     'Y': 0,
     'Z': 0}




```python
d = dict.fromkeys([chr(i) for i in range(65, 90)], 0)
d
```




    {'A': 0,
     'B': 0,
     'C': 0,
     'D': 0,
     'E': 0,
     'F': 0,
     'G': 0,
     'H': 0,
     'I': 0,
     'J': 0,
     'K': 0,
     'L': 0,
     'M': 0,
     'N': 0,
     'O': 0,
     'P': 0,
     'Q': 0,
     'R': 0,
     'S': 0,
     'T': 0,
     'U': 0,
     'V': 0,
     'W': 0,
     'X': 0,
     'Y': 0}




```python
dic = dict([(chr(i), i-64) for i in range(65,91)])
dic
```




    {'A': 1,
     'B': 2,
     'C': 3,
     'D': 4,
     'E': 5,
     'F': 6,
     'G': 7,
     'H': 8,
     'I': 9,
     'J': 10,
     'K': 11,
     'L': 12,
     'M': 13,
     'N': 14,
     'O': 15,
     'P': 16,
     'Q': 17,
     'R': 18,
     'S': 19,
     'T': 20,
     'U': 21,
     'V': 22,
     'W': 23,
     'X': 24,
     'Y': 25,
     'Z': 26}



## 168. Excel Sheet Column Title (Microsoft 4, Facebook 4, Google 2, Apple 2)


```python
class Solution(object):
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        count = 0
        d = collections.defaultdict()
        for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
            d[count] = i
            count += 1
            
        res = ''
        n -= 1
        while n>=0:
            res = d[(n)%26] + res
            n//=26
            n-=1
        return res
```

## (5) 7. Reverse Integer (Int. Math) (Amazon 9)

时间复杂度: O(lgx)  
O(1)


```python
class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x < 0:
            return -self.reverse(-x)
        
        res = 0
        while x:
            res = res * 10 + x % 10
            x //= 10
            
        return res if res <= 2**31 - 1 else 0
```


```python
a = Solution()
a.reverse(-23)
```




    -32




```python
0x7fffffff
```


```python
2**31 -1 
```


```python
'2' == '2'
```




    True




```python
26 % 26
```




    0



## 9. Palindrome Number (Amazon 4, Google 4, Apple 2)


```python
class Solution(object):
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        if x < 0:
            return False
        
        def reverse(x):
            """
            :type x: int
            :rtype: int
            """
            res = 0
            while x:
                res = res * 10 + x % 10
                x //= 10

            return res if res <= 2**31 - 1 else 0
        
        return x == reverse(x)
```

## 866. Prime Palindrome (Amazon 9)


```python
class Solution():
    def primePalindrome(self, N):
        def is_prime(n):
            return n > 1 and all(n % d for d in range(2, int(n**.5) + 1))

        def reverse(x):
            ans = 0
            while x:
                ans = 10 * ans + x % 10
                x /= 10
            return ans

        while True:
            if N == reverse(N) and is_prime(N):
                return N
            N += 1
            
            if 10**7 < N < 10**8:
                N = 10**8
```


```python
int(6**.5)

```




    2



## 204. Count Primes (Microsoft 4, Amazon 4)


```python
class Solution:
    def countPrimes(self, n):
        """
        :type n: int
        :rtype: int
        """
        isPrime = [True] * n
    
        for i in range(2, n):
            if i*i < n and isPrime[i*i]:
                for j in range(i*i, n, i):
                    isPrime[j] = False
                
        count = 0
        for i in range(2, n):
            if isPrime[i]:
                count += 1
                
        return count
                
```


```python
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
```

    2 is a prime number
    3 is a prime number
    4 equals 2 * 2
    5 is a prime number
    6 equals 2 * 3
    7 is a prime number
    8 equals 2 * 4
    9 equals 3 * 3



```python
1 & 2
```




    0




```python
bin(2)
```




    '0b10'



## 390. Elimination Game (Amazon, Quora 2)


```python
class Solution(object):
    def lastRemaining(self, n):
        """
        :type n: int
        :rtype: int
        """
        step = 1
        head = 1
        left = True
        
        while n > 1:
            if left or n % 2:
                head += step
            
            n //= 2
            step *= 2
            left = not left
        
        return head
```

## 29. Divide Two Integers (Facebook 17, Amazon 3, Microsoft Onsite)


```python
# 不能乘除，所以我们改用位运算，运用二分的思想，beats 100%
# 因为最坏的情况就是最大的数除以1，即2**31 / 1, 所以时间复杂度就是O(1)，如果assuming n is the number of bits， 那就是O(lgN)

# O(1)
# O(1)
class Solution:
    def divide(self, dividend, divisor):
        """
        :type dividend: int
        :type divisor: int
        :rtype: int
        """
        positive = (dividend > 0) is (divisor > 0)
        dividend, divisor = abs(dividend), abs(divisor)
        res = 0
        while dividend >= divisor:
            tmp, cnt = divisor, 1
            while dividend >= tmp:
                tmp <<= 1
                cnt <<= 1
            dividend -= tmp >> 1
            res += cnt >> 1
        res = res if positive else -res
        if res >= 2**31 - 1:
            return 2**31 - 1
        elif res <= -(2**31):
            return -(2**31)
        else:
            return res
```


```python
bin(256)
```




    '0b100000000'



## 681. Next Closest Time (String. Math) (Google 17)

O(1)


```python
class Solution:
    def nextClosestTime(self, time):
        """
        :type time: str
        :rtype: str
        """
        
        cur = 60 * int(time[:2]) + int(time[3:])
#         print('cur=', cur)
        allowed = {int(x) for x in time if x != ':'}
#         print('allowed=', allowed)
        while True:
            cur = (cur + 1) % (24 * 60)
#             print('cur=', cur)
            if all(digit in allowed
                    for block in divmod(cur, 60)
                    for digit in divmod(block, 10)):
                return "{:02d}:{:02d}".format(*divmod(cur, 60))
```


```python
s = Solution()
time = "19:34"
s.nextClosestTime(time)
```


```python
divmod(120, 60)
```

## 65. Valid Number (Facebook 14)


```python
class Solution():
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """
        try:
            float(s)
            return True
        except:
            return False  
```

## 8. String to Integer(atoi) (String. Math) (Facebook 6, Microsoft 5, Amazon 5)

O(N)  
O(1)


```python
class Solution:
    # @param str, a string
    # @return an integer
    def myAtoi(self, s):
        """
        :type str: str
        :rtype: int
        """
        s = s.strip()
        
        if not s:
            return 0
        
        num = ''
        if s[0] in '+-':
            num += s[0]
            s = s[1:]
            
        for c in s:            
            if c.isnumeric(): 
                num += c
            else:
                break
                
        try: 
            res = int(num)
            if res > 2**31 - 1:
                return 2**31 - 1 
            elif res < -2**31:
                return -2**31
            else:
                return res
        
        except:
            return 0
```


```python
int('+4')
```




    4




```python
ch = '3'
ch.isdigit()
```

## 415. Add Strings (String. Math, Dic) (Facebook 28->41, Amazon 2->6, Microsoft Onsite 2, Apple 2)


```python
class Solution(object):
    def addStrings(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        res = []
        carry = 0
        i = len(num1) - 1
        j = len(num2) - 1
        
        while i >= 0 or j >= 0:
            x = int(num1[i]) if i >= 0 else 0
            y = int(num2[j]) if j >= 0 else 0
            
            sums = x + y + carry
            carry = sums // 10
            res.append(str(sums % 10))
            
            if i >= 0:
                i -= 1
                
            if j >= 0:
                j -= 1
                
        if carry > 0:
            res.append(str(carry))
            
        res.reverse()
        
        return ''.join(res)
```

See 43

## 43. Multiply String (String. Math, Dic) (Facebook 8, Google 5, Microsoft Onsite 5, Apple 3)


```python
# O(N)
# O(N)
class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        dic = {'0':0,
              '1':1,
              '2':2,
              '3':3,
              '4':4,
              '5':5,
              '6':6,
              '7':7,
              '8':8,
              '9':9}
        
        x1 = 0
        for n in num1:
            x1 = x1 * 10 + dic[n]
            
        
        x2 = 0
        for n in num2:
            x2 = x2 * 10 + dic[n]
            
        res = x1 * x2
        if not res:
            return '0'
        
        ans = ''
        while res:
            
            for k, v in dic.items():
                if v == res % 10:
                    ans += k
        
            res //= 10
            
        return ans[::-1]
```


```python
class Solution(object):
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        res = [0] * (len(num1) + len(num2))
        for i in range(len(num1)-1, -1, -1):
            carry = 0
            for j in range(len(num2)-1, -1, -1):
                tmp = int(num1[i])*int(num2[j])+carry 
                # take care of the order of the next two lines
                carry = (res[i+j+1] + tmp) // 10  
                res[i+j+1] = (res[i+j+1] + tmp) % 10
                # or simply: carry, res[i+j+1] = divmod((res[i+j+1] + tmp), 10)
            res[i] += carry
        res = "".join(map(str, res))
        return '0' if not res.lstrip("0") else res.lstrip("0")
    
num1 = '123'
num2 = '21'

s = Solution()
s.multiply(num2, num1)
```




    '2583'




```python
class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        def str2int(num):
            res = 0
            for i in range(len(num)-1, -1, -1):
                res += int(num[i]) * pow(10, len(num)-1-i)
            return res
        return str(str2int(num1) * str2int(num2))
```


```python
def str2int(num):
            res = 0
            for i in range(len(num)-1, -1, -1):
                res += int(num[i]) * pow(10, len(num)-1-i)
            return res
        
str2int('34')
```

Linked List

### Greedy

## Largest Integer (Microsoft OA)


```python
def solution(array):
    res = 0
    set1 = set(array)
    for n in array:
        if -n in set1:
            res = max(res, abs(n))
            
    return res

a = [3, 2, -2, 5, -3]
b = [1, 2, 3, 0, -4]
solution(b)
```




    0



## Numbers With Equal Digit Sum (List. Dic, Greedy) (Microsoft OA)


```python
def largest_digit_sum(arr):
    def find_digit_sum(num):
        val = 0
        while num:
            val += num % 10
            num //= 10
            
        return val
    
    dic = {}
    res = -1
    for num in arr:
        sums = find_digit_sum(num)
        
        if sums in dic:
            previous = dic[sums]
            dic[sums] = max(previous, num)
            res = max(res, previous + num)
            
        else:
            dic[sums] = num
            
    return res
```


```python
array = [51, 71, 17, 42]  # 93
largest_digit_sum(array)
```




    93



## 1239. Maximum Length of a Concatenated String with Unique Characters (Microsoft OA)


```python
def solution(s):
    arr = [s for s in arr if len(s) == len(set(s))]
    if not arr:
        return 0

    arr.sort(key=len, reverse=True)
    print(arr)
    res = 0

    for i in range(len(arr)):
        tmp = arr[i]
        for j in range(len(arr)):
            if not set(tmp) & set(arr[j]):
                tmp += arr[j]
        res = max(res, len(tmp))

    return res
```


```python
def solution(s):
    array = []
    for s in arr:
        if len(s) == len(set(s)):
            array.append(s)
```

## Widest Path Without Trees (Microsoft OA)


```python
def solution(x, y):
    widest = 0
    x.sort()
    
    for i in range(len(x)-1):
        widest = max(widest, x[i+1] - x[i])
        
    return widest
```

## 1007. Minimum Domino Rotations For Equal Row (Google OA)


```python
class Solution:
    def minDominoRotations(self, A: List[int], B: List[int]) -> int:
        def qualified_domino(num):
            for i in range(len(A)):
                if A[i] != num and B[i] != num:
                    return False
            return True
        
        if not qualified_domino(A[0]) and not qualified_domino(B[0]):
            return -1
            
        if qualified_domino(A[0]):
            return min(len(A)-A.count(A[0]), len(B)-B.count(A[0]))
            
        if qualified_domino(B[0]):
            return min(len(A)-A.count(B[0]), len(B)-B.count(B[0]))
```

## Whac a Mole (Google Phone)
https://leetcode.com/discuss/interview-question/350139/Google-or-Phone-Screen-or-Whac-A-Mole 


```python
class Solution:
    def mallet(self, holes,w):
        """
        :type rowIndex: int
        :rtype: List[int]
        """
        if not (holes and w):
            return 0
        
        if len(holes) < w:
            return 0
        
        result = 0
        for i in range(w):
            result += holes[i]
         
        curr_sum = result  #update
        for j in range(w,len(holes)): #update
            curr_sum += holes[j] - holes[j-w]  #update
            result = max(result,curr_sum)

        return result
```


```python
s = Solution()
s.mallet([0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], 5)
```

## 243. Shortest Word Distance (Amazon 2)


```python
class Solution(object):
    def shortestDistance(self, words, word1, word2):
        """
        :type words: List[str]
        :type word1: str
        :type word2: str
        :rtype: int
        """
        i1 = -1
        i2 = -1
        minDistance = len(words)
        
        for i in range(len(words)):
            if words[i] == word1:
                i1 = i
                
            elif words[i] == word2:
                i2 = i
                
            if i1 != -1 and i2 != -1:
                minDistance = min(minDistance, abs(i1 - i2))
                
        return minDistance
```

## 55. Jump Game (List) (Amazon 10, Google 6, Microsoft OA Phone)
O(N)  
O(1)


```python
class Solution:
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        
        if len(nums) <= 1:
            return True

        # max position one could reach 
        # starting from index <= i
        max_pos = nums[0]
        
        for i in range(len(nums)):
            nxt = i + nums[i]
            
            if nxt >= len(nums) - 1:
                return True        
        
            if i == nxt and nxt == max_pos:
                return False

            max_pos = max(max_pos, nxt)
            
        return True
```


```python
class Solution:
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """ 
        if len(nums) <= 1:
            return True

        # max position one could reach 
        # starting from index <= i
        max_pos = nums[0]
        
        for i in range(1, len(nums)):
            # if one could't reach this point
            if max_pos < i:
                return False
            
            max_pos = max(max_pos, nums[i] + i)

        return True
```


```python
class Solution:
    def canJump(self, nums):
        m = 0
        for i, n in enumerate(nums):
#             print('i=',i,'n=',n) 
            if i > m:
                return False
            m = max(m, i+n)
#             print('m=',m)
        return True
```


```python
class Solution:
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """ 
        if len(nums) <= 1:
            return True
        
        max_jump = float('-inf')
        for i, n in enumerate(nums):
            max_jump = max(max_jump-1, n)
            
            if max_jump + i >= len(nums) - 1:
                return True
            if max_jump == 0:
                return False
```


```python
s = Solution()
nums = [2,3,1,1,4]
s.canJump(nums)
```


```python
s = Solution()
nums = [3,2,1,0,4]
s.canJump(nums)
```

## 45. Jump Game II (List) (Amazon 10-> 5, Microsoft 3, Google 2->4)
O(N)   
O(1)


```python
class Solution:
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """

        if len(nums) <= 1:
            return 0 
        
        # max position one could reach 
        # starting from index <= i 
        max_pos = nums[0]
        # max number of steps one could do
        # inside this jump
        max_steps = nums[0]
        
        jumps = 1
        for i in range(1, len(nums)):
            # if to reach this point 
            # one needs one more jump
            if max_steps < i:
                jumps += 1
                max_steps = max_pos
            max_pos = max(max_pos, nums[i] + i)
                
        return jumps
```


```python
class Solution:
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        cur_end = 0
        cur_farthest = 0
        res = 0
        for i in range(len(nums)-1):
            cur_farthest = max(cur_farthest, i + nums[i])
            if cur_farthest >= len(nums) - 1:
                res += 1
                return res
            if i == cur_end:
                cur_end = cur_farthest
                res += 1
        return res
```

## 121. Best Time to Buy and Sell Stock (List) (Amazon Onsite 26, Microsoft 6->10, Facebook 5->20)
O(N)  
O(1)


```python
class Solution:
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        
        min_price = float('inf')
        max_profit = float('-inf')
        
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
            
        return max_profit
```

## 122. Best Time to Buy and Sell Stock II (List) (Amazon 11, Microsof 3, Facebook 3, Google 5->2)  
O(N)  
O(1)


```python
class Solution:
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        maxprofit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                maxprofit += prices[i] - prices[i-1]
                
        return maxprofit
```

## 674. Longest Continuous Increasing Subsequence (List) (Facebook 7)
O(N)  
O(1)


```python
class Solution():
    def findLengthOfLCIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        if len(nums) == 1:
            return 1
        
        ans = 0
        anchor = 0
        for i in range(1, len(nums)):
            if nums[i-1] >= nums[i]: 
                anchor = i
                
            ans = max(ans, i - anchor + 1)

        return ans
```

## (4) 56. Merge Intervals (Lists) (Facebook 29, Microsoft 12, Amazon 10, Google 13)

O(nlogn)  
O(n)


```python
class Solution:
    def merge(self, lists):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        if not lists:
            return 
        
        lists.sort()
        res = [lists.pop(0)]
#         print('new =', new)
        
        for n in lists:
#             print('i =', i)
            if res[-1][-1] >= n[0]:
                res[-1][-1] = max(res[-1][-1], n[-1])
#                 print('res1 =', res)
            else:
                res.append(n)
#                 print('res2 =', res)
#             print()
        return res
```


```python
class Solution:
    def merge(self, lists):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        
        lists.sort()
#         print('new =', new)
        res = []
        for n in lists:
#             print('i =', i)
            if res and n[0] <= res[-1][-1]:
                res[-1][-1] = max(res[-1][-1], n[-1])
#                 print('res1 =', res)
            else:
                res.append(n)
#                 print('res2 =', res)
#             print()
        return res
```


```python
s = Solution()
s.merge([[1,3],[2,6],[8,10],[15,18]])
```


```python
a = [1,2,3]
a[:-2]
```




    [1]



## 57. Insert Interval (Lists) (Amazon 11->2, Google 7, Facebbook 4) (Hard)


```python
class Solution:
    def insert(self, lists, newInterval):
        """
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        """
        if not lists:
            return [newInterval]
        
        for i in range(len(lists)):
            if lists[i][0] > newInterval[0]:
                lists.insert(i, newInterval)
                break
                
            lists.append(newInterval)            
            
        res = [lists.pop(0)]
        for n in lists:
            if res[-1][-1] >= n[0]:
                res[-1][-1] = max(res[-1][-1], n[-1])
            else:
                res.append(n)
        return res
```


```python
class Solution:
    def insert(self, intervals, newInterval):
        """
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        """
        start, end = newInterval[0], newInterval[-1]
        left = [i for i in intervals if i[-1] < start]
#         print('left=', left)
        right = [i for i in intervals if i[0] > end]
#         print('right=', right)
        if left + right != intervals:
            start = min(start, intervals[len(left)][0])
#             print('s=', s)
            end = max(end, intervals[~len(right)][-1])
#             print('e=', e)
#             print(intervals[~len(right)][-1])
            
        return left + [[start, end]] + right
```


```python
intervals = [[1,3],[6,9]]
newInterval = [2, 5]
s = Solution()
s.insert(intervals, newInterval)
```


```python
~1
```


```python
def insert(self, intervals, newInterval):
    s, e = newInterval.start, newInterval.end
    left, right = [], []
    for i in intervals:
        if i.end < s:
            left += i,
        elif i.start > e:
            right += i,
        else:
            s = min(s, i.start)
            e = max(e, i.end)
    return left + [Interval(s, e)] + right
```

### Stack

## 844. Backspace String Compare (String. Stack) (Google 10 Phone, Facebook 8, Amazon 5, Microsoft 3)

O(m+n)  
O(m+n)


```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        stack_s = []
        stack_t = []
        

        for c in S:
            if c == '#':
                if stack_s:
                    stack_s.pop()
                    
            else:
                stack_s.append(c)
                
        for c in T:
            if c == '#':
                if stack_t:
                    stack_t.pop()
                    
            else:
                stack_t.append(c)
                
        return stack_s == stack_t
```


```python
class Solution:
    def backspaceCompare(self, S, T):
        """
        :type S: str
        :type T: str
        :rtype: bool
        """
        
        def build(S):
            ans = []
            
            for c in S:
                if c != '#':
                    ans.append(c)
                    
                elif c == '#' and ans:
                    ans.pop()
            return ans
        
        return build(S) == build(T)
```

对两个字符串从右往左遍历，用子方程getChar() 从两个字符串分别取值，如取值不等则返回False，相等就继续迭代，知道迭代技术返回True  

子方程getChar()的取值规则：
While循环退出条件：下标出界或者返回值不为空。  
Case 1: 当值等于`#`, `count`增值  
Case 2: 如果`count == 0` 说明这个值没有被`#`给抵消，返回  
Case 3: 如果`count != 0` 切这个值不为`#`，这个值要被`#`抵消掉  
三个Case运行完后，记得锁紧下标`r`  


```python
S = "ab#c", T = "ad#c"
```


```python
# O(m+n)
# O(1)
class Solution:
    def backspaceCompare(self, S1, S2):
        r1 = len(S1) - 1 
        r2 = len (S2) - 1
        
        while r1 >= 0 or r2 >= 0:            
            char1, count = '', 0
            while r1 >= 0 and not char1:
                if S1[r1] != '#':
                    if count == 0:
                        char1 = S1[r1]
                    else:
                        count -= 1
                
                elif S1[r1] == '#':
                    count += 1
                
                r1 -= 1

            char2, count = '', 0
            while r2 >= 0 and not char2:
                if S2[r2] != '#':
                    if count == 0:
                        char2 = S2[r2]
                    else:
                        count -= 1       
                elif S2[r2] == '#':
                    count += 1
                    
                r2 -= 1
               
            if char1 != char2:
                return False
        return True
```

## (3) 917. Reverse Only Letters (Sring. Stack) (Microsoft 3)



```python
class Solution:
    def reverseOnlyLetters(self, S):
        """
        :type S: str
        :rtype: str
        """
        
        stack = []
        for s in S:
            if s.isalpha():
                stack.append(s)
        res = ''    
        for s in S:
            if s.isalpha():
                res += stack.pop()
            else:
                res += s
                
        return res
```

## (3) 20. Valid Parentheses (String. Stack) (Amazon 39, Microsoft 12, Facebook 11, Google 7, Apple 6, Linkedin 4)

O(N)  
O(N)  
因为一共只有三种状况"(" -> ")", "[" -> "]", "{" -> "}".

一遇到左括号就入栈，右括号出栈，这样来寻找对应

需要检查几件事：

出现右括号时stack里还有没有东西
出stack时是否对应
最终stack是否为空


```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        
        leftP = '([{'
        rightP = ')]}'
        stack = []
        for char in s:
            if char in leftP:
                stack.append(char)
            if char in rightP:
                if not stack:
                    return False
                tmp = stack.pop()
                if char == ')' and tmp != '(':
                    return False
                if char == ']' and tmp != '[':
                    return False       
                if char == '}' and tmp != '{':
                    return False
        return not stack
```


```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        dic = {')':'(',
               ']':'[',
               '}':'{'
              }
        
        stack = []
        for c in s:
            if c in dic:
                if stack and dic[c] == stack[-1]:
                    stack.pop() 
                else:
                    return False
                
            else:                
                stack.append(c)
                
        return not stack
```


```python
stack = []
stack.pop()
```


```python
class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        x"""
        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        dic = {")": "(", 
               "}": "{", 
               "]": "["}

        # For every bracket in the expression.
        for c in s:

            # If the character is an closing bracket
            if c in dic:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if dic[c] != top:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(c)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
```


```python
#O(N^2)
class Solution(object):
    def isValid(self, s):
        while "()" in s or "{}" in s or '[]' in s:
            s = s.replace("()", "").replace('{}', "").replace('[]', "")
        return s == ''
```


```python
s = 'sh'
s = s.replace('sh', '')
s

```

## 32 Longest Valid Parenthesis (Facebook 7, Amazon 6, Microsoft 5, Apple 3)


```python
class Solution:
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        stack = []
        maxlen = 0        
        stack.append(-1)
        
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
                
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                    
                else:
                    maxlen = max(maxlen, i - stack[-1])
        
        return maxlen
```


```python
s = Solution()
s.longestValidParentheses('()')
```




    2




```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        l = 0
        r = 0
        maxlen = 0
        
        for i in range(len(s)):
            if s[i] == '(':
                l += 1
                
            else:
                r += 1
                
            if l == r:
                maxlen = max(maxlen, 2 * r)
                
            elif r >= l:
                l = r = 0
                
        l = r = 0
        
        for i in range(len(s) - 1, -1, -1):
            if s[i] == '(':
                l += 1
                
            else:
                r += 1
                
            if l == r:
                maxlen = (max(maxlen, 2 * l))
                
            elif l >= r:
                l = r = 0
                
        return maxlen
```

## 71. Simplify Path (String. Stack) (Facebook 12, Amazon 5, Microsoft 3)


```python
class Solution:
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        
        stack = []
        for part in path.split("/"):
            if part and part != ".": # 如果为空或者 "." 则忽略
                if part == "..":
                    if stack:
                        stack.pop()
                else:
                    stack.append(part)
        if not stack:
            return "/"
        else:
            return "/" + "/".join(stack)
```


```python
class Solution:
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        stack = []
        for part in path.split("/"):
            if not part or part == ".": # 如果为空或者 "." 则忽略
                continue
                
            elif part == "..":
                if stack:
                    stack.pop()
            else:
                stack.append(part)
                    
        print(stack)
        if not stack:
            return "/"
        else:
            return "/" + "/".join(stack)
```


```python
s = '/a//b/c/'
s.split('/')
```




    ['', 'a', '', 'b', 'c', '']




```python
s = Solution()
s.simplifyPath('/home/')
```

    ['home']





    '/home'



## 394. Decode String (String. Stack) (Apple 4, Google 9, Amazon 6->9, Facebook 6)
  
O(N)  
O(N)


```python
class Solution:
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        stack = [["",  0]]
        
        num = ''
        for c in s:
            if c.isdigit():
                num += c
                
            elif c == '[':
                stack.append(["", int(num)])
                num = ""         
                
            elif c == ']':
                string, multiply = stack.pop()
                stack[-1][0] += string * multiply
                
            else:
                stack[-1][0] += c
                
        return stack[0][0]
```

## 224. Basic Calculator (String. Math, Stack) (Amazon 8, Facebook 6, Microsoft 4)


```python
class Solution:
    def calculate(self, s):
        """
        input: str
        output: int
        """
        
        res = 0
        sign = 1
        num = 0
        stack = []
        
        for i in range(len(s)):
            if s[i].isdigit():
                num = num * 10 + int(s[i])
                
            elif s[i] == "+" or s[i] == "-":
                res += num * sign 
                num = 0
                sign = 1 if s[i] == "+" else -1
                
            elif s[i] == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
                
            elif s[i] == ")":
                res += num * sign
                res *= stack.pop()
                res += stack.pop()
                num = 0
                sign = 1
                
        return res + num * sign
```


```python
class Solution:
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        stack = []
        res = 0 
        num = 0 
        sign = 1
        for i, c in enumerate(s):
            if c.isdigit():
                num = num * 10 + int(c)
            elif c in '+-':
                res += sign * num
                num = 0
                sign = 1 if c == '+' else -1
            elif c == '(': # push the result first, then sign;
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1 # reset the sign and res for the value in the parenthesis
            elif c == ')': # use elif because there may have space in input s
                res += sign * num # temporary res in this parenthesis
                num = 0
                res *= stack.pop() # sign before the left parenthesis
                res += stack.pop() # res calculated before the left parenthesis
        
        if num == 0:
            return res
        else:
            return res + sign * num
```

## 227 Basic Calculator II (String. Math, Stack) (Uber 8, Facebook 7, Amazon 5->10, Microsoft 4)
 
先把乘法先算出来，再考虑加减


```python
class Solution:
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        num = 0
        sign =  "+"
        stack = []
        
        for i in range(len(s)):
            if s[i].isdigit():
                num = num * 10 + int(s[i])
                
            if s[i] in "+-*/" or i == len(s) - 1:
                if sign == "+":
                    stack.append(num)
                elif sign == "-":
                    stack.append(-num)
                elif sign == "*":
                    stack.append(stack.pop()*num)
                elif sign == "/":
                    stack.append(int(stack.pop()/num))
                
                num = 0
                sign = s[i]
                  
        return sum(stack)
```


```python
s = '1-2*3'
obj = Solution()
obj.calculate(s)
```




    -1




```python
class Solution():
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        s = s.replace(' ', '')
        
        array = []
        l = 0
        r = 0
        while r < len(s):
            if s[r] in '+-*/':
                array.append(int(s[l:r]))
                array.append(s[r])
                r += 1
                l = r
            else:
                r += 1        
        array.append(int(s[l:]))
                        
        i = 0
        while i < len(array): 
        
            if array[i] == '*':
                array[i-1:i+2] = [array[i-1] * array[i+1]]
                i -= 1
                
            if array[i] == '/':
                array[i-1:i+2] = [array[i-1] // array[i+1]]
                i -= 1
            else:
                i += 1
                
        i = 0
        while i < len(array):
            if array[i] == '+':
                array[i-1:i+2] = [array[i-1] + array[i+1]]
                i -= 1
            if array[i] == '-':
                array[i-1:i+2] = [array[i-1] - array[i+1]]
                i -= 1
            else:
                i += 1
                    
        return array[-1]
        
```


```python
class Solution:
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        stack = []
        i = 0
        while i < len(s):
            if s[i].isdigit():
                tmp = 0
                while i < len(s) and s[i].isdigit():
                    tmp = tmp * 10 + int(s[i])
                    i += 1
                stack.append(tmp)
                # 如果栈中有乘除，先算出来
                while len(stack) > 1 and stack[-2] in {"*", "/"}:
                    stack.pop()
                    opt = stack.pop()
                    if opt == "*":
                        stack.append(stack.pop() * tmp)
                    else:
                        stack.append(stack.pop() // tmp)
            elif s[i] in { "*", "/", "+", "-"}:
                stack.append(s[i])
                i += 1
            else:
                 i += 1
        res = 0
        sign = 1
        for t in stack:
            if t == "+":
                sign = 1
            elif t == "-":
                sign = -1
            else:
                res += sign * t
        return res
```


```python
class Solution:
    def calculate(self, s: str) -> int:
        # 小trick
        s += "+0"
        stack = []
        num = 0
        # 记录前一个符号
        sign = "+"
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c in {"+", "-", "*", "/"}:
                #print(sign, num)
                if sign == "+":
                    stack.append(num)
                elif sign == "-":
                    stack.append(-num)
                elif sign == "*":
                    stack[-1] = stack[-1] * num
                elif sign == "/":
                    # 解决python的负数下取整
                    if stack[-1] < 0:
                        stack[-1] = -(-stack[-1] // num)
                    else:
                        stack[-1] = stack[-1] // num
                sign, num = c, 0
        return sum(stack)


```


```python
int(-3/2)
```

## 496. Next Great Element I (Amazon 7)


```python
class Solution(object):
    def nextGreaterElement(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        stack = []
        dic = {}
        for n in nums2:
            while stack and stack[-1] < n:
                dic[stack.pop()] = n
                
            stack.append(n)
        
        return [dic.get(x, -1) for x in nums1]
```

## 503. Next Great Element II (Amazon 6)


```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        # stack, res = [], [-1] * len(A)
        # for i in range(len(A)) * 2:
        #     while stack and (A[stack[-1]] < A[i]):
        #         res[stack.pop()] = A[i]
        #     stack.append(i)
        # return res
        
        stack = []
        res = [-1] * len(nums)
        for i in range(len(nums)):
            while stack and (nums[stack[-1]] < nums[i]): # stack top index对应在array中的数字小于我们当前的数字
                res[stack.pop()] = nums[i]
            stack.append(i)
            
        print(res)    
            
        for i in range(len(nums)):
            while stack and (nums[stack[-1]] < nums[i]): # stack top index对应在array中的数字小于我们当前的数字
                res[stack.pop()] = nums[i]
            stack.append(i)
        return res
```

## 739. Daily Temperatures (List. Stack) (Amazon Onsite 10)


```python
class Solution:
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        if not T:
            return []


        result = [0] * len(T)
        
        stack = []
        
        for i in range(len(T)):
            while stack and T[stack[-1]] < T[i]:
                j = stack.pop()
                
                result[j] = i-j
            
            stack.append(i)
        
        return result
```

## 402. Remove K Digits (String. Stack) (Amazon 5, Microsoft 3)  


```python
# O(N) 
# O(N)
class Solution:
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        if not k:
            return num

        stack = []
        for c in num:
            while k and stack and stack[-1] > c:
                stack.pop()
                k -= 1
                
            stack.append(c)
        
        while k:
            stack.pop()
            k -= 1  
            
        res = ''.join(stack).lstrip('0')
        return res if res else '0'
```

## 456. 132 Pattern (List. Stack) (Amazon 13)


```python
class Solution:
    def find132pattern(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        
        if nums == None or len(nums) < 3: 
            return False
        
        n = len(nums)
        stack = []
        third = float('-inf')
        
        for i in nums[::-1]:
            if i < third: 
                return True
            
            while stack and stack[-1] < i:
                third = stack.pop()
            stack.append(i)
            
        return False
```

## 768 Max Chunks To Make Sorted II (List. Stack) (Microsoft 2)


```python
class Solution:
    def maxChunksToSorted(self, arr: List[int]) -> int:
        stack = []
        
        for n in arr:
            if not stack or stack[-1] <= n:
                stack.append(n)
            else:
                tmp = stack[-1]
                while stack and stack[-1] > n:
                    stack.pop()
                stack.append(tmp)
        
        return len(stack)
```


```python
class Solution:
    def maxChunksToSorted(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        count = collections.Counter()
        counted = []
        for x in arr:
            count[x] += 1
            counted.append((x, count[x]))

        ans, cur = 0, None
        for X, Y in zip(counted, sorted(counted)):
            cur = max(cur, X)
            if cur == Y:
                ans += 1
        return ans
```

## 636. Exclusive Time of Functions (Facebook 13, Microsoft 5, Amazon 3)


```python
class Solution(object):
    def exclusiveTime(self, n, logs):
        """
        :type n: int
        :type logs: List[str]
        :rtype: List[int]
        """
        res = [0] * n
        stack = []
   
        
        for log in logs:
            idx, start, time = log.split(':')
            idx, time = int(idx), int(time)
            if start == 'start':
                if stack:
                    res[stack[-1]] += time - last_time                    
                stack.append(idx)
                last_time = time
            else:
                stack.pop()
                res[idx] += time - last_time + 1
                last_time = time + 1
        return res                 
```

### General

### String. O(N) O(1). (String) List. O(N) O(N)

## Max Possible Value (Microsoft OA)


```python
def solution(n): 
    string = list(str(n))
    
    if string[0] == '-':
        for i in range(1, len(string)+1):
            if i == len(string):
                string.insert(i, '5')
                break
            
            if '5' < string[i]:
                string.insert(i, '5')
                break
        
    else:
        for i in range(len(string)+1):   
            if i == len(string):
                string.insert(i, '5')
                break
                
            
            if '5' > string[i]:
                string.insert(i, '5')
                break
            
    return int(''.join(string))
            
a = 268
b = 670
c = 0
d = -999
e = 945
f = -945
g = -123 # -123 returns -5123 while it should return -1235
        
solution(-123)
```




    -1235




```python
n = -9
list(str(n))
```




    ['-', '9']




```python
# O(k), k = number of digits
def solution(num):
    if num < 0:
        return neg(num)
    else:
        return pos(num)

def pos(num):
    n = len(str(num))
    res = 0
    
    while num >= 0:
        val = num//10**(n-1)
        num %= 10**(n-1)
        if val < 5:
            res += (5*10**n)+val*(10**(n-1))+num
            return res
        else:
            res += val*10**n
            n -= 1
            
def neg(num):
    num = abs(num)
    n = len(str(num))
    res = 0
    
    while num >= 0:
        val = num//10**(n-1)
        num %= 10**(n-1)
        if val > 5:
            res += (5*10**n)+val*(10**(n-1))+num
            return -res
        else:
            res += val*10**n
            n -= 1
print(solution(-99))
```


```python
def maxPossibleValue(N):
    s = str(N)
    if N >= 0:
        i = 0
        for d in s:
            if d >= '5':
                i += 1
            else:
                break
        ans = int(s[:i] + '5' + s[i:])
    else:
        i, s = 0, s[1:]
        for d in s:
            if d <= '5':
                i += 1
            else:
                break
        ans = -int(s[:i] + '5' + s[i:])
    return ans
            

N = 268
print(maxPossibleValue(N))

N = 670
print(maxPossibleValue(N))

N = 0
print(maxPossibleValue(N))

N = -999
print(maxPossibleValue(N))
```


```python
def insert_five(num):
    num_str = str(num) if num >= 0 else str(-num)
    i = 0

    if num >= 0:
        while i < len(num_str) and num_str[i] >= '5':
            i += 1
    else:
        while i < len(num_str) and num_str[i] <= '5':
            i += 1

    max_string = (num_str[:i] + '5' + num_str[i:])

    return max_string if num >= 0 else '-' + max_string
```

## 1268. Search Suggestions System (Amazon OA 29)


```python
class Solution:
    def suggestedProducts(self, products, searchWord):
        """
        :type products: List[str]
        :type searchWord: str
        :rtype: List[List[str]]
        """
        ans, res = [], []
        products.sort()
        
        for i in range(1, len(searchWord)+1):            
            for j in range(len(products)):
                if len(ans) == 3:
                    break
                    
                if searchWord[:i] == products[j][:i]:
                    ans.append(''.join(products[j]))
                
            res.append(ans)
            ans = []
            
        return res
```


```python
class Solution:
    def suggestedProducts(self, products, searchWord):
        """
        :type products: List[str]
        :type searchWord: str
        :rtype: List[List[str]]
        """
        ans, res = [], []
        products.sort()
        
        for i in range(1, len(searchWord)+1):
            to_search = searchWord[:i]
            
            j = 0
            while j < len(products):
                if len(ans) == 3:
                        break
                
                if to_search == products[j][:i]:
                    ans.append(''.join(products[j]))
                    
                j += 1
                
            res.append(ans)
            ans = []
            
        return res
```


```python
# Buggy with large input 
class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        
                    
        dic = {}
        
        for word in products:
            t = dic
            for c in word:
                if c not in t:
                    t[c] = {}
                    
                t = t[c]
                
            t['#'] = {}
            
        # print(dic)
        def dfs(start, t, word):
            if start == '#':
                tmp.append(word)
                return

            # print(t)
            # print(start)
            t = t.get(start)

            for nxt in t:
                dfs(nxt, t, word + start)   
            
        res = []
        
        for i in range(len(searchWord)):
            tmp = []
            word = ''
            t = dic
            for c in searchWord[:i]:
                if c not in t:
                    break
                
                word += c
                t = t[c]
            
            if searchWord[i] in t:
                start = searchWord[i]
                dfs(start, t, word)

            tmp.sort()
            if len(tmp) >= 3:
                tmp = tmp[:3]

            res.append(tmp)
            
        return res
```

## 482. License Key Formatting (String. List) (Google OA 16)


```python
class Solution:
    def licenseKeyFormatting(self, S, K):
        """
        :type S: str
        :type K: int
        :rtype: str
        """
        S = S.replace("-", "").upper()[::-1]
        return '-'.join(S[i:i+K] for i in range(0, len(S), K))[::-1]
```


```python
'-'.join(['w9e3','23f5'])[::-1]
```

## Find N Unique Integers Sum up to Zero (Microsoft OA)


```python
class Solution:
    def sumZero(self, n):
        array = list(range(-(n // 2), (n // 2) + 1))

        if n % 2 == 0:
            array.pop(n // 2)
        return array
    
obj = Solution()
obj.sumZero(4)
```




    [-2, -1, 1, 2]



## Day of Week (Microsoft OA)


```python
def solution(s, n):
    array = ["Mon", "Tue", "Web", "Thu", "Fri", "Sat", "Sun"]
    index = array.index(s)
    
    if n >= 7:
        n %= 7
    
    if index + n >= 7:
        return array[index + n - 7]
    
    else:
        return array[index + n]
    
solution("Sat", 23)
```




    'Mon'



## Max Inserts to Obtain String Without 3 Consecutive 'a' (Microsoft OA)


```python
def solution(string):
    if not len(string):
        return 2
    
#     result = 0    
    if string[0] == "a": 
        res = 0
        a = 1
        
    else:
        res = 2
        a = 0
    
    for i in range(1, len(string) + 1):
        if i == len(string):
            res += 2 - a
            break
        
        if string[i] == "a":
            a += 1
        else:
            res += 2 - a
            a = 0
            
        if a >= 3:
            return -1
        
    return res


a = "aabab" #3
b = "dog" #8
c = "aa" #0
d = "baaaa" #-1
solution(d)
```




    -1




```python
def consecutive(string):
    count = 0
    prea = False
    for ss in string:
        if ss == "a":
            if prea == False:
                count += 1
                prea = True
                
        if ss != "a":
            if prea == False:
                count += 2
            else:
                prea = True
                
    if string[-1] != "a":
        count+= 2
        
    return count

a = "aabab"
b = "dog"
c = "aa"
d = "baaaa"
print(consecutive(d))
```

    3


## Fair Indexes (Microsoft OA)


```python
def solution(A, B):
    res = 0
    
    sumA = sum(A)
    sumB = sum(B)
    
    tmpA = 0
    tmpB = 0
    
    for i in range(len(A)-1):
        tmpA += A[i]
        tmpB += B[i]
        
        if sumA == 2 * tmpA and sumB == 2 * tmpB and tmpA == tmpB:
            res += 1
            
    return res

A1 = [4,-1,0,3]; B1 = [-2, 5, 0 ,3] #2
A2 = [2,-2,-3,3]; B2 = [0,0,4,-4] #1
A3 = [4,-1,0,3]; B3 = [-2,6,0,4] #0
A4 = [3,2,6]; B4 = [4,1,6] #0
A5 = [1,4,2,-2,5]; B5 = [7,-2,-2,2,5] #2

solution(A4, B4)
```




    0




```python
def solution(A, B):
    res = 0
    sum_leftA = 0
    sum_leftB = 0
    sum_rightA = sum(A)
    sum_rightB = sum(B)
    
    print(sum_rightA)
    print(sum_rightB)
    
#     if sum_rightA == sum_rightB:
#         res += 1
        
    for i in range(1, len(A)):
        sum_leftA += A[i - 1]
        sum_leftB += B[i - 1]
        
        print(sum_leftA, sum_leftB)
        
        sum_rightA -= A[i-1]
        sum_rightB -= B[i-1]
        
        print(sum_rightA, sum_rightB)
        
        if sum_leftA == sum_leftB == sum_rightA == sum_rightB:
            res += 1
            
#     sum_leftA += A[-2]
#     sum_leftB += B[-2]
    
#     if sum_leftA == sum_leftB:
#         res += 1
            
    return res

A1 = [4,-1,0,3]; B1 = [-2, 5, 0 ,3] #2
A2 = [2,-2,-3,3]; B2 = [0,0,4,-4] #1
A3 = [4,-1,0,3]; B3 = [-2,6,0,4] #0
A4 = [3,2,6]; B4 = [4,1,6] #0
A5 = [1,4,2,-2,5]; B5 = [7,-2,-2,2,5] #2

solution(A5, B5)
```

    10
    10
    1 7
    9 3
    5 5
    5 5
    7 3
    3 7
    5 5
    5 5





    2



## String Without 3 Identical Consecutive Letters (Microsoft OA)


```python
from itertools import groupby
def stringWithout3Identical(S):
    """
    input: str
    output: str
    """
    
    ans = ''
    for c, g in groupby(S):
        length = len(list(g))
        
        if length > 2:
            ans += c * 2
            
        else:
            ans += c * length

    return ans
    
S = 'eedaaad'
# S = ['e', 'e', 'd', 'a', 'a', 'a', 'd']
stringWithout3Identical(S)

S = 'xxxtxxx'
stringWithout3Identical(S)

S = 'uuuuxaaaaxuuu'
stringWithout3Identical(S)
```




    'eedaad'






    'xxtxx'






    'uuxaaxuu'



## Lexicographically Smallest String (Microsoft OA)


```python
def lexiSmallestString(string_input):
    # loop through one letter after another
    for index, letter in enumerate(string_input[:-1]):
        if letter > string_input[index+1]:
            # rebuild string without z if letter is greater than next
            result_string = string_input[:index] + string_input[index+1:]
            print ("letter", letter)
            print ("result string", result_string)
            return (result_string)
        else:
            # else remove last character
            result_string = string_input[:index+1]
            print ("result string", result_string)
            
lexiSmallestString("abczd")
lexiSmallestString("abcde")
```

    result string a
    result string ab
    result string abc
    letter z
    result string abcd
    result string a
    result string ab
    result string abc
    result string abcd



```python
def solution(s):
    for i in range(len(s)-1):
        if s[i] > s[i+1]:
            s = s.replace(s[i], '')
            
            break
    
    return s

a = 'abczd'
solution(a)
```




    'abcd'




```python
s = 'abc'
s.replace('c', '')
s
```




    'abc'




```python
def containsSubstring(src, key):
    res = []
    for word in src:
        if key in word:
            res.append(word)
    return res

src = {"minecraftgame", "intelligent", "innercrafttalent", "knife", "scissor", "stonecrafter"}
key = "craft"
containsSubstring(src, key)
```

## Light Buld Switcher (Microsoft OA)


```python
public int getShiningCounts(int[] arr) {
	int ans = 0, sum = 0, target = 0;
		
	for(int i = 1; i<= arr.length; i++) {
		sum += arr[i-1];
		target += i ; //Sum from 1 to i
		if(sum == target) ans++;
	}
		
	return ans;
}
```


```python
def solution(s):
    ans = 0
    sums = 0
    target = 0
    for i in range(1, len(s)+1):
        sums += s[i-1]
        target += i
        
        if sums == target:
            ans += 1
            
    return ans

a = [2, 1, 3, 5, 4]
solution(a)
```




    3



## Second Max (Google Phone)


```python
def secondMax(nums):
    def compare(a,b):
        return max(a,b)
    
    first = compare(nums[0], nums[1])
    if first == nums[0]:
        second = nums[1]
    else:
        second = nums[0]
            
    for i in range(2, len(nums)):
        if compare(first, nums[i]) > first:
            second = first
            first = nums[i]
                
        elif compare(first, nums[i]) > nums[i]:
            if compare(second, nums[i]) > second: 
                second = nums[i]
                
    return second
nums = [10, 8, 15, 12, 6, 20, 20, 1]
secondMax(nums)
```




    15




```python
(10, 8)
(10, 15) - (15, 10)
(15, 12)
(15, 20) - (20, 15)
```

## 163. Missing Ranges (List) (Google 6 Phone) 
O(N)  
O(1)


```python
class Solution:
    def findMissingRanges(self, nums, lower, upper):
        """
        :type nums: List[int]
        :type lower: int
        :type upper: int
        :rtype: List[str]
        """
        
        result = []
        nums.insert(0, lower -1)
        pre = nums[0]
        nums.append(upper + 1)
        
        for n in nums:
            if n - pre == 2:
                result.append(str(n - 1))
#                 print('result1=', result)
            elif n - pre > 2:
                result.append(str(pre + 1) + "->" + str(n - 1))
#                 print('result2=', result)
            pre = n
#             print('pre=', pre)
#             print()
        return result
```


```python
s = Solution()
nums = [0, 1, 3, 50, 75]
s.findMissingRanges(nums, 0, 99)
```

## 796. Rotate String (Apple 2)


```python
class Solution(object):
    def rotateString(self, A, B):
        """
        :type A: str
        :type B: str
        :rtype: bool
        """
        return len(A) == len(B) and B in A + A
```

## 724. Find Pivot Index (Facebook 3, Google 2, Amazon 2, Microsoft 2, Apple?)


```python
class Solution(object):
    def pivotIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        S = sum(nums)
        leftsum = 0
        for i, x in enumerate(nums):
            if leftsum == (S - leftsum - x):
                return i
            leftsum += x
        return -1
```

## 134. Gas Station (List) (Amazon 6, Microsoft 5)


```python
class Solution:
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """        
        if sum(gas) - sum(cost) < 0:
            return -1
        
        tank = 0
        res = 0
        for i in range(len(gas)):
            tank += gas[i] - cost[i]
            if tank < 0: 
                tank = 0
                res = i + 1
        return res 
```

## 412. Fizz Buzz (Microsoft 3, Amazon 2, Apple)

O(N)


```python
class Solution(object):
    def fizzBuzz(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        
        
        res = []
        for i in range(1, n+1):
            if not i % 3 and not i % 5:
                res.append('FizzBuzz')    
                
            elif not i % 3:
                res.append('Fizz')
                
            elif not i % 5:
                res.append('Buzz')
                
            else:
                res.append(str(i))
                
        return res
            
```

## 859. Buddy Strings (Microsoft Onsite) 


```python
class Solution:
    def buddyStrings(self, A: str, B: str) -> bool:
        if len(A) != len(B): 
            return False
        
        # 兩個字串相等, 且字串中有重複的字元(swap後字串不變)
        if A == B and len(set(A)) < len(A): 
            return True
        
        # ["abcd", "badc"], #false
        # dif = [('a', 'b'), ('b', 'a'), ('c', 'd'), ('d', 'c')]
        # 唯一一組, 且swap後吻合 -> True
        dif = [(a, b) for a, b in zip(A, B) if a != b]
        #print(dif)
        return len(dif) == 2 and dif[0] == dif[1][::-1]
```

## 836. Rectangle Overlap (Microsoft 5, Amazon 3)


```python
class Solution:
    def isRectangleOverlap(self, rec1, rec2):
        """
        :type rec1: List[int]
        :type rec2: List[int]
        :rtype: bool
        """
        
        x1,y1,x2,y2 = 0,1,2,3
        
        return ( 
            rec1[x1] < rec2[x2] and # rec1 is to left of rec2
            rec1[y1] < rec2[y2] and # rec1 is above rec2
            rec2[x1] < rec1[x2] and # rec2 is to the left of rec1
            rec2[y1] < rec1[y2]     # rec2 is above rec1
        )
```

## 165. Compare Version Numbers (String. List) (Amazon 16, Microsoft 4)  


```python
# O(N)  
# O(N)
class Solution:
    def compareVersion(self, version1, version2):
        """
        :type version1: str
        :type version2: str
        :rtype: int
        """
        versions1 = [int(v) for v in version1.split(".")]
#             print('versions1 =', versions1)
        versions2 = [int(v) for v in version2.split(".")]
#             print('versions2 =', versions2)

        length1 = len(versions1)
        length2 = len(versions2)
        if length1 < length2:
            for i in range(length2 - length1):
                versions1.append(0)
                
        else:
            for i in range(length1 - length2):
                versions2.append(0)
                        
        for i in range(len(versions1)):
            v1 = versions1[i] 
            v2 = versions2[i] 

            if v1 > v2:
                return 1
            elif v1 < v2:
                return -1

        return 0
```


```python
s = Solution()
s.compareVersion('0.1', '1.1')
```

## 722. Remove Comments (List[str]) (Microsoft 5)


```python
class Solution(object):
    def removeComments(self, source):
        """
        :type source: List[str]
        :rtype: List[str]
        """
        in_block = False
        ans = []
        for line in source:
            i = 0
            if not in_block:
                newline = []
            while i < len(line):
                if line[i:i+2] == '//' and not in_block:
                    break
                
                elif line[i:i+2] == '/*' and not in_block:
                    in_block = True
                    i += 2
                elif line[i:i+2] == '*/' and in_block:
                    in_block = False
                    i += 2
                
                elif in_block:             
                    i += 1
                else:
                    newline.append(line[i])
                    i += 1
                
            if newline and not in_block:
                ans.append("".join(newline))

        return ans
```


```python
s = ' // jsjjs  '
s.strip()
```




    '// jsjjs'



## 680. Valid Palindrome II (Facebook 67, Microsoft 4)


```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def is_pali_range(i, j):
            return s[i:j+1] == s[i:j+1][::-1]
        
        for i in range(len(s) // 2):
            if s[i] != s[~i]:
                j = len(s) - 1 - i
                return is_pali_range(i+1, j) or is_pali_range(i, j-1)
            

        return True
```


```python
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """

        def is_pali_range(i, j):
            while i < j:
                if s[i] != s[j]:
                    return False
                
                i += 1
                j -= 1
                
            return True
#             for k in range(i, j):
#                 if s[k] != s[j-k+i]:
#                     return False
                        
#             return True
        
        for i in range(len(s) // 2):
            if s[i] != s[~i]:
                j = len(s) - 1 - i
                return is_pali_range(i+1, j) or is_pali_range(i, j-1)
            
        return True
```


```python
~2
```




    -3




```python
array = [1,2,3]
for i in range(len(array)-1, -1, -1):
    print(i)
```

    2
    1
    0


## 1249. Minimum Remove to Make Valid Parentheses (Facebook 99, Amazon 5, Microsoft 2)


```python
class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str
        """
        counter = 0
        li = list(s)

        for i, char in enumerate(li):
            if char == '(': 
                counter += 1
            elif char == ')':
                if counter > 0: 
                    counter -= 1
                else: li[i] = '#'

        for i in range(len(li))[::-1]:
            if counter == 0: 
                break
            if li[i] == '(':
                li[i] = '#'
                counter -= 1

        return ''.join(li).replace('#', '')
```


```python
for n in map(int, '200'):
    print(n)

```

    2
    0
    0


## 161. One Edit Distance (Amazon 3)


```python
class Solution:
    def isOneEditDistance(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if s == t:
            return False 
        
        if abs(len(s) - len(t)) > 1:
            return False
        
        for i in range(min(len(s), len(t))):
            if s[i] != t[i]:
                if len(s) == len(t):
                    s = s[:i] + t[i] + s[i+1:] # replacement
                    
                elif len(s) < len(t):
                    s = s[:i] + t[i] + s[i:]   # insertion
                    
                else:
                    s = s[:i] + s[i+1:]        # deletion
                    
                break
                
        # 后面两个是为了 checking edge case for s ="a", t = ""
        return s == t or s == t[:-1] or s[:-1] == t 
```

## 14. Longest Common Prefix (Amazon 6, Google 5, Microsoft 3)


```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if not strs:
            return ''
        for i in range(len(strs[0])):
            for str in strs:
                if i >= len(str) or strs[0][i] != str[i]:
                    return strs[0][:i]
        return strs[0]
```

## 443. String Compression (String List) (Microsoft Onsite 6)
O(N)  
O(1)


```python
class Solution:
    def compress(self, strs):
        """
        :type chars: List[str]
        :rtype: int
        """
        
        count = 1

        for i in range(len(strs)-1, -1, -1):
            if i > 0 and strs[i] == strs[i-1]:
                count += 1
                
            else:
                end = i + count
                if count == 1:
                    continue
                else:
                    strs[i: end] = [strs[i]] + list(str(count))
                 
                count = 1

        return len(strs)
```


```python
s = '12'
for c in s:
    print(c)
```


```python
class Solution:
    def compress(self, chars):
        """
        List[stri]
        int
        """
        
        if not chars:
            return []
        
        if len(chars) == 1:
            return len(chars)
        
        l = 0
        r = 0
        
        count = 0
        while r < len(chars):                               
            if chars[l] == chars[r]:
                r += 1
                count += 1
                
                if r == len(chars) and count > 1:
                    replace = list(str(count))
                    chars[l + 1:] = replace
   
            else:
                if count == 1:
                    l = r              
                    count = 0
                    
                else:
                    replace = list(str(count))                    
                    chars[l + 1 : r] = replace
                    r = l + len(replace) + 1
                    l = r
                    count = 0

        return len(chars)
```


```python
l = 0
r = 3
s = ['a', 'a', 'a', 'b']

s[l+1:r] = '2'

r = l + 2
l = r

l 
r

s[1:1]
```




    2






    2






    []




```python
class Solution:
    def compress(self, chars):
        if len(chars) <= 1:
            return len(chars)
        
#         count = 1
#         start = 0
#         for i in range(len(chars)-1):
#             if chars[i] == chars[i+1]:
#                 count += 1
                
#             if chars[i] != chars[i+1]:
#                 chars[start+1: i+1] = [str(count)]
#                 count = 1
#                 start = i + 1
        
#             if i == len(chars)-2:
#                 chars[start+1:] = [str(count)]
                
#         return len(chars)
        
        count = 0
        l = 0
        r = 0
        while r <= len(chars) - 1:
            if chars[l] == chars[r]:
                count += 1
                r += 1
                print('on', l, r)
                if r >= len(chars):
                    tmp = []
                    for c in str(count):
                        tmp.append(c)
                        
                    print('tmp2', tmp)
                    
                    chars[l+1:r] = tmp
                    
            else:
                if count == 1:
                    count = 0
                    l = r
                    print('one')
                
                else:
                    tmp = []
                    for c in str(count):
                        tmp.append(c)
                    
                    print('tmp1', tmp)
                    chars[l+1:r] = tmp 
                    count = 0
                    l = r
                    print('l', l)
                    print('r', r)
                        
        return chars
```


```python
s = Solution()
s.compress(["a","a","b","b","c","c","c"])
```

## 68. Text Justification (Google 8, Microsoft 4, Amazon 3) (Hard)


```python
class Solution:
    def fullJustify(self, words, maxWidth):
        """
        :type words: List[str]
        :type maxWidth: int
        :rtype: List[str]
        """
        
        n = len(words)
        if n == 0:
            return []
        
        res = []
        cur, num_letters = [], 0
        for w in words:
            if len(cur) + len(w) + num_letters > maxWidth:
                if len(cur) == 1:
                    res.append(cur[0] + ' '*(maxWidth - num_letters))
                else:
                    num_space = maxWidth - num_letters
                    gap, remain_gap = divmod(num_space, len(cur) - 1)
                    for i in range(remain_gap):
                        cur[i] += ' '
                    res.append((' '*gap).join(cur))
                cur, num_letters = [], 0
                
            cur += [w]
            num_letters += len(w)
            
        res.append(' '.join(cur) + ' '*(maxWidth - num_letters - len(cur) + 1))
        return res 
```

## 483. Guess the Word (Google 23)


```python
import random
class Solution:
    def findSecretWord(self, wordlist, master):
        """
        :type wordlist: List[Str]
        :type master: Master
        :rtype: None
        """
        
        new_wordlist = wordlist
        while True:
            test_word = random.choice(new_wordlist)
            matches = master.guess(test_word)

            if matches == 6:
                return

            wordlist = new_wordlist
            new_wordlist = []
            for word in wordlist:
                dist = 0
                for i in range(6):
                    if word[i] == test_word[i]:
                        dist += 1

                if matches == dist:
                    new_wordlist.append(word)
```

## 158. Read N Characters Given Read4 II - Call multiple times (String List) (Facebook 15, Google 6) (Hard)


```python
class Solution:
    head, tail, buffer = 0, 0, [''] * 4 ## 定义全局变量

    def read(self, buf, n):
        """
        :type buf: Destination buffer (List[str])
        :type n: Maximum number of characters to read (int)
        :rtype: The number of characters read (int)
        """
        i = 0
        while i < n:
            if self.head == self.tail: ## read4 的缓存区为空的时候
                self.head = 0
                self.tail = read4(self.buffer) ## 开始进缓存区
                if self.tail == 0:
                    break
            while i < n and self.head < self.tail:
                buf[i] = self.buffer[self.head] ## 读出缓存区的变量
                i += 1
                self.head += 1
        return i
```


```python
buf = ['a','b','c']
buf[0] = ''
buf
```

## 169. Majority Element (Amazon 6, Google 3)


```python
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        count = 0
        for num in nums:
            if count == 0:
                majority = num
                
            if num == majority:
                count += 1
            else:
                count -= 1
        return majority
```

## 229. Majority Element II (List) (Microsoft 2, Amazon 2)


```python
class Solution:
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        if not nums:
            return []
        
        count1 = 0
        count2 = 0
        candidate1 = 0
        candidate2 = 1
        for n in nums:
            if n == candidate1:
                count1 += 1
#                 print('case1 count1=', count1)
            elif n == candidate2:
                count2 += 1
#                 print('case2 count2=', count2)
            elif count1 == 0:
                candidate1 = n 
                count1 = 1
#                 print('case3 candidate1=', candidate1)
#                 print('case3 count1=', count1)
            elif count2 == 0:
                candidate2 = n 
                count2 = 1
#                 print('case4 candidate2=', candidate2)
#                 print('case4 count2=', count2)
            else:
                count1 -= 1
                count2 -= 1
#                 print('x')
#         print(candidate1,candidate2)
        return [n for n in (candidate1, candidate2)
                        if nums.count(n) > len(nums) // 3]
```


```python
s = Solution()
nums = [1,1,1,3,3,2,2,2]
s.majorityElement(nums)
```

## 277. Find the Celebrity (Microsoft Onsite 3, Facebbook 5, Amazon 5)


```python
# O(N) 
# O(1)
class Solution:
    def findCelebrity(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        celebrity = 0
        for i in range(1, n):
            if knows(celebrity, i):
				#说明当前的这个celebrity肯定不是名人，因为他认识别的人
                celebrity = i
		# 到这里的 celebrity，必定不认识 [celebrity + 1, n - 1]的所有人
        for i in range(celebrity):
            if knows(celebrity, i): # 为了确保celebrity 不认识 [0, celebrity - 1]
                return -1
        
        for i in range(n):
            if not knows(i, celebrity): # 为了确保 每个人都认识 celebrity
                return -1
        return celebrity
```


```python
class Solution():
    def findCelebrity(self, n):
        """
        :type n: int
        :rtype: int
        """
        res = 0
        
        # if celebrity > candidate, candidate must change to the celebrity, cause (knows(candidate, celebrity) == True)
        # if candidate == celebrity: candidate won't change, cause celebrity knows nobody.
        # after the loop, candidate is the only one can be the celebrity
        for i in range(1, n):
            if knows(res, i):
                res = i
                
        # check people < candidate
        for i in range(res):
            if knows(res, i) or not(knows(i, res)):
                return -1
        
        # check if people > candidate are all knows the candidate
        for i in range(res+1, n):
            if not knows(i, res):
                return -1
            
        return res
```

### bisect

## 315. Count of Smaller Numbers After Self (bisect) (List) (Google 11, Amazon 6->3)

https://docs.python.org/3.0/library/bisect.html

O(N^2)


```python
import bisect
class Solution:
    def countSmaller(self, nums):
        counts = []
        done = []
        for num in nums[::-1]:
            counts.append(bisect.bisect_left(done, num))
#             print('counts=', counts)
            bisect.insort(done, num)
#             print('done=', done)
        return counts[::-1]
```


```python
s = Solution()
nums = [5,2,6,1]
s.countSmaller(nums)
```




    [2, 1, 1, 0]




```python
import bisect

data = [5,1,5]
bisect.bisect(data, 5)
```

## 480. Sliding Window Median (bisect) (Facebook 6, Amazon 6, Google 2)


```python
import bisect
class Solution:
    def medianSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[float]
        """
        if not nums:
            return []
        
        window = sorted(nums[:k])
        res = []
        if k % 2 == 0:
            res.append((window[k // 2] + window[k // 2 - 1]) / 2)
        else:
            res.append(window[k // 2])
        
        for i in range(k, len(nums)):
            bisect.insort(window, nums[i])
            index = bisect.bisect_left(window, nums[i - k])
            window.pop(index)
            if k % 2 == 0:
                res.append((window[k // 2] + window[k // 2 - 1]) / 2)
            else:
                res.append(window[k // 2])
        return res
```

## 239. Sliding Window Maximum (List, Queue) (Amazon Onsite 21, Facebook 6, Google 5, Microsoft Onsite 1, 5)



```python
class Solution():
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        if not nums:
            return []

        if k == 1:
            return nums
        
        res = [max(nums[:k])]
        
        for i in range(k, len(nums)):
            if nums[i] >= res[-1]:
                res.append(nums[i])
            else:
                if nums[i - k] < res[-1]:
                    res.append(res[-1])
                    
                elif nums[i - k] == res[-1]:
                    res.append(max(nums[i-k+1:i+1]))
                    
        return res
```

use heap to get max?


```python
# O(N)  
# O(N)
class Solution:
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        if not nums:
            return []

        queue = []
        res = []

        for i in range(k):
            while queue:
                if nums[i] > nums[queue[-1]]:
                    queue.pop()
                else:
                    break
            queue.append(i)

        for i in range(k, len(nums)):
            res.append(nums[queue[0]])
            if queue[0] < i - k + 1:
                queue.pop(0)

            while queue:
                if nums[i] > nums[queue[-1]]:
                    queue.pop()
                else:
                    break
            queue.append(i)

        res.append(nums[queue[0]])
        return res
```


```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """       
        # base cases
        n = len(nums)
        if n * k == 0:
            return []
        if k == 1:
            return nums
        
        def clean_deque(i):
            # remove indexes of elements not from sliding window
            if deq and deq[0] == i - k:
                deq.pop(0)
                
            # remove from deq indexes of all elements 
            # which are smaller than current element nums[i]
            while deq and nums[i] > nums[deq[-1]]:
                deq.pop()
        
        # init deque and output
        deq = []
        max_idx = 0
        for i in range(k):
            clean_deque(i)
            deq.append(i)
            # compute max in nums[:k]
            if nums[i] > nums[max_idx]:
                max_idx = i
                
        output = [nums[max_idx]]
        
        # build output
        for i in range(k, n):
            clean_deque(i)          
            deq.append(i)
            output.append(nums[deq[0]])
        return output
```

### (String) Matrix. O(N^2) O(N^2)

## 463. Island Perimeter (Facebook 11, Google 2, Apple?)


```python
class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rows = len(grid)
        cols = len(grid[0])
        
        result = 0
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    tmp = 4
                    for i, j in directions:
                        next_i = r + i
                        next_j = c + j
                        
                        if 0 <= next_i < rows and 0 <= next_j < cols:
                            if grid[next_i][next_j] == 1:
                                tmp -= 1
                    print(tmp)
                    result += tmp
                    
        return result
```


```python
class Solution(object):
    def islandPerimeter(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rows = len(grid)
        cols = len(grid[0])
        
        result = 0
        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    if r == 0:
                        up = 0
                    else:
                        up = grid[r-1][c]
                    if c == 0:
                        left = 0
                    else:
                        left = grid[r][c-1]
                    if r == rows-1:
                        down = 0
                    else:
                        down = grid[r+1][c]
                    if c == cols-1:
                        right = 0
                    else:
                        right = grid[r][c+1]
                        
                    result += 4-(up+left+right+down)
                
        return result
                
```

## 289 Game of Life (Matrix) (Amazon 10, Google 2 Phone)


```python
# O(n^2)
# O(1)
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        # Neighbors array to find 8 neighboring cells for a given cell
        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        m = len(board)
        n = len(board[0])

        # Iterate through board cell by cell.
        for i in range(m):
            for j in range(n):

                # For each cell count the number of live neighbors.
                live_neighbors = 0
                for di, dj in neighbors:

                    # row and column of the neighboring cell
                    r = (i + di)
                    c = (j + dj)

                    # Check the validity of the neighboring cell and if it was originally a live cell.
                    if 0 <= r < m and 0 <= c < n and abs(board[r][c]) == 1:
                        live_neighbors += 1

                # Rule 1 or Rule 3
                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 signifies the cell is now dead but originally was live.
                    board[i][j] = -1
                # Rule 4
                if board[i][j] == 0 and live_neighbors == 3:
                    # 2 signifies the cell is now live but was originally dead.
                    board[i][j] = 2

        # Get the final representation for the newly updated board.
        for i in range(m):
            for j in range(n):
                if board[i][j] > 0:
                    board[i][j] = 1
                else:
                    board[i][j] = 0
```


```python
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        # Neighbors array to find 8 neighboring cells for a given cell
        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        dp = []
        for n in board:
            dp.append(n.copy())
        
        rows = len(board)
        cols = len(board[0])

        # Iterate through board cell by cell.
        for row in range(rows):
            for col in range(cols):

                # For each cell count the number of live neighbors.
                live_neighbors = 0
                for neighbor in neighbors:

                    # row and column of the neighboring cell
                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # Check the validity of the neighboring cell and if it was originally a live cell.
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and dp[r][c] == 1:
                        live_neighbors += 1

                # Rule 1 or Rule 3
                if dp[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 signifies the cell is now dead but originally was live.
                    board[row][col] = 0
                # Rule 4
                if dp[row][col] == 0 and live_neighbors == 3:
                    # 2 signifies the cell is now live but was originally dead.
                    board[row][col] = 1
```


```python
class Solution:
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        
        for i in range(len(board)):
            for j in range(len(board[i])):
                live=0
                try:
                    l_1=board[i-1][j-1]
                    if l_1>0 and i>0 and j>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_2=board[i-1][j]
                    if l_2>0 and i>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_3=board[i-1][j+1]
                    if l_3>0 and i>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_4=board[i][j-1]
                    if l_4>0 and j>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_5=board[i][j+1]
                    if l_5>0:
                        live+=1
                except IndexError:
                    pass
                try:
                    l_6=board[i+1][j-1]
                    if l_6>0 and j>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_7=board[i+1][j]
                    if l_7>0:
                        live+=1
                except IndexError:
                    pass
                
                try:
                    l_8=board[i+1][j+1]
                    if l_8>0:
                        live+=1
                except IndexError:
                    pass  
                
                if board[i][j]>0:
                    if live<2 or live>3:
                        board[i][j]=2
                    elif live==2 or live==3:
                        board[i][j]=1
                else:
                    if live==3:
                        board[i][j]=-1
                        
        for i in range(len(board)):
            for j in range(len(board[i])):
                if board[i][j]==2:
                    board[i][j]=0
                if board[i][j]==-1:
                    board[i][j]=1

```

## 36. Valid Sudoku (String Matrix) (Uber 7, Microsoft 7, Amazon 5->9, Apple 7, Google 3)

O(m*n)  
O(1)


```python
class Solution:
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        def is_row_valid(board):
            for row in board:
                if not is_unit_valid(row):
                    return False
            return True

        def is_col_valid(board):
            for col in zip(*board):
                if not is_unit_valid(col):
                    return False
            return True

        def is_square_valid(board):
            for i in (0, 3, 6):
                for j in (0, 3, 6):
                    square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]
    #                 print(square)
    #                 print()
                    if not is_unit_valid(square):
                        return False
            return True

        def is_unit_valid(unit):
            unit = [i for i in unit if i != '.']
            return len(set(unit)) == len(unit)

        
        return (is_row_valid(board) and
                is_col_valid(board) and
                is_square_valid(board))
```


```python
board = [
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
s = Solution()
s.isValidSudoku(board)
```


```python
class Solution:
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        # init data
        rows = [{} for i in range(9)]
        columns = [{} for i in range(9)]
        boxes = [{} for i in range(9)]

        # validate a board
        for i in range(9):
            for j in range(9):
                num = board[i][j]
                if num != '.':
                    num = int(num)
                    box_index = (i // 3 ) * 3 + j // 3
                    
                    # keep the current cell value
                    rows[i][num] = rows[i].get(num, 0) + 1
                    columns[j][num] = columns[j].get(num, 0) + 1
                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1
                    
                    # check if this value has been already seen before
                    if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1:
                        return False         
        return True
```


```python
matrix = [['a'] * 4 for j in range(3)]
matrix
```


```python
[[1] for i in range(9) for i in range(9)]
```

## 794. Valid Tic-Tac-Toe State	(String Matrix) (Microsoft Onsite 4)
O(m*n)  
O(1)  

To find the validity of a given board, we could first think about the cases where the board is invalid

Since X starts first, x_count >= o_count. So if o_count > x_count, we can return False
Since the players take turns, we could also return False if x_count-o_count>1
After the corner cases, this is the algorithm used:

If player O has a winning condition, also check the following:
a) If player X also has a winning condition, return False
b) If x_count != o_count , return False (Since player O always plays second, it has to meet this condition always)
If player X has a winning condition, check the following:
a) If x_count != o_count + 1, return False (Since player X plays the first move, if player X wins, the player X's count would be 1 more than player O)


```python
class Solution:    
    def validTicTacToe(self, board):
        """
        :type board: List[str]
        :rtype: bool
        """    
        X, O = 0, 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == "X":
                    X += 1
                elif  board[i][j] == "O":
                    O += 1
        
        def win(board, player):
            """
            Check if the given player has a win position.
            Return True if there is a win position. Else return False.
            """
        
            #Check the rows
            for i in range(len(board)):
                if board[i][0] == board[i][1] == board[i][2] == player:
                    return True                        

            #Check the columns
            for i in range(len(board)):
                if board[0][i] == board[1][i] == board[2][i] == player:
                    return True 

            #Check the diagonals
            if board[0][0] == board[1][1] == board[2][2]  == player or \
                   board[0][2] == board[1][1] == board[2][0] == player:
                return True

            return False
        
        if X == O:
            if win(board, 'O') and win(board, 'X'):
                return False
            
            if win(board, 'X'):
                return False
            
            if win(board, 'O'):
                return True
        
            return True
        
        elif X == O + 1:
            if win(board, 'O') and win(board, 'X'):
                return False
            
            if win(board, 'X'):
                return True
            
            if win(board, 'O'):
                return False
            
            return True
        
        else:
            return False
```


```python
class Solution:    
    def validTicTacToe(self, board):
        """
        :type board: List[str]
        :rtype: bool
        """    
        X, O = 0, 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == "X":
                    X += 1
                elif  board[i][j] == "O":
                    O += 1

        if O not in {X-1, X}: 
            return False
        
        def win(board, player):
            """
            Check if the given player has a win position.
            Return True if there is a win position. Else return False.
            """
        
            #Check the rows
            for i in range(len(board)):
                if board[i][0] == board[i][1] == board[i][2] == player:
                    return True                        

            #Check the columns
            for i in range(len(board)):
                if board[0][i] == board[1][i] == board[2][i] == player:
                    return True 

            #Check the diagonals
            if board[0][0] == board[1][1] == board[2][2]  == player or \
                   board[0][2] == board[1][1] == board[2][0] == player:
                return True

            return False
        
        if win(board, 'O'):
            if win(board, 'X'):
                return False
            return O == X  
        
        if win(board, 'X') and X != O + 1:
            return False
        
        return True
```

## 54. Spiral Matrix (Matrix) (Amazon OA 19, Microsoft 8, Google 5)  
O(m*n)  
O(1)


```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        
        cur = 0
        
        m = len(matrix)
        n = len(matrix[0])
        
        res = []
               
        maxUp = maxLeft = 0
        maxRight = n - 1
        maxDown = m - 1
        direction = 0
        
        while True:
            if cur == m * n:
                return res
            
            if direction == 0: #go right
                for i in range(maxLeft, maxRight+1):
                    cur += 1
                    res.append(matrix[maxUp][i])
                    
                maxUp += 1
            elif direction == 1: # go down
                for i in range(maxUp, maxDown+1):
                    cur += 1
                    res.append(matrix[i][maxRight])
                    
                maxRight -= 1
            elif direction == 2: # go left
                for i in range(maxRight, maxLeft - 1, -1):
                    cur += 1
                    res.append(matrix[maxDown][i])
                maxDown -= 1
            else: #go up
                for i in range(maxDown, maxUp - 1, -1):
                    cur += 1
                    res.append(matrix[i][maxLeft])
                maxLeft += 1
                
            direction = (direction + 1 ) % 4
```


```python
class Solution:
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if not matrix:
            return []
        
        return list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
```


```python
s = Solution()
matrix = [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]

print(matrix and matrix.pop(0))

matrix2 = list(zip(*matrix))[::-1]
print('matrix2 =', matrix2)
print(matrix2 and matrix2.pop(0))


matrix3 = list(zip(*matrix2))[::-1]
print('matrix3 =', matrix3)
print(matrix3 and matrix3.pop(0))

matrix4 = list(zip(*matrix3))[::-1]
print('matrix4 =', matrix4)
print(matrix4 and matrix4.pop(0))

matrix5 = list(zip(*matrix4))[::-1]
print('matrix5 =', matrix5)
print(matrix5 and matrix5.pop(0))

matrix6 = list(zip(*matrix5))[::-1]
print('matrix6 =', matrix6)
print(matrix5 and matrix6.pop(0))

# s.spiralOrder(matrix)

```


```python
1 and 32
```


```python
l1 = [1,2,3]
l1 += [3]
l1
```

## 59. Spiral Matrix II (Microsoft Onsite, Amazon 3)


```python
class Solution:
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        res = []
        l = n * n + 1
        while l > 1:
            l, r = l - len(res), l
            res = [list(range(l, r))] + list(zip(*res[::-1]))
        return res
```


```python
class Solution():
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        if not n:
            return
        
        
        cur = 0
        matrix = [[0 for i in range(n)] for j in range(n)]
        maxUp = maxLeft = 0 
        maxDown = maxRight = n - 1
        direction = 0
        
        while True:
            if cur == n * n:
                return matrix
            
            if direction == 0: #go right
                for i in range(maxLeft, maxRight+1):
                    cur += 1
                    matrix[maxUp][i] = cur
                maxUp += 1
            elif direction == 1: # go down
                for i in range(maxUp, maxDown+1):
                    cur += 1
                    matrix[i][maxRight] = cur
                maxRight -= 1
            elif direction == 2: # go left
                for i in range(maxRight, maxLeft - 1, -1):
                    cur += 1 
                    matrix[maxDown][i] = cur
                maxDown -= 1
            else: #go up
                for i in range(maxDown, maxUp - 1, -1):
                    cur += 1
                    matrix[i][maxLeft] = cur
                maxLeft +=1       
            
            direction = (direction + 1 ) % 4
```

## 48. Rotate Image (Matrix) (Amazon 9, Microsoft Onsite 8)

O(row*col)  
O(1)


```python
class Solution:
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        matrix[:] = zip(*matrix[::-1])
        
```


```python
s = Solution()
matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
# matrix[:]
# s.rotate(matrix)
# matrix
x = zip(*matrix[::-1])
for i in x:
    print(i)
```


```python
list(zip(*matrix[::-1]))
```


```python
class Solution:
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)        
        # transpose matrix
        for i in range(n):
            for j in range(i, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] 
        
        # reverse each row
        for i in range(n):
            matrix[i].reverse()
```

## 867. Transpose Matrix (Microsoft Onsite)


```python
class Solution():
    def transpose(self, A):
        """
        :type A: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(A), len(A[0])
        ans = [[0] * m for _ in range(n)]
        
        for r, row in enumerate(A):
            for c, val in enumerate(row):
                ans[c][r] = val
        return ans
```


```python
class Solution:
    def transpose(self, A):
        """
        :type A: List[List[int]]
        :rtype: List[List[int]]
        """
        
        A[:] = zip(*A)
        return A
    
```

## 73. Set Matrix Zeroes (Matrix) (Amazon 7, Microsoft Onsite 5)

时间复杂度: O(m * n)  
空间复杂度: O(1)


```python
class Solution:
    def setZeroes(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        row =len(matrix)
        col = len(matrix[0])
        
        for i in range(row):
            for j in range(col):
                if matrix[i][j] == 0:
                    for k in range(row):
                        if matrix[k][j] != 0:
                            matrix[k][j] = '*'
                            
                    for k in range(col):
                        if matrix[i][k] != 0:
                            matrix[i][k] = '*'
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '*':
                    matrix[i][j] = 0 
```


```python
class Solution:
    def setZeroes(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        is_col = False
        m = len(matrix)
        n = len(matrix[0])
        for i in range(m):
            # Since first cell for both first row and first column is the same i.e. matrix[0][0]
            # We can use an additional variable for either the first row/column.
            # For this solution we are using an additional variable for the first column
            # and using matrix[0][0] for the first row.
            if matrix[i][0] == 0:
                is_col = True
            for j in range(1, n):
                # If an element is zero, we set the first element of the corresponding row and column to 0
                if matrix[i][j]  == 0:
                    matrix[0][j] = 0
                    matrix[i][0] = 0

        # Iterate over the array once again and using the first row and first column, update the elements.
        for i in range(1, m):
            for j in range(1, n):
                if not matrix[i][0] or not matrix[0][j]:
                    matrix[i][j] = 0

        # See if the first row needs to be set to zero as well
        if matrix[0][0] == 0:
            for j in range(n):
                matrix[0][j] = 0

        # See if the first column needs to be set to zero as well        
        if is_col:
            for i in range(m):
                matrix[i][0] = 0
```

## 311. Sparse Matrix Multiplication (Matrix) (Facebook 5, Microsoft Onsite, Apple 4)

O(m*n)  
O(m*n)


```python
class Solution(object):
    def multiply(self, A, B):
        """
        :type A: List[List[int]]
        :type B: List[List[int]]
        :rtype: List[List[int]]
        """
        mA = len(A)
#         print('mA=', mA)
        nA = len(A[0])
#         print('nA=', nA)
        nB = len(B[0])
#         print('nB=', nB)
        res = [[0]*nB for n in range(mA)]
        
        for i in range(mA):
            for k in range(nB):
                for j in range(nA):
                    if A[i][j]:
                        res[i][k] += A[i][j] * B[j][k]    
        return res
```


```python
class Solution:
    def multiply(self, A, B):
        """
        :type A: List[List[int]]
        :type B: List[List[int]]
        :rtype: List[List[int]]
        """
            
        mA = len(A)
#         print('mA=', mA)
        nA = len(A[0])
#         print('nA=', nA)
        nB = len(B[0])
#         print('nB=', nB)
        res = [[0]*nB for n in range(mA)]
#         print('res=', res)

        for i in range(mA):
            for j in range(nA):
                if A[i][j]:
                    for k in range(nB):
                        res[i][k] += A[i][j]*B[j][k]
        return res
```


```python
s = Solution()
A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]

A[1][0]

s.multiply(A,B)
```


```python
import numpy as np
x = np.array(A)
y = np.array(B)
z = x @ y
```
