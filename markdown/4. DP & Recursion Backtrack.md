```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

### (18) DP-Iteration. DP-DFS-Recursion

### List. List. DP-Iteration. O(N) O(N)

## 509. Fibonacci Number (Amazon 2, Microsoft 2)

Bottom-Up Approach using Memoization  
O(N)  
O(N)


```python
class Solution:
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
#         cache = {0: 0, 
#                  1: 1}
        
        dp = [0, 1] + [0] * (n - 1)
        # Since range is exclusive and we want to include N, we need to put N+1.
        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
```


```python
[0] *  -2
```




    []



Top-Down Approach using Memoization


```python
class Solution:    
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
        dic = {0: 0,
               1: 1}
        
        def dp(n): 
#             if n <= 1:
#                 return n

            if n in dic:
                return dic[n]

            dic[n] = dp(n-1) + dp(n-2)
            return dic[n]
        
        return dp(n)
```


```python
s = Solution()
s.fib(7)
```




    13




```python
class Solution:        
    def countBinStry(self, n):
        """
        :type n: int
        :rtype: int
        """
        dic = {0: 0, 
               1: 1}
        
        n += 2
        
        def fib(n):
            """
            :type n: int
            :rtype: int
            """
#             if n <= 1:
#                 return n

            if n in dic:
                return dic[n]

            dic[n] = fib(n-1) + fib(n-2)
            
            return dic[n]
        
        return fib(n)
```


```python
s = Solution()
s.countBinStry(4)
```




    8




```python
class Solution:
    def fib(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        if n <= 1:
            return n
        return self.fib(n-1) + self.fib(n-2)
```

## 70. Climbing Stairs (Int) (Amazon 6)  
O(N)  
O(1)


```python
# Recursion
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        if n == 1: 
            return 1
        if n == 2: 
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)
```


```python
# Bottom up. 时间复杂度: O(N)- 空间复杂度: O(N)
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        if n == 2:
            return 2
        
        cache = [0, 1, 2] + [0] * (n-2)
        
        for i in range(3, n+1):
            cache[i] = cache[i-1] + cache[i-2]
        return cache[n]
```


```python
[0] * -1
```




    []




```python
# Top down. 时间复杂度: O(N)- 空间复杂度: O(N)
class Solution:            
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        dic = {1: 1, 
               2: 2}
        
        def dp(n):
            if n in dic:
                return dic[n]

            dic[n] = dp(n-1) + dp(n-2)
            return dic[n]
        
        return dp(n)
```


```python
class Solution:
    def climbStairs(self, n):
        if n == 1: 
            return 1
        res = [-1 for i in range(n)]
        res[0], res[1] = 1, 2
        
        def dp(n, res):
            if res[n] == -1:
                res[n] = dp(n - 1, res) + dp(n - 2, res)
            return res[n]
        
        return dp(n-1, res)
        
#     def dp(self, n, res):
#         if res[n] == -1:
#             res[n] = self.dp(n - 1, res) + self.dp(n - 2, res)
#         return res[n]
```

## Knapsack


```python
def solve_knapsack(profits, weights, capacity):

    n = len(profits)
    if capacity <= 0 or n == 0 or len(weights) != n:
        return 0

    dp = [[0 for i in range(capacity+1)] for j in range(n)]

  # populate the capacity = 0 columns, with '0' capacity we have '0' profit
    for i in range(0, n):
        dp[i][0] = 0

  # if we have only one weight, we will take it if it is not more than the capacity
    for c in range(0, capacity+1):
        if weights[0] <= c:
            dp[0][c] = profits[0]

  # process all sub-arrays for all the capacities
    for i in range(1, n):
        for c in range(1, capacity+1):
            # include the item, if it is not more than the capacity
            if weights[i] <= c:
                dp[i][c] = max(dp[i - 1][c], profits[i] + dp[i - 1][c - weights[i]])

            else:
                dp[i][c] = dp[i - 1][c]
    return dp[n - 1][capacity]

print(solve_knapsack([1, 6, 10, 16], [1, 2, 3, 5], 5))
print(solve_knapsack([1, 6, 10, 16], [1, 2, 3, 5], 6))
print(solve_knapsack([1, 6, 10, 16], [1, 2, 3, 5], 7))
```

    16
    17
    22



```python
def knapSack(val, wt, W): 
    n = len(val)
    K = [[0 for x in range(W+1)] for x in range(n+1)] 
  
    # Build table K[][] in bottom up manner 
    for i in range(n+1): 
        for w in range(W+1): 
            if i==0 or w==0: 
                K[i][w] = 0
            elif wt[i-1] <= w: 
                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]) 
            else: 
                K[i][w] = K[i-1][w] 
  
    return K[n][W]

print(knapSack([1, 6, 10, 16], [1, 2, 3, 5], 5))
print(knapSack([1, 6, 10, 16], [1, 2, 3, 5], 6))
print(knapSack([1, 6, 10, 16], [1, 2, 3, 5], 7))
```

    16
    17
    22


## 118. Pascal's Triangle (Amazon 3, Apple 2)


```python
class Solution:
    def generate(self, num_rows):
        triangle = []

        for row_num in range(num_rows):
            # The first and last row elements are always 1.
            row = [0] * (row_num+1)

            row[0], row[-1] = 1, 1

            # Each triangle element is equal to the sum of the elements
            # above-and-to-the-left and above-and-to-the-right.
            for i in range(1, len(row)-1):
                row[i] = triangle[row_num-1][i-1] + triangle[row_num-1][i]

            triangle.append(row)

        return triangle
```


```python
x = [None] * 5
x
```




    [None, None, None, None, None]



## 119. Pascal's Triangle II


```python
class Solution:
    def getRow(self, rowIndex):
    # j行的数据, 应该由j - 1行的数据计算出来.
    # 假设j - 1行为[1,3,3,1], 那么我们前面插入一个0(j行的数据会比j-1行多一个),
    # 然后执行相加[0+1,1+3,3+3,3+1,1] = [1,4,6,4,1], 最后一个1保留即可.
        r = [1]
        for i in range(rowIndex):
            r.insert(0, 0)
            # 因为i行的数据长度为i+1, 所以j+1不会越界, 并且最后一个1不会被修改.
            for j in range(i+1):
                r[j] += r[j + 1]
        return r

```

## Product of K Consecutive Numbers (List, List-DP) (Google Phone)


```python
class Solution:
    def product(self, nums, k):
        dp = [nums[0]] * len(nums)
        k = len(nums) if k > len(nums) else k
        
        for i in range(1, k):
            dp[i] = dp[i-1] * nums[i]
            
        for i in range(k, len(nums)):
            dp[i] = dp[i-1] // nums[i-k] * nums[i]
            
            
        return dp
            
nums = [1, 3, 3, 6, 5, 7, 0, -3]
k = 3
s = Solution()
s.product(nums, k)
```




    [1, 3, 9, 54, 90, 210, 0, 0]




```python
def x(nums, k):

    dp = [num for num in nums]
    k = len(nums) if k > len(nums) else k
    for i in range(1,k):
        for j in range(i+1,len(nums)):
            dp[j] *= nums[j-i]
    return dp

nums = [1, 3, 3, 6, 5, 7, 0, -3]
k = 3
# Output: [1, 3, 9, 54, 90, 210, 0, 0]
x(nums, k)
```




    [1, 3, 9, 54, 90, 210, 0, 0]



## 975. Odd Even Jump (List-DP) (Google 9->4) (Hard)
- 时间复杂度: O(NlgN)- 空间复杂度: O(N)  
规律跳格子，固定点位固定落地点，所以可以搞一个函数专门算这个，接下来就是dp，dp[i]代表从点i能否跳到最后一个点


```python
# O(N*logN)
class Solution:
    def oddEvenJumps(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        def make(B):
            res = [-1] * N
            stack = [] # invariant: stack is decreasing
            for i in B:
                while stack and i > stack[-1]:
                    res[stack.pop()] = i
                stack.append(i)
            return res

        N = len(A) # A = [10,13,12,14,15]

        B = sorted(list(range(N)), key = lambda i : A[i]) # [0, 2, 1, 3, 4]
        odd_nxt = make(B)

        B = sorted(list(range(N)), key = lambda i : -A[i]) # [4, 3, 1, 2, 0]
        even_nxt = make(B)

        odd, even = [False] * N, [False] * N
        odd[-1], even[-1] = True, True

        for i in range(N-2, -1, -1):
            if odd_nxt[i] != -1:
                odd[i] = even[odd_nxt[i]]
            if even_nxt[i] != -1:
                even[i] = odd[even_nxt[i]]

        return sum(odd)
```


```python
for i in range(3,-1,-1):
    print(i)
```

    3
    2
    1
    0


## 343. Integer Break (Apple 4, Google 2, 6-12months)


```python
# O(N^2)
# O(N)
class Solution(object):
    cache = {1: 1}
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n in self.cache:
            return self.cache[n]
        self.cache[n] = -1
        for i in range(1, n):
            self.cache[n] = max(self.cache[n], i * (n-i), i * self.integerBreak(n-i))
        return self.cache[n] 
```


```python
class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        cache = [1] * (n+1)
        for i in range(2, n+1):
            for j in range(1, i):
                cache[i] = max(cache[i], j * (i-j), j * cache[i-j])
        return cache[-1] 
```

## 354. Russin Doll Envelopes (Lists-DP) (Microsoft 3->0, Google 5, Amazon 2) (Hard)


```python
import bisect
class Solution:
    def maxEnvelopes(self, envelopes):
        """
        :type envelopes: List[List[int]]
        :rtype: int
        """
        
        envelopes = sorted(envelopes, key = lambda x: (x[0], -x[1]))
        dp = []
        for env in envelopes:
            h = env[1]
            pos = bisect.bisect_left(dp, h)
            if pos == len(dp):
                dp.append(h)
            else:
                dp[pos] = h
        return len(dp)
```

## 53. Maximum Subarray (List. List.DP-Iteration) (Amazon 29, Linkein 16, Microsoft Onsite 13, Apple 8, Google 7, Facebook 7)


```python
# O(N)  
# O(N)
# dp[i]表示i之前的最大sum

class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [nums[0]] * len(nums)
#         print('maxSum =', maxSum)
        
        for i in range(1, len(nums)):
#             print('i=', i)
            dp[i] = max(dp[i - 1] + nums[i], nums[i])
#             print(f'maxSum [{i}] =', maxSum[i])
        return max(dp)
```


```python
s = Solution()
nums = [-2,1,-3,4,-1,2,1,-5,4]
s.maxSubArray(nums)
```

    maxSum = [-2, -2, -2, -2, -2, -2, -2, -2, -2]
    i= 1
    maxSum [1] = 1
    i= 2
    maxSum [2] = -2
    i= 3
    maxSum [3] = 4
    i= 4
    maxSum [4] = 3
    i= 5
    maxSum [5] = 5
    i= 6
    maxSum [6] = 6
    i= 7
    maxSum [7] = 1
    i= 8
    maxSum [8] = 5





    6




```python
nums = [2,3,4,5]
maxSum = [nums[0] for i in nums]
maxSum
```




    [2, 2, 2, 2]




```python
maxsum = [2] * 4
```

## 152. Maximum Product Subarray (List, List-DP) (Linkedin 10, Microsoft 4, Amazon Onsite 4-1, Google 3, Facebook 3)


```python
class Solution:
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        maxdp = [nums[0]] * len(nums)
        mindp = [nums[0]] * len(nums)

        for i in range(1, len(nums)):
            maxdp[i] = max(mindp[i-1]*nums[i], maxdp[i-1]*nums[i], nums[i])
            mindp[i] = min(maxdp[i-1]*nums[i], mindp[i-1]*nums[i], nums[i])

        return max(maxdp)
```

## 918. Maximum Sum Circular Subarray


```python
class Solution:
    def maxSubarraySumCircular(self, A):
        def maxSum(nums):
            dp = [nums[0]] * len(nums)
            for i in range(1, len(nums)):
                dp[i] = max(dp[i - 1] + nums[i], nums[i])
            return max(dp)
                
        res = [A]

        for i in range(len(A) - 1):
            new = res[-1].copy()
#             new = new.copy()
            n = new.pop()
            new.insert(0, n)
            res.append(new)
        
        print(res)
        
        maximum = float('-inf')
        for n in res:
            maximum = max(maximum, maxSum(n))
            
        return maximum
    
s = Solution()
A = [-2, -3, -1]
s.maxSubarraySumCircular(A)
```

    [[-2, -3, -1], [-1, -2, -3], [-3, -1, -2]]





    -1



## 238. Product of Array Except Self (List[int]. List.DP-Iteration) (Facebook 70, Amazon 22, Microsoft 9, Apple 7, Google 4)


```python
# O(n)  
# O(n)
class Solution():
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        if not nums:
            return []
        
        n = len(nums)
        left, right, res = [0]*n, [0]*n, [0]*n
        
        left[0] = 1
        for i in range(1, n):
            left[i] = nums[i - 1] * left[i - 1]
        
        right[n - 1] = 1
        for i in range(n - 2, -1, -1):
            right[i] = nums[i + 1] * right[i + 1]
                    
        for i in range(n):
            res[i] = left[i] * right[i]
        
        return res
```


```python
class Solution:
    def productExceptSelf(self, nums):
        
        # The length of the input array 
        n = len(nums)
        
        # The left and right arrays as described in the algorithm
        L, R, res = [0]*n, [0]*n, [0]*n
        
        # L[i] contains the product of all the elements to the left
        # Note: for the element at index '0', there are no elements to the left,
        # so the L[0] would be 1
        L[0] = 1
        for i in range(1, n):
            
            # L[i - 1] already contains the product of elements to the left of 'i - 1'
            # Simply multiplying it with nums[i - 1] would give the product of all 
            # elements to the left of index 'i'
            L[i] = nums[i - 1] * L[i - 1]
            
#         print('L =', L)
        # R[i] contains the product of all the elements to the right
        # Note: for the element at index 'length - 1', there are no elements to the right,
        # so the R[length - 1] would be 1
        R[n - 1] = 1
        for i in range(n - 2, -1, -1):
            
            # R[i + 1] already contains the product of elements to the right of 'i + 1'
            # Simply multiplying it with nums[i + 1] would give the product of all 
            # elements to the right of index 'i'
            R[i] = nums[i + 1] * R[i + 1]
        
#         print('R =', R)
        # Constructing the answer array
        for i in range(n):
            # For the first element, R[i] would be product except self
            # For the last element of the array, product except self would be L[i]
            # Else, multiple product of all elements to the left and to the right
            res[i] = L[i] * R[i]
        
        return res
```


```python
for i in reversed(range(4)):
    print(i)
```


```python
s = Solution()
s.productExceptSelf([1,2,3,4])
```


```python
[0]*3
```


```python
l1 = [0,2,4]
l1.pop(0)
l1
```


```python
length = 5
for i in reversed(range(length - 1)):
    print(i)
```


```python
for i in range(5, -1, -1):
    print(i)
```

O(N)  
O(1)


```python
class Solution:
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        length = len(nums)
        
        answer = [0]*length
        
        answer[0] = 1
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        
        R = 1
        for i in reversed(range(length)):
            answer[i] = answer[i] * R
            R *= nums[i]
        
        return answer
```


```python
class Solution:
    def productExceptSelf(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        # The length of the input array 
        length = len(nums)
        
        # The answer array to be returned
        answer = [0]*length
        
        # answer[i] contains the product of all the elements to the left
        # Note: for the element at index '0', there are no elements to the left,
        # so the answer[0] would be 1
        answer[0] = 1
        for i in range(1, length):
            
            # answer[i - 1] already contains the product of elements to the left of 'i - 1'
            # Simply multiplying it with nums[i - 1] would give the product of all 
            # elements to the left of index 'i'
            answer[i] = nums[i - 1] * answer[i - 1]
        
        # R contains the product of all the elements to the right
        # Note: for the element at index 'length - 1', there are no elements to the right,
        # so the R would be 1
        R = 1;
        for i in reversed(range(length)):
            
            # For the index 'i', R would contain the 
            # product of all elements to the right. We update R accordingly
            answer[i] = answer[i] * R
            R *= nums[i]
        
        return answer
```

## 198. House Robber (List. List.DP-Iteration) (Google 5->7, Amazon 3)  
https://github.com/azl397985856/leetcode/blob/master/problems/198.house-robber.md  
dp[i]表示能抢最大的财产


```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        if not nums: 
            return 0
        if len(nums) == 1: 
            return nums[0]
        if len(nums) == 2: 
            return max(nums)

        dp = [0]*len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        
        return dp[-1]
```

## 91. Decode Ways (String (num). List. DP-Iteration) (Amazon 9, Facebook 8, Google 3, Microsoft Onsite, Apple 2)
 


```python
# O(N)  
# O(N)
# dp[i]表示s[i]之前included的最大decode数量

class Solution():
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s or s[0] == "0":
            return 0

        dp = [0] * (len(s) + 1)
        dp[-1] = 1
        
        if s[0] != "0":
            dp[0] = 1

        for i in range(1, len(s)):
            one = int(s[i])
            two = int(s[i - 1] + s[i])
            if 0 < one < 10:
                dp[i] += dp[i - 1]
            if 9 < two < 27:
                dp[i] += dp[i - 2]

#         print(dp)
        return dp[-2]
```


```python
# O(N)  
# O(N)

# dp[i]表示s[i]之前(不包括i)的最大decode数量

# w tells the number of ways  
# v tells the previous number of ways  
# d is the current digit  
# p is the previous digit 

class Solution:
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        if not s or s[0] == "0":
            return 0

        dp = [0] * (len(s) + 1)

        dp[0] = 1
        if s[0] != "0":
            dp[1] = 1

        for i in range(2, len(s) + 1):
            one = int(s[i - 1])
            two = int(s[i - 2] + s[i - 1])
            if 0 < one < 10:
                dp[i] += dp[i - 1]
            if 9 < two < 27:
                dp[i] += dp[i - 2]
        return dp[-1]
```

## Candy (List. DP-List) (Amazon 4, Microsoft Onsite 3)


```python
# O(N)  
# O(N)
# dp[i]表示这个位置的最大值
class Solution():
    def candy(self, ratings):
        """
        :type ratings: List[int]
        :rtype: int
        """
        if not ratings: 
            return 0
        
        n = len(ratings)
        
        left_to_right = [1] * n
        right_to_left = [1] * n
        # 找从左到右满足条件的
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                # 保证从左到右的最少个数
                left_to_right[i] = left_to_right[i - 1] + 1
        # print(left_to_right)
        # 找从右到左满足条件的(同时要符合从左到右)
        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                # 保证从左到右也满足, 同时也满足从右到左
                right_to_left[i] = max(left_to_right[i], right_to_left[i + 1] + 1)
        # print(right_to_left)
        res = 0
        # 选这个位置最大值
        for i in range(n):
            res += max(left_to_right[i], right_to_left[i])
        return res
```


```python
# Optimized
class Solution():
    def candy(self, ratings): 
        if not ratings: 
            return 0
        
        n = len(ratings)
        
        candy_nums = [1] * n

        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                candy_nums[i] = 1 + candy_nums[i - 1]

        for i in range(n - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                candy_nums[i] = max(candy_nums[i], 1 + candy_nums[i + 1])
        return sum(candy_nums)
```

## 279. Perfect Squares (Int, List-DP) (Google 4->0, Amazon 2)


```python
# dp[i]表示加到数字i需要的最小square个数
class Solution:
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        square = [i**2 for i in range(1, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        # bottom case
        dp[0] = 0
        
        for num in square:
            for i in range(num, n+1):
                dp[i] = min(dp[i], dp[i-num] + 1)
        
        return dp[-1]
```


```python
# dp[i]表示加到数字i需要的最小square个数
class Solution:
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        square_nums = [i**2 for i in range(1, int(math.sqrt(n))+1)]
        
        dp = [float('inf')] * (n+1)
        # bottom case
        dp[0] = 0
        
        for i in range(1, n+1):
            for square in square_nums:
                if i >= square:
                    dp[i] = min(dp[i], dp[i-square] + 1)
        
        return dp[-1]
```

## 322. Coin Change (List, List-DP) (Amazon 14, Microsoft 5, Google)  

O(N^2)  
O(N)  

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1

题目求的值为 f(11)，第一次选择硬币时我们有三种选择。
假设我们取面额为 1 的硬币，那么接下来需要凑齐的总金额变为 11 - 1 = 10，即 f(11) = f(10) + 1，这里的 +1 就是我们取出的面额为 1 的硬币。

同理，如果取面额为 2 或面额为 5 的硬币可以得到：  
f(11) = f(9) + 1
f(11) = f(6) + 1

f(11) = min(f(10), f(9), f(6)) + 1  

dp[i]是得到i数值的硬币数量


```python
# dp[i]表示获得i面值所需的最少币数
from math import inf
class Solution:
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        
        dp = [0] + [inf] * amount
        
        for c in coins:  # 枚举硬币种数
            for i in range(c, amount + 1):  # 从小到大枚举金额，确保j-c >= 0.
                dp[i] = min(dp[i], 1 + dp[i - c])
           
        if dp[-1] != inf:
            return dp[-1]  
        else: 
            return -1  # 如果为inf说明状态不可达，返回-1即可。
```

## 518. Coin Change II (List. List-DP) (Amazon 5, Microsoft 2)


```python
# dp[i]表示获得i面值的所有方式
class Solution:
    def change(self, amount, coins):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        dp = [1] + [0] * amount 
        
        for c in coins:
            for i in range(c, amount + 1):
                dp[i] = dp[i] + dp[i - c]
                print(dp)

        return dp[-1]

s = Solution()
amount = 5
coins = [1, 2, 5]    
s.change(amount, coins)

```

    [1, 1, 0, 0, 0, 0]
    [1, 1, 1, 0, 0, 0]
    [1, 1, 1, 1, 0, 0]
    [1, 1, 1, 1, 1, 0]
    [1, 1, 1, 1, 1, 1]
    [1, 1, 2, 1, 1, 1]
    [1, 1, 2, 2, 1, 1]
    [1, 1, 2, 2, 3, 1]
    [1, 1, 2, 2, 3, 3]
    [1, 1, 2, 2, 3, 4]





    4




```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        if amount == 0:
            return 1
        
        # dp[i] means the #ways to compose {i} amount
        dp = [0] * (amount + 1)
        dp[0] = 1
        
        for j in coins:
            for i in range(amount + 1):
                if i >= j:
                    dp[i] += dp[i - j]

        return dp[amount]
```

## 1155. Number of Dice Rolls With Target Sum (Amazon 7)


```python
class Solution:
    def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        dp = [[0 for i in range(target + 1)] for j in range(d + 1)]
        dp[0][0] = 1
        mod = 10 ** 9 + 7
        for i in range(1, d + 1):
            for j in range(1, target + 1):
                k = 1
                while k <= min(j, f):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod
                    k += 1
        return dp[d][target] % mod
```


```python
def numRollsToTarget(self, d: int, f: int, target: int) -> int:
        @lru_cache(maxsize=None)
        def nrolls(d, t):
            if d == 0: return 1 if t == 0 else 0 
            if d > t or t < 0: return 0
            res = 0
            for i in range(1, f+1):
                res += nrolls(d-1, t-i)
            return res % ((10 ** 9) + 7)
        return nrolls(d, target
```

## 300. Longest Increasing Subsequence (List, List-DP) (Amazon 6, Google 5, Microsoft 2)


```python
# O(N^2)  
# O(N)  
# dp[i]表示列表i之前的最大长度
class Solution:
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        dp = [1] * len(nums)
        for r in range(1, len(nums)):
            for l in range(r):
                if nums[r] > nums[l]:
                    dp[r] = max(dp[r], 1 + dp[l])
#                     print(f'dp[{i}]=', dp[i])
#                     print(dp)
                    
        return max(dp)
```


```python
nums = [10,9,2,5,3,7,101,18]
s = Solution()
s.lengthOfLIS(nums)
```

    dp[3]= 2
    [1, 1, 1, 2, 1, 1, 1, 1]
    dp[4]= 2
    [1, 1, 1, 2, 2, 1, 1, 1]
    dp[5]= 2
    [1, 1, 1, 2, 2, 2, 1, 1]
    dp[5]= 3
    [1, 1, 1, 2, 2, 3, 1, 1]
    dp[5]= 3
    [1, 1, 1, 2, 2, 3, 1, 1]
    dp[6]= 2
    [1, 1, 1, 2, 2, 3, 2, 1]
    dp[6]= 2
    [1, 1, 1, 2, 2, 3, 2, 1]
    dp[6]= 2
    [1, 1, 1, 2, 2, 3, 2, 1]
    dp[6]= 3
    [1, 1, 1, 2, 2, 3, 3, 1]
    dp[6]= 3
    [1, 1, 1, 2, 2, 3, 3, 1]
    dp[6]= 4
    [1, 1, 1, 2, 2, 3, 4, 1]
    dp[7]= 2
    [1, 1, 1, 2, 2, 3, 4, 2]
    dp[7]= 2
    [1, 1, 1, 2, 2, 3, 4, 2]
    dp[7]= 2
    [1, 1, 1, 2, 2, 3, 4, 2]
    dp[7]= 3
    [1, 1, 1, 2, 2, 3, 4, 3]
    dp[7]= 3
    [1, 1, 1, 2, 2, 3, 4, 3]
    dp[7]= 4
    [1, 1, 1, 2, 2, 3, 4, 4]





    4




```python
# Dynamic programming + Dichotomy.
class Solution:
    def lengthOfLIS(self, nums):
        tails = [0] * len(nums)
        res = 0
        
        for num in nums:
            i = 0
            j = res
            
            while i < j:
                m = (i + j) // 2
                if tails[m] < num: 
                    i = m + 1 # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                else: 
                    j = m
            
            tails[i] = num
            
            if j == res: 
                res += 1
        return res

```

### Matrix, String. DP-Iteration. O(N^2) O(N^2)

## 62. Unique Paths (Int. Matrix. DP-Iteration) (Amazon 10->5, Microsoft 5)


```python
# 时间复杂度: O(m * n)- 空间复杂度: O(m * n)
# dp[i][j]表示该位置最多unique paths
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        if not m or not n:
            return 0
        
        dp = [[1] * n for i in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

时间复杂度: O(m * n)- 空间复杂度: O(n)


```python
class Solution:
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        if m < 1 or n < 1:
            return 0
        dp = [1] * n
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j-1]
        return dp[n-1]
```

## 63. Unique Paths II (Matrix-DP) (Amazon 4->7, Google 7, Microsot Onsite 3)


```python
class Solution():
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        
        if not m or not n:
            return 0
        
        if obstacleGrid[0][0] == 1:
            return 0
        
        for i in range(n):
            if obstacleGrid[0][i] == 0:
                obstacleGrid[0][i] = 1
                
            else:
                for j in range(i, n):
                    obstacleGrid[0][j] = 0
                    
                break
                
        # print(obstacleGrid)
                
        for i in range(1, m):
            if obstacleGrid[i][0] == 0:
                obstacleGrid[i][0] = 1
                
            else:
                for j in range(i, m):
                    obstacleGrid[j][0] = 0
                    
                break
        
        # print(obstacleGrid)
                
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] = 1
                    
                else:
                    obstacleGrid[i][j] = 0
        
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:                
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]
                    
        return obstacleGrid[-1][-1]
```


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """

        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:
            return 0
        n, m = len(obstacleGrid[0]), len(obstacleGrid)
        arr = [0] * n
        arr[0] = 1
        
        for i in range(m):
            if obstacleGrid[i][0] == 1:
                arr[0] = 0
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    arr[j] = arr[j] + arr[j - 1]
#                     print(arr, 0)
                else:
                    arr[j] = 0
#                     print(arr, 1)
                 
        return arr[-1]
```


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        dp = []
        for i in range(len(obstacleGrid)):
            dp.append([0]*len(obstacleGrid[0]))
        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0 
        for i in range(1,len(obstacleGrid)):
            dp[i][0] = 1 if obstacleGrid[i][0] == 0 and dp[i-1][0] != 0 else 0
        
        for j in range(1,len(obstacleGrid[0])):
            dp[0][j] = 1 if obstacleGrid[0][j] == 0 and dp[0][j-1] != 0 else 0
            
        for i in range(1,len(dp)):
            for j in range(1,len(dp[0])):
                if obstacleGrid[i][j] == 1:
                    dp[i][j] = 0
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])

        # If the starting cell has an obstacle, then simply return as there would be
        # no paths to the destination.
        if obstacleGrid[0][0] == 1:
            return 0

        # Number of ways of reaching the starting cell = 1.
        obstacleGrid[0][0] = 1

        # Filling the values for the first column
        for i in range(1, m):
            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)

        # Filling the values for the first row        
        for j in range(1, n):
            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)

        # Starting from cell(1,1) fill up the values
        # No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]
        # i.e. From above and left.
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]
                else:
                    obstacleGrid[i][j] = 0

        # Return value stored in rightmost bottommost cell. That is the destination.            
        return obstacleGrid[m-1][n-1]
```

## 64. Minimum Path Sum (Matrix. DP-Matrix) (Amazon 9->17, Google 9)

O(N^2)  
O(1)  
grid[i][j] 表示最少路径sum


```python
class Solution:
    def minPathSum(self, matrix):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        if not matrix:
            return 0

        m = len(matrix)
        n = len(matrix[0])

        for i in range(1, n):
            matrix[0][i] += matrix[0][i-1]

        for i in range(1, m):
            matrix[i][0] += matrix[i-1][0]

        for i in range(1, m):
            for j in range(1, n):
                matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1])

        return matrix[-1][-1]
```

## 542. 01 Matrix (Matrix. DP-Matrix) (Amazon 5->3)  


```python
# O(N)
# O(N)
# dp[i][j]表示当前位置到最近0的距离
class Solution:
    def updateMatrix(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(matrix), len(matrix[0])
        dp = [[float('inf')] * n for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    dp[i][j] = 0
                    
        def get(i, j):
            if 0 <= i <= m - 1 and 0 <= j <= n - 1:
                return dp[i][j]
            else:
                return float('inf')
            
        for i in range(m):
            for j in range(n):
                if matrix[i][j] != 0:
                    dp[i][j] = min(get(i, j-1) + 1, get(i,j+1) + 1, get(i-1,j) + 1, get(i+1,j) + 1)
                    
        for i in range(m-1,-1,-1):
            for j in range(n-1,-1,-1):
                if matrix[i][j] != 0:
                    dp[i][j] = min(get(i, j-1) + 1, get(i,j+1) + 1, get(i-1,j) + 1, get(i+1,j) + 1)
                
        return dp
```


```python
# O(N)
# O(N)
# dp[i][j]表示当前位置到最近0的距离
class Solution:
    def updateMatrix(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """
        m, n = len(matrix), len(matrix[0])
        dp = [[float('inf')] * n for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    dp[i][j] = 0
                    
                else:
                    if i > 0:
                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
                    if j > 0:
                        dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
                    
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                # if matrix[i][j] == 0:
                #     dist[i][j] = 0
                if i < m - 1:
                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
                if j < n - 1:
                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)   
                
        return dp
```


```python
class Solution:
    def updateMatrix(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """
        m = len(matrix)
        n = len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j]:
                    matrix[i][j] = min(matrix[i - 1][j] + 1 if i > 0 else float('inf'), 
                                       matrix[i][j - 1] + 1 if j > 0 else float('inf'))
                         

        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if matrix[i][j]:
                    matrix[i][j] = min(matrix[i + 1][j] + 1 if i < m - 1 else float('inf'), 
                                       matrix[i][j + 1] + 1 if j < n - 1 else float('inf'), matrix[i][j])
                    
        return matrix
```

## Closest XY Pair in a Grid (Matrix. DP-Matrix) (Google Phone)
https://leetcode.com/discuss/interview-question/311662/Google-or-Phone-screen-or-Closest-XY-pair-in-a-grid


```python
def minDist(grid):
    m, n = len(grid), len(grid[0])
    dist = [[float('inf')] * n for _ in range(m)]
    

    for x in range(m):
        for y in range(n):
            if grid[x][y] == 'X':
                dist[x][y] = 0
            else:
                if x > 0:
                    dist[x][y] = min(dist[x][y], dist[x - 1][y] + 1)
                if y > 0:
                    dist[x][y] = min(dist[x][y], dist[x][y - 1] + 1)
    
    print(dist)
    for x in range(m - 1, -1, -1):
        for y in range(n - 1, -1, -1):
            if grid[x][y] == 'X':
                dist[x][y] = 0
            else:
                if x < m - 1:
                    dist[x][y] = min(dist[x][y], dist[x + 1][y] + 1)
                if y < n - 1:
                    dist[x][y] = min(dist[x][y], dist[x][y + 1] + 1)
    
    print(dist)
    return min(dist[x][y] for x in range(m) for y in range(n) if grid[x][y] == 'Y')

grid = [['X','X','0'],
        ['0','0','Y'],
        ['Y','0','0']] 
# Output: 1

minDist(grid)
```

    [[0, 0, 1], [1, 1, 2], [2, 2, 3]]
    [[0, 0, 1], [1, 1, 2], [2, 2, 3]]





    2



## 221. Maximal Square (String Matrix. DP-Matrix) (Google 8, Amazon 4)


```python
# dp[i][j]代表以matrix[i][j]为右下角的正方形的最大长度
# 状态方程dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1，但是必须要满足dp[i][j] == 1，因为右下角也必须为1啊

# O(m*n)
# O(m*n)
class Solution:
    def maximalSquare(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        
        m = len(matrix)
        n = len(matrix[0]) 
        
        dp = [[int(matrix[i][j]) for j in range(n)] for i in range(m)]

        for i in range(1, m):
            for j in range(1, n):
                if dp[i][j] == 1:
                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1

        max_len = 0
        for i in range(m):
            for j in range(n):
                max_len = max(max_len, dp[i][j])
        return max_len * max_len
```

## Count Squares (Goolge Phone)
Matrix  
https://leetcode.com/discuss/interview-question/416012/Google-or-Phone-Screen-or-Count-Squares


```python
# dp[i][j]表示matrix[i-1][j-1]的square个数

def zeroSquares(self, matrix):
    if not matrix:
        return 0
    
    row = len(matrix)
    col = len(matrix[0])
    dp = [[0] * (len(col) + 1) for n in row + 1]
    
    count = 0
    for i in len(1, row + 1):
        for j in len(1, col + 1):
            if matrix[i-1][j-1] == 0:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                count += dp[i][j]
                
                
    return count
        
# public int zeroSquares(int[][] matrix) {
#     int rows = matrix.length;
#     int cols = matrix[0].length;

#     int[][] dp = new int[rows + 1][cols + 1];

#     int count = 0;
#     for (int r = 1; r <= rows; r++) {
#         for (int c = 1; c <= cols; c++) {
#             if (matrix[r - 1][c - 1] == 0) {
#                 dp[r][c] = min(dp[r - 1][c], dp[r][c - 1], dp[r - 1][c - 1]) + 1;
#                 count += dp[r][c];
#             }
#         }
#     }
#     return count;
# }
```

## 85. Maximal Rectangle (Matrix (char). DP-Matrix) (Google 10, Amazon 4, Microsoft 6)


```python
# dp[i][j]表示matrix[i][j]长方形的最大长度

class Solution:
    def maximalRectangle(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        
        maxarea = 0

        dp = [[0] * len(matrix[0]) for n in range(len(matrix))]
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == '1': 
                    # compute the maximum width and update dp with it
                    length = dp[i][j] = dp[i][j-1] + 1 if j else 1

                    # compute the maximum area rectangle with a lower right corner at [i, j]
                    for k in range(i, -1, -1):
                        length = min(length, dp[k][j])
                        maxarea = max(maxarea,  length * (i-k+1)) # 长乘以宽
        return maxarea
```

### String

## 139. Word Break (String, List. List-DP) (Facebook 34, Amazon 27, Google 9, Apple 6, Microsoft 7)

O(N^2)  
O(N)  

dp[i]表示最新word的起点


```python
class Solution:
    def wordBreak(self, s, strs):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        # 初始化标记列表
        dp = [True] + [False] * len(s)

        for l in range(len(s)):
            if dp[l]:
                for r in range(l+1, len(s)+1):
                    if s[l:r] in strs:
                        dp[r] = True
        return dp[-1]
    
s = 'aaaaaaa'
strs = ['aaa', 'aaaa']
obj = Solution()
obj.wordBreak(s, strs)
```




    True



## 5. Longest Palindromic Substring (String. Matrix. DP-Iteration) (Amazon OA 93, Microsoft Onsite 15, Google 8, Apple 7)
O(N^2)  
O(N^2)  
dp[i][j]表示i, j之间string是不是palindrome


```python
# DP
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if len(s) <= 1:
            return s

        dp = [[False]*len(s) for i in range(len(s))]

        res = ''

        for r in range(1, len(s)):
            for l in range(r):
                if s[l] == s[r] and (r - l <= 2 or dp[l + 1][r - 1]):
                    dp[l][r] = True

                    if r - l + 1 > len(res):
                        res = s[l:r + 1]
        
        if not res:
            return s[0]
        
        return res
```


```python
s = 'ababa'
o = Solution()
o.longestPalindrome(s)
```

    [False, False, True, False, True]
    [False, False, False, True, False]
    [False, False, False, False, True]
    [False, False, False, False, False]
    [False, False, False, False, False]





    'ababa'




```python
# DP
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        
        size = len(s)
        if size <= 1:
            return s
        # 二维 dp 问题
        # 状态：dp[l,r]: s[l:r] 包括 l，r ，表示的字符串是不是回文串
        # 设置为 None 是为了方便调试，看清楚代码执行流程
        dp = [[False for _ in range(size)] for _ in range(size)]

        longest_l = 1
        res = s[0]

        # 因为只有 1 个字符的情况在最开始做了判断
        # 左边界一定要比右边界小，因此右边界从 1 开始
        for r in range(1, size):
            for l in range(r):
                # 状态转移方程：如果头尾字符相等并且中间也是回文
                # 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可
                # 否则要继续看收缩以后的区间的回文性
                # 重点理解 or 的短路性质在这里的作用
                if s[l] == s[r] and (r - l <= 2 or dp[l + 1][r - 1]):
                    dp[l][r] = True
                    cur_len = r - l + 1
                    if cur_len > longest_l:
                        longest_l = cur_len
                        res = s[l:r + 1]
            # 调试语句
            # for item in dp:
            #     print(item)
            # prin
        return res
```


```python
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''
        
        res = ''  # Memory to remember a palindrome
        for i in range(len(s)):  # i = start, O = n
            for j in range(len(s), i, -1):  # j = end, O = n^2
                if len(res) >= j-i:  # To reduce time
                    break
                    
                elif s[i:j] == s[i:j][::-1]:
                    res = s[i:j]
                    break
        return res
```


```python
s = 'babad'
for i in range(len(s)):
    for j in range(len(s),i,-1):
#         print(i,j)
        print(s[i:j])
    print()
```

    babad
    baba
    bab
    ba
    b
    
    abad
    aba
    ab
    a
    
    bad
    ba
    b
    
    ad
    a
    
    d
    


## 516. Longest Palindromic Subsequence (String, DP-Matrix) (Amazon 6, Linkedin 4, Microsoft 3)
O(n^2)  
O(n^2)  

dp[i][j]表示i,j之间string的最长palindrome长度


```python
class Solution:
    def longestPalindromeSubseq(self, s):
        if not s:
            return 0

        if s == s[::-1]:
            return len(s)

        dp = [[0] * len(s) for i in range(len(s))]

        for l in range(len(s)-1, -1, -1):   
            dp[l][l] = 1
            for r in range(l + 1, len(s)):
                if s[l] == s[r]:
                    dp[l][r] = 2 + dp[l+1][r-1]            
                else:
                    dp[l][r] = max(dp[l+1][r], dp[l][r-1])
        
        for array in dp:
            print(array)
            
        return dp[0][len(s)-1]
```


```python
o = Solution()
s= 'bbbab'
o.longestPalindromeSubseq(s)

```

    [1, 2, 3, 3, 4]
    [0, 1, 2, 2, 3]
    [0, 0, 1, 1, 3]
    [0, 0, 0, 1, 1]
    [0, 0, 0, 0, 1]





    4




```python
o = Solution()
s = "cbbd"
o.longestPalindromeSubseq(s)
```

    [1, 1, 2, 2]
    [0, 1, 2, 2]
    [0, 0, 1, 1]
    [0, 0, 0, 1]





    2




```python
class Solution:
    def longestPalindromeSubseq(self, s):
        if not s:
            return 0
        
        if s == s[::-1]:
            return len(s)
        
        dp = [[0] * len(s) for i in range(len(s))]
        for r in range(len(s)):
            dp[r][r] = 1
            for l in range(r-1, -1, -1):
                if s[l] == s[r]:
                    dp[l][r] = 2 + dp[l+1][r-1]            
                else:
                    dp[l][r] = max(dp[l+1][r], dp[l][r-1])
        
        for array in dp:
            print(array)
        return dp[0][len(s)-1]
    
o = Solution()
s= 'bbbab'
o.longestPalindromeSubseq(s)
```

    [1, 2, 3, 3, 4]
    [0, 1, 2, 2, 3]
    [0, 0, 1, 1, 3]
    [0, 0, 0, 1, 1]
    [0, 0, 0, 0, 1]





    4




```python
o = Solution()
s = "cbbd"
o.longestPalindromeSubseq(s)
```

    [1, 1, 2, 2]
    [0, 1, 2, 2]
    [0, 0, 1, 1]
    [0, 0, 0, 1]





    2



## 1143. Longest Common Subsequence (String. Matrix. DP-Iteration) (Amazon 4, Microsoft 3)


```python
# O(N^2)
# O(N^2)
# dp[i][j]代表s1[i]和s2[j]之前的longest common subsequence
def longest_common_subsequence(s1, s2):

    m = len(s1)
    n = len(s2)
    
    dp = [[0] * (n + 1) for i in range(m + 1)]

    for i, c1 in enumerate(s1):
        for j, c2 in enumerate(s2):
            if c1 == c2:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            
            else:
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
                
#     for x in dp:
#         print(x)
    return dp[m - 1][n - 1]

s1 = "TERRACED"
s2 = "CRATERED"

longest_common_subsequence(s1, s2)
```

    [0, 0, 0, 1, 1, 1, 1, 1, 0]
    [0, 0, 0, 1, 2, 2, 2, 2, 0]
    [0, 1, 1, 1, 2, 3, 3, 3, 0]
    [0, 1, 1, 1, 2, 3, 3, 3, 0]
    [0, 1, 2, 2, 2, 3, 3, 3, 0]
    [1, 1, 2, 2, 2, 3, 3, 3, 0]
    [1, 1, 2, 2, 3, 3, 4, 4, 0]
    [1, 1, 2, 2, 3, 3, 4, 5, 0]
    [0, 0, 0, 0, 0, 0, 0, 0, 0]





    5



## 97. Interleaving String (String. DP-Matrix) (Apple 8, Amazon 8, Microsoft 3)  (Hard)
O(m*n)  
O(m*n)    
dp[i][j]代表s1的前i个字符和s2的前j个字符合起来是否能够组成s3的前i+j个字符  
中文leetcode题解


```python
class Solution:
    def isInterleave(self, s1, s2, s3):
        """
        :type s1: str
        :type s2: str
        :type s3: str
        :rtype: bool
        """
        if len(s1) + len(s2) != len(s3):
            return False
        
        dp = [[False] * (len(s2)+1) for i in range(len(s1)+1)]
        dp[0][0] = True
        
        for i in range(1, len(s1) + 1):
            if s1[i-1] == s3[i-1]:
                dp[i][0] = True
            else:
                break
                
        for j in range(1, len(s2)+1):
            if s2[j-1] == s3[j-1]:
                dp[0][j] = True
            else: # 前面都不符合了，后面肯定不符合了
                break
                
        for i in range(1, len(s1)+1):
            for j in range(1, len(s2)+1):
                if (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1]):
                    dp[i][j] = True
        return dp[-1][-1]
```

## 44. Wildcard Matching (String. DP-Matrix) (Google 4->0, Microsoft Onsite 2->6, Amazon 4)


```python
# O(N^2)  
# O(N^2)  
# dp[i][j]表示based string(i, j)是不是match
class Solution():
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """        
        dp = [[False] * (len(p) + 1) for n in range(len(s) + 1)]
        dp[-1][-1] = True
        
        for j in range(len(p)):
            if p[j] == "*":
                dp[-1][j] = dp[-1][j - 1]

        for i in range(len(s)):
            for j in range(len(p)):
                if (s[i] == p[j] or p[j] == "?"):
                    dp[i][j] = dp[i - 1][j - 1]
                    
                elif p[j] == "*":
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
        
        # print(dp)
        return dp[len(s)-1][len(p)-1]
    
s = Main()
s.isMatch('aa', '*')
```

    [[False, False], [False, False], [False, False]]
    [True, False]
    [True, False]
    [True, True]





    True




```python
# O(N^2)  
# O(N^2)  
# dp[i][j]表示based string(i-1, j-1)是不是match
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        if not s and not p:
            return True
        
        dp = [[False] * (len(p) + 1) for n in range(len(s) + 1)]
        dp[0][0] = True
        
        for j in range(1, len(p) + 1):
            if p[j - 1] == "*":
                dp[0][j] = dp[0][j - 1]

        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if (s[i - 1] == p[j - 1] or p[j - 1] == "?"):
                    dp[i][j] = dp[i - 1][j - 1]
                    
                elif p[j - 1] == "*":
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
        
        for n in dp:    
            print(n)
        return dp[-1][-1]
    
o = Solution()
o.isMatch('aa', '*')
```

    [True, True]
    [False, True]
    [False, True]





    True




```python
class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = True
        
        for j in range(1, len(p) + 1):
            if p[j - 1] == "*":
                dp[0][j] = dp[0][j - 1]

        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if (s[i - 1] == p[j - 1] or p[j - 1] == "?") and dp[i-1][j-1]:
                    dp[i][j] = True
                
                elif p[j - 1] == "*" and (dp[i - 1][j] or dp[i][j - 1]):
                    dp[i][j] = True
                    
        return dp[-1][-1]
```

## 10. Regular Expression Matching (String. DP-Matrix. DP, DFS-Dic, Recursion) (Facebook 8, Microsoft 7, Google 6, Amazon 6->3) (Hard)


```python
# dp[i][j]表示s[:i+1] p[:j+1]是不是match
class Solution():
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """    
        dp = [[False] * (len(p) + 1) for n in range(len(s) + 1)]
        
        dp[-1][-1] = True
                
        for j in range(len(p)):
            if p[j] == "*" and dp[-1][j-2]:
                dp[-1][j] = True

        for i in range(len(s)):
            for j in range(len(p)):
                if s[i] == p[j] or p[j] == ".":                    
                    dp[i][j] = dp[i - 1][j - 1]
                       
                elif p[j] == "*":
                    if s[i] == p[j-1] or p[j-1] == '.':
                        dp[i][j] = dp[i-1][j] or dp[i][j-2]
                    
                    elif s[i] != p[j-1]:
                        dp[i][j] = dp[i][j-2]
                
#                     if s[i] != p[j-1] and p[j-1] != '.':
#                         dp[i][j] = dp[i][j-2]
#                     else:
#                         dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i][j-2]

                        # x a
                        # a *
        
        # print(dp)
        return dp[len(s)-1][len(p)-1]
```


```python
# dp[i][j]表示text[i:] pattern[j:]是不是match
class Solution:
    def isMatch(self, text, pattern):
            """
            :type s: str
            :type p: str
            :rtype: bool
            """
            dic = {} 

            def dp(i, j):
                if (i, j) in dic: 
                    return dic[(i, j)]

                if j == len(pattern): 
                    return i == len(text)

                if i <= len(text) - 1 and (pattern[j] == text[i] or pattern[j] == '.'):
                    if j <= len(pattern) - 2 and pattern[j + 1] == '*':         
                        dic[(i, j)] = dp(i, j + 2) or dp(i + 1, j)
                    else:
                        dic[(i, j)] = dp(i + 1, j + 1)

                else:
                    if j <= len(pattern) - 2 and pattern[j + 1] == '*':
                        dic[(i, j)] = dp(i, j + 2) or False
                    else:
                        dic[(i, j)] = False

                return dic[(i, j)]

            return dp(0, 0)
```


```python
class Solution:
#     def isMatch(self, s, p):
#         dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]

#         dp[-1][-1] = True
        
#         for i in range(len(s), -1, -1):
#             for j in range(len(p) - 1, -1, -1):
#                 print(i,j)
#                 first_match = i < len(s) and p[j] in {s[i], '.'}
#                 if j+1 < len(p) and p[j+1] == '*':
#                     dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]
#                 else:
                    
#                     dp[i][j] = first_match and dp[i+1][j+1]
                    
#                     print(dp[i][j])

#         return dp[0][0]
    
    # 带备忘录的递归
    # Top Down
    def isMatch(self, text, pattern):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        
        dic = {} # 备忘录
        
        def dp(i, j):
            if (i, j) in dic: 
                return dic[(i, j)]
            
            if j == len(pattern): 
                return i == len(text)

            first = i <= len(text) - 1 and (pattern[j] == text[i] or pattern[j] == '.')

            if j <= len(pattern) - 2 and pattern[j + 1] == '*':
                dic[(i, j)] = dp(i, j + 2) or first and dp(i + 1, j)
            else:
                dic[(i, j)] = first and dp(i + 1, j + 1)

#             print(dic)
            return dic[(i, j)]

        return dp(0, 0)

    # # 暴力递归
    # def isMatch(text, pattern) -> bool:
    #     if not pattern: return not text

    #     first = bool(text) and pattern[0] in {text[0], '.'}

    #     if len(pattern) >= 2 and pattern[1] == '*':
    #         return isMatch(text, pattern[2:]) or \
    #                 first and isMatch(text[1:], pattern)
    #     else:
    #         return first and isMatch(text[1:], pattern[1:])
```


```python
text = 'aab'
pattern = 'c*a*b' 

s= Solution()
s.isMatch(text, pattern)
```

    {(0, 4): False}
    {(0, 4): False, (1, 4): False}
    {(0, 4): False, (1, 4): False, (2, 4): True}
    {(0, 4): False, (1, 4): False, (2, 4): True, (2, 2): True}
    {(0, 4): False, (1, 4): False, (2, 4): True, (2, 2): True, (1, 2): True}
    {(0, 4): False, (1, 4): False, (2, 4): True, (2, 2): True, (1, 2): True, (0, 2): True}
    {(0, 4): False, (1, 4): False, (2, 4): True, (2, 2): True, (1, 2): True, (0, 2): True, (0, 0): True}





    True



## 72. Edit Distance  (String. 1-Matrix. DP-Iteration. 2- Dic. DP, DFS-Recursion) (Microsoft 3->0, Amazon 2->9, Google 6)

Bottom Up


```python
# O(mn)
# O(mn)
# dp(i,j)表示最少操作数量
class Solution():
    def minDistance(self, s1, s2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        dp = [[0] * (len(s2) + 1) for n in range(len(s1) + 1)]
        # 第一行
        for j in range(len(s2)):
            dp[-1][j] = dp[-1][j-1] + 1
        # 第一列
        for i in range(len(s1)):
            dp[i][-1] = dp[i-1][-1] + 1
            
        for i in range(len(s1)):
            for j in range(len(s2)):
                if s1[i] == s2[j]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1 
                    # 插入 dp[i][j-1]  a,b -> ab, b -> a, '' (0, -1)
                    # 删除 dp[i-1][j] a,b -> '', b (-1, 0)
                    # 替换 
        #print(dp)      
        return dp[len(s1)-1][len(s2)-1]
```


```python
class Solution:
    def minDistance(self, s1, s2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """

        dp = [[0] * (len(s2) + 1) for n in range(len(s1) + 1)]
        # 第一行
        for j in range(1, len(s2) + 1):
            dp[0][j] = dp[0][j-1] + 1
        # 第一列
        for i in range(1, len(s1) + 1):
            dp[i][0] = dp[i-1][0] + 1
            
        for i in range(1, len(s1) + 1):
            for j in range(1, len(2) + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1
        #print(dp)      
        return dp[-1][-1]
```


```python
class Solution:
    def minDistance(self, s1, s2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """

        dic = {} # 备忘录
        def dp(i, j):
            if (i, j) in dic: 
                return dic[(i, j)]
            
            if i == len(s1): 
                return len(s2) - j 
            if j == len(s2): 
                return len(s1) - i 

            if s1[i] == s2[j]:
                dic[(i, j)] = dp(i + 1, j + 1) 
            else:
                dic[(i, j)] = min(dp(i, j + 1) + 1,    # 插入
                                  dp(i + 1, j) + 1,    # 删除
                                  dp(i + 1, j + 1) + 1) # 替换
                                  
                
            return dic[(i, j)]

        return dp(0, 0)
```


```python
# class Solution:
    # def minDistance(self, word1: str, word2: str) -> int:
        
#     def minDistance(self, s1, s2) -> int:

#         def dp(i, j):
#             # base case
#             if i == -1: return j + 1
#             if j == -1: return i + 1

#             if s1[i] == s2[j]:
#                 return dp(i - 1, j - 1)  # 啥都不做
#             else:
#                 return min(
#                     dp(i, j - 1) + 1,    # 插入
#                     dp(i - 1, j) + 1,    # 删除
#                     dp(i - 1, j - 1) + 1 # 替换
#                 )

#         # i，j 初始化指向最后一个索引
#         return dp(len(s1) - 1, len(s2) - 1)

# base case 是 i 走完 s1 或 j 走完 s2，可以直接返回另一个字符串剩下的长度。  
# Up Down

# dp(i,j)表示改变的s1 i之前 和s2 j之前的最少编辑次数
class Solution:
    def minDistance(self, s1, s2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """

        dic = {} # 备忘录
        def dp(i, j):
            if (i, j) in dic: 
                return dic[(i, j)]
            
            if i == -1: 
                return j + 1
            if j == -1: 
                return i + 1

            if s1[i] == s2[j]:
                dic[(i, j)] = dp(i - 1, j - 1) 
            else:
                dic[(i, j)] = min(dp(i, j - 1) + 1,    # 插入
                                  dp(i - 1, j) + 1,    # 删除
                                  dp(i - 1, j - 1) + 1 # 替换
                                  )
                
            return dic[(i, j)]

        return dp(len(s1) - 1, len(s2) - 1)
```

### Dic. DP-DFS-Recursion. O(N^2) O(N^2)

## 140. Word Break II (String. Dic. DP, DFS-Recursion) (Amazon 23, Facebook 13, Microsoft Onsite 4, Google 4, Apple 5)


```python
# O(n^3)
# O(n^3)
# Pre order + Post order
class Solution:
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """
        dic = {}
         
        def dp(s):
            if s in dic: 
                return dic[s]
            
#             if not s: 
#                 return []

            res = []
            for word in wordDict:
                if s.startswith(word):          
                    if len(word) == len(s):
                        res.append(word)
                    
                    else:
                        for item in dp(s[len(word):]):
                            res.append(word + ' ' + item)
                        
            dic[s] = res
            return dic[s]        
        return dp(s)
```


```python
class Solution:
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """
        res = []

        def dfs(idx, tmp_res):
            if idx == len(s):
                res.append(tmp_res[:-1])
            if not self.check(s[idx:], wordDict):
                return
            for i in range(idx+1, len(s)+1):
                if s[idx:i] in wordDict:
                    dfs(i, tmp_res+s[idx:i]+' ')

        dfs(0, '')
        return res

    def check(self, s, wordDict):
        ok = [True]
        for i in range(1, len(s) + 1):
            ok += any(ok[j] and s[j:i] in wordDict for j in range(i)),
        return ok[-1]
```

## 472. Concatenated Words (String List. Dic. DP, DFS-Recursion) (Amazon 24, Apple 4)


```python
# O(n^2)
# O(n^2)
class Solution:
    def findAllConcatenatedWordsInADict(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        words = set(words)
        result = []
        
        memo = {}
        
        def dp(word):
            if word in memo:
                return memo[word]
            
            if not word:
                return True
            
            memo[word] = False
            for i in range(1, len(word) + 1):
                if word[:i] in words and dp(word[i:]):
				    # update the set along checking
                    #words.add(word)
                    memo[word] = True
                    
            return memo[word]
        
        for word in words:
		    # this range avoids checking the whole word in the valid set
            for i in range(1, len(word)):
                if word[:i] in words and dp(word[i:]):
                    result.append(word)
                    break
                    
        return result
```


```python
words = ['abc', 'abc', 'ccc']
set(words)
```




    {'abc', 'ccc'}



## 416. Partition Equal Subset Sum (List. Dic. DP, DFS-Recursion) (Facebook 7, Amazon 2, Google 2, Microsoft)


```python
class Solution:    
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        
        s = sum(nums)
        if s % 2 != 0: 
            return False
        
        length = len(nums)
        dic = {}
        
        def canFindSum(target, index):
            if target in dic:
                return dic[target] 
            
            if target == 0:
                dic[target] = True
                return

            dic[target] = False
            if target > 0:
                for i in range(index, length):
                    if canFindSum(target - nums[i], i+1):
                        dic[target] = True
                        break

            return dic[target]
        
        return canFindSum(s//2, 0)
```


```python
class Solution:    
    def canPartition(self, nums):
        """
        array
        boolean
        """
        sums = sum(nums)
        if sums % 2:
            return False
        half = sums // 2
        
        dp = [[False] * (half + 1) for i in range(len(nums) + 1)]
        for i in range(len(dp)):
            dp[i][0] = True
        
        for i in range(1, len(dp)):
            for j in range(1, len(dp[0])):
                if nums[i - 1] > j:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] 
        return dp[-1][-1]
```

### (18) (String) List, Matrix. Recursion, DFS, Backtrack

### Recursion

## 50. Pow(x, n) (Recursion) (Facebook 9, Linkedin 7, Amazon 6)

O(logn)  
O(logn)


```python
class Solution:
    def myPow(self, x, n):
        if n == 0:
            return 1
        if n < 0:
            return 1 / self.myPow(x, -n)
        
        if n % 2:
            return x * self.myPow(x, n - 1)

        return self.myPow(x * x, n // 2)
```


```python
class Solution:
    def myPow(self, x, n):
        if n < 0:
            x = 1 / x
            n = -n
        pow = 1
        while n:
            if n & 1:
                pow *= x
            x *= x
            n >>= 1
        return pow
```

## 66. Plus One (Recursion) (Google 4, Amazon 3)


```python
class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        if not digits:
            return [1]
        
        if digits[-1] < 9:
            digits[-1] += 1
            return digits
        
        else:
            return self.plusOne(digits[:-1]) + [0]
```


```python
class Solution(object):
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        n = len(digits)
        
        # move along the input array starting from the end
        for i in range(n):
            idx = n - 1 - i
            # set all the nines at the end of array to zeros
            if digits[idx] == 9:
                digits[idx] = 0
            # here we have the rightmost not-nine
            else:
                # increase this rightmost not-nine by 1 
                digits[idx] += 1
                # and the job is done
                return digits
                
        # we're here because all the digits are nines
        return [1] + digits
```

### (String) List. DFS-Recursion. O(2^N) O(2^N)

## Rhyme Schemes (Google Phone)


```python
def find_rythm(n):
    ans = []
    def backtrack(rythm = ''):
        if len(rythm) == n:
            convert = ''
            for c in rythm:
                convert += chr(int(c)+64)
            ans.append(convert)
            return
        
        max_val = 1 + max([int(num) for num in rythm]) if rythm else 1
        
#         max_val = max([int(num) for num in rythm] or [0])+1
        for i in range(1, max_val + 1):
            backtrack(rythm + str(i))
            
    backtrack()
    return ans

print(find_rythm(2))
```

    ['AA', 'AB']



```python
ord('1')
```




    49



## 22. Generate Parenthesis (DFS-Recursion) (Amazon OA 12, Microsoft Onsite 11, Facebook 7, Apple 4)

时间复杂度: O(4^N / sqrt(N))

https://xiaozhuanlan.com/topic/3421690578  
以Generate Parentheses为例，backtrack的题到底该怎么去思考？
所谓Backtracking都是这样的思路：在当前局面下，你有若干种选择。那么尝试每一种选择。如果已经发现某种选择肯定不行（因为违反了某些限定条件），就返回；如果某种选择试到最后发现是正确解，就将其加入解集

所以你思考递归题时，只要明确三点就行：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。即“ORT原则”（这个是我自己编的）

对于这道题，在任何时刻，你都有两种选择：

加左括号。
加右括号。
同时有以下限制：

如果左括号已经用完了，则不能再加左括号了。
如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。
结束条件是：
左右括号都已经用完。

结束后的正确性：
左右括号用完以后，一定是正确解。因为1. 左右括号一样多，2. 每个右括号都一定有与之配对的左括号。因此一旦结束就可以加入解集（有时也可能出现结束以后不一定是正确解的情况，这时要多一步判断）。

递归函数传入参数：
限制和结束条件中有“用完”和“一样多”字样，因此你需要知道左右括号的数目。
当然你还需要知道当前局面sublist和解集res。



```python
class Solution:
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        if not n:
            return ['']
  
        def dfs(s = '', l = 0, r = 0):
            if len(s) == 2 * n:
                res.append(s)
                return
                
            if l < n:
                dfs(s + '(', l + 1, r)
            if r < l:
                dfs(s + ')', l, r + 1)
        
        res = []
        dfs()
        return res
```

## 17. Letter Combinations (String List. DFS-Recursion) (Amazon Onsite 13-1, Microsoft 7, Apple 2, Google 6, Uber 5)

O(3^N x 4^M) where N is the number of digits in the input that maps to 3 letters (e.g. 2, 3, 4, 5, 6, 8) and M is the number of digits in the input that maps to 4 letters (e.g. 7, 9), and N+M is the total number digits in the input.  
O(3^N x 4^M)


```python
class Solution:
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        dic = {
            '2':['a','b','c'],
            '3':['d','e','f'],
            '4':['g','h','i'],
            '5':['j','k','l'],
            '6':['m','n','o'],
            '7':['p','q','r','s'],
            '8':['t','u','v'],
            '9':['w','x','y','z']
        }
        
        if not digits:
            return []
        
        def dfs(digits, s = ''):
            if not digits:
                res.append(s)
                return

            for c in dic[digits[0]]:
                dfs(digits[1:], s+c)
                
        res = []
        dfs(digits)
        return res
```

## 1087. Brace Expansion (List. DFS-Recursion) (Google 6)


```python
class Solution:
    def expand(self, S):
        """
        :type S: str
        :rtype: List[str]
        """
        res = []
        def backtrack(s, word = ''):
            if not s:
                res.append(word)
                return

            if s[0] == "{":
                i = s.find("}")
                for letter in s[1:i].split(','):
                    backtrack(s[i+1:], word+letter)
            else:
                backtrack(s[1:], word + s[0])
                    
        backtrack(S)   
        return sorted(res)
```


```python
s = Solution()
S = 'a_{cat,dog}_is_with_{sarah,mike}'
s.expand(S)
```




    ['a_cat_is_with_sarah',
     'a_cat_is_with_mike',
     'a_dog_is_with_sarah',
     'a_dog_is_with_mike']



## 39. (3) Combination Sum (List, DFS-Recurison) (Airbnb 10, Microsoft 7, Amazon 5)

![image.png](attachment:image.png)


```python
class Solution:
    def combinationSum(self, nums, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """     
        
        # nums should be sorted
        def dfs(sums = 0, path = [], index = 0):    
            if sums == target:
                res.append(path)
                return 
            
#             if target < 0:
                # return  # backtracking
            
            if sums < target:
                for i in range(index, len(nums)):
                    dfs(sums + nums[i], path+[nums[i]], i)
        
        res = []
        dfs()
        return res

```


```python
class Solution:
    def combinationSum(self, nums, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """     
        
        # nums should be sorted
        
        def dfs(target, path = [], index = 0):    
            if target == 0:
                res.append(path)
                return 
            
#             if target < 0:
#                 return  # backtracking
            
            if target > 0:
                for i in range(index, len(nums)):
                    dfs(target-nums[i], path+[nums[i]], i)
        
        res = []
        dfs(target)
        return res
    
        def dfs(sums = 0, path = [], index = 0):    
            if sums == target:
                res.append(path)
                return 
            
#             if target < 0:
                # return  # backtracking
            
            if sums < target:
                for i in range(index, len(nums)):
                    dfs(sums + nums[i], path+[nums[i]], i)
        
        res = []
        dfs()
        return res
```


```python
l1 = [1,2,3]
l1.append([5,6])
l1
```




    [1, 2, 3, [5, 6]]



## 40. Combination Sum II (List. DFS-Recursion) (Microsoft Onsite 3)


```python
class Solution():
    def combinationSum2(self, nums, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def dfs(sums = 0, path = [], index = 0):
            if sums == target:
                res.append(path)
                return
            
            if sums < target:
                for i in range(index, len(nums)):
                    if i > index and nums[i] == nums[i-1]:
                        continue

                    dfs(sums + nums[i], path+[nums[i]], i+1)
          
        nums.sort()
        res = []
        dfs()
        return res
```


```python
class Solution():
    def combinationSum2(self, nums, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def dfs(target, path = [], index = 0):
            if target == 0:
                res.append(path)
            
            if target < 0:
                return 
            
            for i in range(index, len(nums)):
                if i > index and nums[i] == nums[i-1]:
                    continue
                    
                dfs(target - nums[i], path+[nums[i]], i+1)
          
        nums.sort()
        res = []
        dfs(target)
        return res
```


```python
class Solution():
    def combinationSum2(self, nums):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        def dfs(path = [], index = 0):
            print(path)
            
            
            for i in range(index, len(nums)):
                if i > index and nums[i] == nums[i-1]:
                    continue
                    
                dfs(path+[nums[i]], i+1)
          
        nums.sort()
        dfs()

nums = [1, 2, 3]
s = Solution()
s.combinationSum2(nums)
```

    []
    [1]
    [1, 2]
    [1, 2, 3]
    [1, 3]
    [2]
    [2, 3]
    [3]


## 77. Combinations (Google 3, Microsoft 2)


```python
class Solution:
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        
        array = [n for n in range(1, n + 1)]
              
        def dfs(path, index):
            if len(path) == k:
                res.append(path)
                return
                
            for i in range(index, n):
                dfs(path + [array[i]], i + 1)
    
        res = []
        dfs([], 0)
        return res
```


```python
class Solution:
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        
        def dfs(cur_nums, idx):
            if len(cur_nums) == k:
                res.append(cur_nums)
                return
            if idx == n + 1:
                return
            dfs(cur_nums+[idx], idx+1)
            dfs(cur_nums, idx+1)
        
        res = []      
        dfs([], 1)
        return res
```

## 78. Subsets (List. DFS-Recursion, BFS-Queue) (Facebook 8, Amazon 6, Microsoft 5)


```python
# O(N*2^N)  
# O(N*2^N)
class Solution:
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """    
        def dfs(path, index):
            res.append(path)
            
            for i in range(index, len(nums)):
                dfs(path + [nums[i]], i + 1)
            
        res = []
        dfs([], 0)
        return res 
```


```python
#BFS
class Solution:
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """    
        subsets = [[]]
        # start by adding the empty subset
        for n in nums:
        # we will take all existing subsets and insert the current number in them to create new subsets
            for i in range(len(subsets)):
              # create a new subset from the existing subset and insert the current element to it
              # set = list(subsets[i])
              # set.append(currentNumber)
              subsets.append(subsets[i]+[n])

        return subsets
```


```python
#O(2^N)
class Solution:
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = [[]]
        for n in nums:
            res.extend([[n] + num for num in res])
        return res 
```


```python
nums = [1,2,3]
s = Solution()
s.subsets(nums)
```




    [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]




```python
[1,3] + [3]
```

## 90. Subsets II (Amazon 3, Microsoft 2)


```python
class Solution():
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        def dfs(path, index):
            res.add(tuple(path))
            
            for i in range(index, len(nums)):
                if i > index and nums[i] == nums[i-1]:
                    continue
                dfs(path + [nums[i]], i + 1)
            
        nums.sort()
        res = set()
        dfs([], 0)

        return res
```


```python
# BFS
class Solution:
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """    
        nums.sort()
        subsets = [[]]
        visited = set()
        # start by adding the empty subset
        for n in nums:
        # we will take all existing subsets and insert the current number in them to create new subsets
            for i in range(len(subsets)):
              # create a new subset from the existing subset and insert the current element to it
              # set = list(subsets[i])
              # set.append(currentNumber)
                tmp = subsets[i] + [n]
 
                if tuple(tmp) not in visited:
                    visited.add(tuple(tmp))
                    subsets.append(tmp)
                
        return subsets
```


```python
dic = {(1,2):2}
tmp = set([1,2])
print(tmp)
if tmp in dic:
    print(1)
```

    {1, 2}



    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-13-08144693518c> in <module>
          2 tmp = set([1,2])
          3 print(tmp)
    ----> 4 if tmp in dic:
          5     print(1)


    TypeError: unhashable type: 'set'



```python
s = set()
set.add([1,2])
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-4-6e53d1607f83> in <module>
          1 s = set()
    ----> 2 set.add([1,2])
    

    TypeError: descriptor 'add' requires a 'set' object but received a 'list'


## 46. (2) Permutations (List. DFS-Recursion, BFS-Queue) (Amazon 7, Facebook 6)  
O(n x n!)   
O(N!)

<img src="Screen Shot 2019-10-22 at 4.00.20 PM.png">


```python
class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        def dfs(nums, path):
            if not nums:
                res.append(path)
                # return # backtracking
            for i in range(len(nums)):
                dfs(nums[:i]+nums[i+1:], path+[nums[i]])

        
        res = []
        dfs(nums, [])
        return res
```


```python
class Solution:
    def permute(self, nums):
        result = []
        queue = [[]]

        for n in nums:
            # we will take all existing permutations and add the current number to create new permutations

            for i in range(len(queue)):
                old = queue.pop(0)
                # create a new permutation by adding the current number at every position
#                 print(old)
                
                for j in range(len(old)+1):
                    new = old.copy()
#                     print(new)
                    new.insert(j, n)
#                     print(new)
                    if len(new) != len(nums):
                        queue.append(new)
                    else:
                        result.append(new)

        return result
```


```python
array = []
len(array)
```




    0




```python
def generate_permutations(nums):
    result = []
    generate_permutations_recursive(nums, 0, [], result)
    return result


def backtrack(nums, index, currentPermutation, result):
    if index == len(nums):
        result.append(currentPermutation)
    else:
        # create a new permutation by adding the current number at every position
        for i in range(len(currentPermutation)+1):
            newPermutation = list(currentPermutation)
            newPermutation.insert(i, nums[index])
            backtrack(nums, index + 1, newPermutation, result)
```


```python
class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums:
            return [[]]
        
        
        def backtrack(first):
            # if all integers are used up
            if first == len(nums):  
                res.append(nums[:])
                return
                
            for i in range(first, len(nums)):
                # place i-th integer first 
                # in the current permutation
                nums[first], nums[i] = nums[i], nums[first]
                # use next integers to complete the permutations
                backtrack(first + 1)
                # backtrack
                nums[first], nums[i] = nums[i], nums[first]
        
        res = []
        backtrack(0)
        return res
```


```python
nums = [1,2,3]
nums2 = [4,5,6]
nums.append(nums2)
nums
```




    [1, 2, 3, [4, 5, 6]]



## 47. Permutations II (Amazon 3, Microsoft Onsite 1, 2)


```python
class Solution():
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        def dfs(nums, path):
            if not nums:
                res.add(tuple(path))

            for i in range(len(nums)):
                dfs(nums[:i]+nums[i+1:], path+[nums[i]])

        res = set()
        dfs(nums, [])
        return res
```


```python
class Solution():
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = set()
        queue = [[]]

        for n in nums:
            # we will take all existing permutations and add the current number to create new permutations

            for i in range(len(queue)):
                old = queue.pop(0)
                # create a new permutation by adding the current number at every position
#                 print(old)
                
                for j in range(len(old)+1):
                    new = old.copy()
#                     print(new)
                    new.insert(j, n)
#                     print(new)
                    if len(new) != len(nums):
                        queue.append(new)
                    else:
                        res.add(tuple(new))

        return res
```

## 93. Restore IP Addresses (String. Recursion-Backtracking) (Microsoft Onsite 1, 4, Amazon 3->6)  
O(2^N)  
O(1)


```python
class Solution:
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        if len(s) > 12 or len(s) < 4:
            return []

        def isValid(ip):
            if ip.count('.') != 3:
                return False
            
            array = ip.split('.')
            for num in array:
                if not num or int(num) > 255 or (len(num) > 1 and num[0] == '0'):
                    return False
            return True

        res = []
        def backtrack(cur, idx, cnt):
            if cnt == 3:
                if isValid(cur):
                    res.append(cur)
                return
            
            if idx > len(cur) - 1:
                return
            
            backtrack(cur[:idx] + '.' + cur[idx:], idx + 2, cnt+1)
            backtrack(cur, idx+1, cnt)

        backtrack(s, 0, 0)
        return res
```

## 24 Game (List. DFS-Recursion) (Google 5, Microsoft 4)


```python
class Solution:
    def judgePoint24(self, nums):
        
        if not nums:
            return False
        
        if len(nums) == 1:
            return 23.9 <= nums[0] <= 24.1
        
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                a = nums[i]
                b = nums[j]
                new_arr = nums[:i] + nums[i + 1:j] + nums[j + 1:]
                
                for num in [a + b, a - b, b - a, a * b, a and b / a, b and a / b]:
                    if self.judgePoint24(new_arr + [num]):
                        return True
        return False
```

### (String) Matrix. List, parameter. DFS-Recursion, (Backtracking) 

## 733. Flood Fill (Amazon 14)


```python
# O(m*n)
# O(m*n)

class Solution():
    def floodFill(self, image, sr, sc, newColor):
        m = len(image)
        n = len(image[0])
        
        color = image[sr][sc]
        
        if color == newColor: 
            return image
        
        def dfs(i, j):
#             if i < 0 or i >= m or j < 0 or j >= n or image[i][j] != color:
#                 return

            if 0 <= i < m and 0 <= j < n and image[i][j] == color:
                
                image[i][j] = newColor
                dfs(i-1, j)
                dfs(i + 1, j)
                dfs(i, j - 1)
                dfs(i, j + 1)
        
        dfs(sr, sc)
        return image
```


```python
class Solution():
    def floodFill(self, image, sr, sc, newColor):
        m = len(image)
        n = len(image[0])
        
        color = image[sr][sc]
        
        if color == newColor: 
            return image
        
        def dfs(i, j):
            if image[i][j] == color:
                image[i][j] = newColor
                
                if i >= 1: 
                    dfs(i-1, j)
                if i + 1 < m:
                    dfs(i + 1, j)
                if j >= 1:
                    dfs(i, j - 1)
                if j + 1 < n:
                    dfs(i, j + 1)
        
        dfs(sr, sc)
        return image
```

## 200. Number of Island (String Matrix. DFS-Recursion) (Amazon 75, Google 15, Microsoft 12)

O(N*M)  
O(N*M)


```python
class Solution:
    def numIslands(self, matrix):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not matrix:
            return 0
        
        m = len(matrix)
        n = len(matrix[0])

        def dfs(i, j):
#             if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] != '1':
#                 return
        
            if 0 <= i < m and 0 <= j < n and matrix[i][j] == '1':
                matrix[i][j] = '#'
                dfs(i+1, j)
                dfs(i-1, j)
                dfs(i, j+1)
                dfs(i, j-1)
                
        
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dfs(i, j)
                    res += 1
        return res
```


```python
grid = [[1,1,0,0,0],
        [1,1,0,0,0],
        [0,0,1,0,0],
        [0,0,0,1,1]]

print(len(grid))

for i in range(len(grid)):
    for j in range(len(grid[0])):
        print(grid[i][j])
```

    4
    1
    1
    0
    0
    0
    1
    1
    0
    0
    0
    0
    0
    1
    0
    0
    0
    0
    0
    1
    1



```python
class Solution:
    def numIslands(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        
        m = len(matrix)
        n = len(matrix[0])

        def dfs(i, j):
            matrix[i][j] = '#'

            for direction in [(1,0),(-1,0),(0,1),(0,-1)]:
                x, y = i + direction[0], j + direction[1]
                # if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j]:
                #     continue

                if 0 <= x < m and 0 <= y < n and matrix[x][y] == '1':
                    dfs(x, y)
                            
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dfs(i, j)
                    res += 1
        return res
```

## 695. Max Area of Island (Matrix. DFS-Recursion) (Microsoft Onsite, Amazon 5)


```python
# O(m*n)
# O(m*n)
class Solution:
    def maxAreaOfIsland(self, grid):
        """
        input: List[List[int]]
        output: int
        """
        if not grid:
            return 0
        
        m = len(grid)
        n = len(grid[0])
        
        res = 0
        
        # return area of (i,j) surround
        def dfs(i, j):
#             if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1:
#                 return 0
            
            if 0 <= i < m and 0 <= j < n and matrix[i][j] == 1:
                grid[i][j] = '#'
                return 1 + dfs(i-1, j) \
                         + dfs(i+1, j) \
                         + dfs(i, j-1) \
                         + dfs(i, j+1)
            
            else:
                return 0

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    area = dfs(i, j)
                    res = max(res, area)

        return res
```


```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        m = len(grid)
        n = len(grid[0])
        
        res = 0
        
        # return area of (i,j) surround
        def dfs(i, j):

            grid[i][j] = '#'

            count = 1

            for direction in [(1,0),(-1,0),(0,1),(0,-1)]:
                x, y = i + direction[0], j + direction[1]
                # if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j]:
                #     continue

                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                    count += dfs(x, y)

            return count

        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    area = dfs(i, j)
                    res = max(res, area)

        return res
```

## 694. Number of Distinct Islands (Amazon 16)


```python
# O(m*n)
# O(m*n)
class Solution():
    def numDistinctIslands(self, grid):
        m = len(grid)
        n = len(grid[0])
        
        def dfs(i, j, di = 0):
#             if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] != 1:
#                 return 
            
            if 0 <= i < m and 0 <= j < n and grid[i][j] == 1:
                grid[i][j] = '*'
                shape.append(di)
                dfs(i+1, j, 1)
                dfs(i-1, j, 2)
                dfs(i, j+1, 3)
                dfs(i, j-1, 4)
                shape.append(0)

        shapes = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    shape = []
                    dfs(i, j)
    #                 print(shape)

                    if shape:
                        shapes.add(tuple(shape))

        return len(shapes)
```


```python
s = Solution()
grid = [[1,1,0],[0,1,1],[0,0,0],[1,1,1],[0,1,0]]
s.numDistinctIslands(grid)
```

    [0, 3, 1, 3, 0, 0, 0, 0]
    []
    []
    []
    []
    []
    []
    []
    []
    [0, 3, 1, 0, 3, 0, 0, 0]
    []
    []
    []
    []
    []





    2



## 529. Minesweeper (Matrix. DFS-Recursion) (Uber 10, Amazon 4, Microsoft Onsite 3)


```python
# O(m*n)
# O(m*n)
class Solution:
    def updateBoard(self, board, click):
        """
        :type board: List[List[str]]
        :type click: List[int]
        :rtype: List[List[str]]
        """
        if not board:
            return []

        m, n = len(board), len(board[0])
        i, j = click[0], click[1]

        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == 'M':
            board[i][j] = 'X'
            return board

        
        def dfs(i, j):
            # if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'E':
            #     return
            if 0 <= i < m and 0 <= j < n and board[i][j] == 'E':   
                mine_count = 0

                for d in [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 'M':        
                        mine_count += 1

                if mine_count != 0:
                    board[i][j] = str(mine_count)
                    return

                board[i][j] = 'B'
                dfs(i+1, j)
                dfs(i+1, j+1)
                dfs(i+1, j-1)
                dfs(i-1, j)
                dfs(i-1, j-1)
                dfs(i-1, j+1)
                dfs(i, j+1)
                dfs(i, j-1)
                
        # run dfs to reveal the board
        dfs(i, j)
        return board 
```


```python
class Solution:
    def updateBoard(self, board, click):
        """
        :type board: List[List[str]]
        :type click: List[int]
        :rtype: List[List[str]]
        """
        if not board:
            return []

        m, n = len(board), len(board[0])
        i, j = click[0], click[1]

        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == 'M':
            board[i][j] = 'X'
            return board

        
        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'E':
                return
  
            mine_count = 0

            for d in [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]:
                ni, nj = i + d[0], j + d[1]
                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 'M':        
                    mine_count += 1

            if mine_count != 0:
                board[i][j] = str(mine_count)
                return
                
            board[i][j] = 'B'
            dfs(i+1, j)
            dfs(i+1, j+1)
            dfs(i+1, j-1)
            dfs(i-1, j)
            dfs(i-1, j-1)
            dfs(i-1, j+1)
            dfs(i, j+1)
            dfs(i, j-1)
                
        # run dfs to reveal the board
        dfs(i, j)
        return board 
```


```python
class Solution:
    def updateBoard(self, board, click):
        """
        :type board: List[List[str]]
        :type click: List[int]
        :rtype: List[List[str]]
        """
        if not board:
            return []

        m, n = len(board), len(board[0])
        i, j = click[0], click[1]

        # If a mine ('M') is revealed, then the game is over - change it to 'X'.
        if board[i][j] == 'M':
            board[i][j] = 'X'
            return board

        
        def dfs(board, i, j):
            if board[i][j] != 'E':
                return
     
            directions = [(-1,-1), (0,-1), (1,-1), (1,0), (1,1), (0,1), (-1,1), (-1,0)]

            mine_count = 0

            for d in directions:
                ni, nj = i + d[0], j + d[1]
                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 'M':        
                    mine_count += 1

            if mine_count == 0:
                board[i][j] = 'B'
            else:
                board[i][j] = str(mine_count)
                return

            for d in directions:
                ni, nj = i + d[0], j + d[1]
                if 0 <= ni < m and 0 <= nj < n:
                    dfs(board, ni, nj)
        
        # run dfs to reveal the board
        dfs(board, i, j)
        return board 
```

## 130. Surrounded Regions (String Matrix. DFS-Recursion) (Google 2->5, Amazon 5, Uber 2)


```python
# O(m*n)
# O(m*n)
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        
        m = len(board)
        n = len(board[0]) 
        
        def dfs(i, j):
            # 退出dfs的条件：1.走到boundary；2.遇到'X'
            # if i < 0 or i >= m or j < 0 or j >=n or board[i][j] != 'O': 
            #     return 
            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':   
                board[i][j] = '#' # 表示该元素已被访问

                dfs(i - 1, j)
                dfs(i + 1, j)
                dfs(i, j - 1)
                dfs(i, j + 1)
        
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0 or i == m - 1 or j == n - 1: # 点在boundary上
                    if board[i][j] == 'O': # 如果boundary上的元素为O,则进行dfs
                        dfs(i, j)
                        
        for i in range(m):
            for j in range(n):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                else:
                    board[i][j] = 'X'
                    
                    
```


```python
# 因为boundary上的'O'肯定不会被包围
# 主要思路就是对boundary上是'O'的元素进行DFS，然后只要碰到'O'就继续走下去，直到碰到'X'或者碰到boundary，然后将这些'O'全部mark一下，即用'#'来替代，
# 最后我们遍历整个board，如果是'#'就变回'O'，如果是'X'或者'O'就变成'X'。

class Solution:
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        
        if not board:
            return
        
        m = len(board)
        n = len(board[0]) 
        
        def dfs(i, j):
            # 退出dfs的条件：1.走到boundary；2.遇到'X'
            if i < 0 or i >= m or j < 0 or j >=n or board[i][j] != 'O': 
                return 
            
            board[i][j] = '#' # 表示该元素已被访问
            
            dfs(i - 1, j)
            dfs(i + 1, j)
            dfs(i, j - 1)
            dfs(i, j + 1)
        
        for i in range(row):
            for j in range(col):
                if i == 0 or j == 0 or i == row - 1 or j == col - 1: # 点在boundary上
                    if board[i][j] == 'O': # 如果boundary上的元素为O,则进行dfs
                        dfs(i, j)
                        
        for i in range(row):
            for j in range(col):
                if board[i][j] == '#':
                    board[i][j] = 'O'
                else:
                    board[i][j] = 'X'
```

51. N-Queens

## 79. Word Search (String Matrix. DFS-Recursion, Backtracking) (Amazon 15, Microsoft 8, Uber 7, Facebook 7)

![image.png](attachment:image.png)


```python
class Solution:
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        
        if not board:
            return False
        if not word:
            return True
        
        m = len(board)
        n = len(board[0])
        
        # check whether can find word, start at (i,j) position    
        def dfs(i, j, word):
            if not word: # all the characters are checked
                return True
            
            # if i < 0 or i >= m or j < 0 or j >= n or word[0] != board[i][j]:
            #     return False
            
            if 0 <= i < m and 0 <= j < n and board[i][j] == word[0]:   
            
                tmp = board[i][j]  # first character is found, check the remaining part
                board[i][j] = "#"  # avoid visit again 
                # check whether can find "word" along one direction
                res = dfs(i+1, j, word[1:]) or \
                      dfs(i-1, j, word[1:]) or \
                      dfs(i, j+1, word[1:]) or \
                      dfs(i, j-1, word[1:])
                board[i][j] = tmp
                return res
            
            else:
                return False
    
    
        for i in range(m):
            for j in range(n):
                if dfs(i, j, word):
                    return True
        return False

```


```python
# O(m*n)  
# O(1)

# Time Complexity: O(N4^L)where N is the number of cells in the board and L is the length of the word to be matched.
# For the backtracking function, its execution trace would be visualized as a 4-ary tree, 
# each of the branches represent a potential exploration in the corresponding direction. 
# Therefore, in the worst case, the total number of invocation would be the number of nodes in a full 4-nary tree, which is about 4^L

class Solution:
    def exist(self, board, word):
        if not board:
            return False
        if not word:
            return True
        
        m = len(board)
        n = len(board[0])
        
        # check whether can find word, start at (i,j) position    
        def dfs(i, j, word):
            if not word: # all the characters are checked
                return True
            
            if i < 0 or i >= m or j < 0 or j >= n or word[0] != board[i][j]:
                return False
            
            tmp = board[i][j]  # first character is found, check the remaining part
            board[i][j] = "#"  # avoid visit again 
            # check whether can find "word" along one direction
            res = dfs(i+1, j, word[1:]) or \
                  dfs(i-1, j, word[1:]) or \
                  dfs(i, j+1, word[1:]) or \
                  dfs(i, j-1, word[1:])
            board[i][j] = tmp
            return res
    
        for i in range(m):
            for j in range(n):
                if dfs(i, j, word):
                    return True
        return False

```


```python
class Solution:
    def exist(self, matrix, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        if not matrix:
            return False
        if not word:
            return True

        def backtrack(i, j, idx = 0):
            if idx == len(word):
                return True
            
            if i < 0 or i > m - 1 or j < 0 or j > n - 1 or matrix[i][j] != word[idx]:
                return False
               
            tmp = matrix[i][j]
            matrix[i][j] = '*'
            res = backtrack(i+1, j, idx+1) or \
                  backtrack(i, j+1, idx+1) or \
                  backtrack(i-1, j, idx+1) or \
                  backtrack(i, j-1, idx+1)
            matrix[i][j] = tmp
            return res
        
        m = len(matrix)
        n = len(matrix[0])
        for i in range(m):
            for j in range(n):
                if backtrack(i, j):
                    return True
        return False
```

## 212. Word Search II (String Matrix. DFS, Backtrack-Recursion) (Amazon 21, Facebook 5, Google 5, Uber 5, Microsoft Onsite 1, 5) (Hard)

时间复杂度: O(row * col * max_len(words))  
空间复杂度: O(N) total number of letters in the dictionary


```python
class Solution:
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        if not board or not words:
            return

        # build trie 
        trie = {}
        for word in words:
            t = trie
            for c in word:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t['#'] = {}
#         print('trie=',trie)

        def backtrack(i, j, trie, path):
            if '#' in trie:
                res.add(path)
                return
        
#             if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in trie:
#                 return
        
            if 0 <= i < m and 0 <= j < n and board[i][j] in trie:
                c = board[i][j]
                board[i][j] = '*' # backtracking
                backtrack(i + 1, j, trie[c], path + c)
                backtrack(i - 1, j, trie[c], path + c)
                backtrack(i, j + 1, trie[c], path + c)
                backtrack(i, j - 1, trie[c], path + c)
                board[i][j] = c
        
        res = set()
        
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                backtrack(i, j, trie, '')
        return list(res)
```


```python
class Solution:
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        if not board or not words:
            return

        # build trie 
        trie = {}
        for word in words:
            t = trie
            for c in word:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t['#'] = '#'
#         print('trie=',trie)

        def backtrack(i, j, trie, path):
            if '#' in trie:
                res.add(path)
            
            if i >= 0 and i < m and j >= 0 and j < n and board[i][j] in trie:
                c = board[i][j]
                board[i][j] = '*' # backtracking
                backtrack(i + 1, j, trie[c], path + c)
                backtrack(i - 1, j, trie[c], path + c)
                backtrack(i, j + 1, trie[c], path + c)
                backtrack(i, j - 1, trie[c], path + c)
                board[i][j] = c
        
        res = set()
        for i in range(len(board)):
            for j in range(len(board[0])):
                backtrack(i, j, trie, '')
        return list(res)
```


```python
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
s = Solution()
s.findWords(board, words)
```

    trie= {'o': {'a': {'t': {'h': {'#': '#'}}}}, 'p': {'e': {'a': {'#': '#'}}}, 'e': {'a': {'t': {'#': '#'}}}, 'r': {'a': {'i': {'n': {'#': '#'}}}}}





    ['oath', 'eat']



## 329. Longest Increasing Path in a Matrix (Matrix. DP, DFS-Recursion) (Google 4->7, Amazon 3, Facebook 4->3)


```python
# O(m*n)
# O(m*n)
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix: 
            return 0

        m = len(matrix)
        n = len(matrix[0])
        cache = {}

        def dfs(i, j):
            if (i, j) in cache:
                return cache[i, j]
            
            res = 1

            for direction in [(1,0),(-1,0),(0,1),(0,-1)]:
                x, y = i + direction[0], j + direction[1]
                # if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j]:
                #     continue

                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:
                    length = 1 + dfs(x, y)
                    res = max(length, res)

            cache[i, j] = res

            return res

        res = 0
        for i in range(m):
            for j in range(n):
                cur_len = dfs(i, j)
                res = max(res, cur_len)

        return res
```


```python
# O(m*n)  
# O(m*n)
# Postoder
class Solution:
    def longestIncreasingPath(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        if not matrix: 
            return 0
        
        dic = {}
        def dp(i, j):   
            if (i,j) in dic:
                return dic[i,j]
            
            dic[i,j] = 1 + max(
                dp(i - 1, j) if i > 0 and matrix[i][j] > matrix[i - 1][j] else 0,
                dp(i + 1, j) if i < m - 1 and matrix[i][j] > matrix[i + 1][j] else 0,
                dp(i, j - 1) if j > 0 and matrix[i][j] > matrix[i][j - 1] else 0,
                dp(i, j + 1) if j < n - 1 and matrix[i][j] > matrix[i][j + 1] else 0)

            return dic[i, j]
        
        m = len(matrix)
        n = len(matrix[0])
#         dp = [[0] * n for i in range(m)]
#         print('dp=',dp)
        
        res = 0
        for i in range(m):
            for j in range(n):
                res = max(res, dp(i, j))
        return res
```


```python
class Solution:
    def longestIncreasingPath(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        if not matrix: 
            return 0
        
        def backtrack(i, j):        
            if not dp[i][j]:                
                dp[i][j] = 1 + max(
                    backtrack(i - 1, j) if i > 0 and matrix[i][j] > matrix[i - 1][j] else 0,
                    backtrack(i + 1, j) if i < m - 1 and matrix[i][j] > matrix[i + 1][j] else 0,
                    backtrack(i, j - 1) if j > 0 and matrix[i][j] > matrix[i][j - 1] else 0,
                    backtrack(i, j + 1) if j < n - 1 and matrix[i][j] > matrix[i][j + 1] else 0)
            
            return dp[i][j]
        
        m = len(matrix)
        n = len(matrix[0])
        dp = [[0] * n for i in range(m)]
#         print('dp=',dp)
        
        res = []
        for i in range(m):
            for j in range(n):
                res.append(backtrack(i, j))
        return max(res)
```


```python
s = Solution()

matrix = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 

s.longestIncreasingPath(matrix)
```

    dp= [[0, 0, 0], [0, 0, 0], [0, 0, 0]]





    4




```python
class Solution:
    def longestIncreasingPath(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """

        if not matrix: 
            return 0
        
        
        
        m = len(matrix)
        n = len(matrix[0])
        
        dic = {}
        
        def dp(i, j, prev):   
            if (i,j) in dic:
                return dic[i,j]
            
            if i < 0 or j < 0 or i >= m or j >= n or matrix[i][j] >= prev:
                return 0
            
            x = matrix[i][j]
            
            dic[i,j] = 1 + max(
                dp(i - 1, j, x),
                dp(i + 1, j, x),
                dp(i, j - 1, x),
                dp(i, j + 1, x))

            return dic[i, j]
        
#         dp = [[0] * n for i in range(m)]
#         print('dp=',dp)
        
        res = 0
        inf = float('inf')
        for i in range(m):
            for j in range(n):
                res = max(res, dp(i, j, inf))
        return res
```


```python
matrix = [[9,9,4],[6,6,8],[2,1,1]]

s = Solution()
s.longestIncreasingPath(matrix)
```




    5



## 947. Most Stones Removed with Same Row or Column (Matrix, Recursion-Backtracking) (Google 8)
O(MN)  
O(MN)
https://www.jianshu.com/p/30d2058db7f7


```python
import collections
class Solution:
    def removeStones(self, points):
        """
        :type stones: List[List[int]]
        :rtype: int
        """
        
        index = collections.defaultdict(set)
        for i, j in points:
            index[i].add(j + 10000)
            index[j + 10000].add(i)

        print(index)    

        def backtrack(i):
            seen.add(i)
            for j in index[i]:
                if j not in seen:
                    backtrack(j)

        seen = set()
        islands = 0
        for i, j in points:
            if i not in seen:
                islands += 1
                backtrack(i)
                backtrack(j + 10000)
        return len(points) - islands
```


```python
s = Solution()
stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
s.removeStones(stones)
```

    defaultdict(<class 'set'>, {0: {10000, 10001}, 10000: {0, 1}, 10001: {0, 2}, 1: {10000, 10002}, 10002: {1, 2}, 2: {10001, 10002}})





    5



## 489. Robot Room Cleaner (DFS-Recursion) (Facebook 6, Google 5, Amazon 4) (Hard)




```python
# """
# This is the robot's control interface.
# You should not implement it, or speculate about its implementation
# """
#class Robot:
#    def move(self):
#        """
#        Returns true if the cell in front is open and robot moves into the cell.
#        Returns false if the cell in front is blocked and robot stays in the current cell.
#        :rtype bool
#        """
#
#    def turnLeft(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def turnRight(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def clean(self):
#        """
#        Clean the current cell.
#        :rtype void
#        """

class Solution:
    def cleanRoom(self, robot):
        """
        :type robot: Robot
        :rtype: None
        """
        visited = set()
        
        def dfs(robot, x = 0, y = 0, direct_x = 0, direct_y = 1):
            
            robot.clean()
            visited.add((x, y))

            for k in range(4):
                next_x = x + direct_x
                next_y = y + direct_y
                
                if (next_x, next_y) not in visited and robot.move():
                    dfs(robot, next_x, next_y, direct_x, direct_y)
                    robot.turnLeft()
                    robot.turnLeft()
                    robot.move()
                    robot.turnLeft()
                    robot.turnLeft()
                    
                robot.turnLeft()
                direct_x, direct_y = -direct_y, direct_x
        
        dfs(robot)
```

## 37. Sudoku Solver (Amazon 4, Microsoft 3, Facebook 3)


```python
def solveSudoku(self, board):
        """
        List[List[str]]
        None
        """
    
        row = [set(range(1, 10)) for _ in range(9)]  # 行剩余可用数字
        col = [set(range(1, 10)) for _ in range(9)]  # 列剩余可用数字
        block = [set(range(1, 10)) for _ in range(9)]  # 块剩余可用数字

        empty = []  # 收集需填数位置
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':  # 更新可用数字
                    val = int(board[i][j])
                    row[i].remove(val)
                    col[j].remove(val)
                    block[(i // 3)*3 + j // 3].remove(val)
                else:
                    empty.append((i, j))

        def backtrack(iter=0):
            if iter == len(empty):  # 处理完empty代表找到了答案
                return True
            i, j = empty[iter]
            b = (i // 3)*3 + j // 3
            for val in row[i] & col[j] & block[b]:
                row[i].remove(val)
                col[j].remove(val)
                block[b].remove(val)
                board[i][j] = str(val)
                if backtrack(iter+1):
                    return True
                row[i].add(val)  # 回溯
                col[j].add(val)
                block[b].add(val)
            return False
        backtrack()
```

## 805. Split Array With Same Average (List, Recursion-Backtracking) (Amazon 2, Microsoft 2->0) (Hard)


```python
class Solution:
    def splitArraySameAverage(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """      
        nums.sort()

# 		从数组nums中，找到k个数之和等于target的可能性
# 		combination sum II 或者 k sum那两道题的简易版
        def dfs(nums, k, target, index):
            if not k and not target:
                return True

            if not k or target < 0:
                return False

            for i in range(index, len(nums)):
                if i > index and nums[i] == nums[i -1]:
                    continue

                if target < nums[i] * k or target > nums[-1] * k:
                    break

                if dfs(nums, k - 1, target - nums[i], i + 1):
                    return True

            return False
        
        #个数不会超过数组总个数的一半 + 1
        for i in range(1, len(nums) // 2 + 1):
#             i个数 x sum（nums） ==  i个数之和 x len(nums)
#             所以 sum（nums） x i ➗ len(nums) == i个数之和 必然是整数
            if sum(nums) * i % len(nums):
                continue
                 
#             从数组nums中，找到k个数之和等于target的可能性
            if dfs(nums, i, sum(nums) * i // len(nums), 0):
                return True
        
        return False    
```

### BFS

## 417. Pacific Atlantic Water Flow (Google 3, Amazon 2)


```python
class Solution(object):
    def pacificAtlantic(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """
        if not matrix: return []
        
        directions = {(0,1), (0,-1), (1,0), (-1,0)}
        m, n = len(matrix), len(matrix[0])        
        
        def dfs(stk):
            ocean = set(stk)
            while stk:
                cur = stk.pop()
                for d in directions:
                    i, j = cur[0] + d[0], cur[1] + d[1]
                    if 0 <= i < m and 0 <= j < n and (i, j) not in ocean:
                        if matrix[i][j] >= matrix[cur[0]][cur[1]]:
                            stk.append((i, j))
                            ocean.add((i, j))
            return ocean
        
        stk1 = [(0, i) for i in range(n)] + [(i, 0) for i in range(1,m)]
        print(stk1)
        stk2 = [(m-1, i) for i in range(n)] + [(i, n-1) for i in range(m-1)]
        print(stk2)
        
        return dfs(stk1) & dfs(stk2)
```

## Zombie in Matrix (BFS) (Amazon OA)

Given a 2D grid, each cell is either a zombie 1 or a human 0. Zombies can turn adjacent (up/down/left/right) human beings into zombies every hour. Find out how many hours does it take to infect all humans?

Input:  
[[0, 1, 1, 0, 1],  
 [0, 1, 0, 1, 0],  
 [0, 0, 0, 0, 1],  
 [0, 1, 0, 0, 0]]  

Output: 2

Explanation:  
At the end of the 1st hour, the status of the grid:  
[[1, 1, 1, 1, 1],  
 [1, 1, 1, 1, 1],  
 [0, 1, 0, 1, 1],  
 [1, 1, 1, 0, 1]]  

At the end of the 2nd hour, the status of the grid:  
[[1, 1, 1, 1, 1],  
 [1, 1, 1, 1, 1],  
 [1, 1, 1, 1, 1],  
 [1, 1, 1, 1, 1]]  


```python
class Solution:
    def minHour(self, rows, columns, grid):
        if not rows or not columns:
            return 0
        
        queue = [[i,j] for i in range(rows) for j in range(columns) if grid[i][j]==1]
        time = 0
        
        while queue:
#             new = []
            for n in range(len(queue)):
                i, j = queue.pop(0)
                      
                for di, dj in [[1,0],[-1,0],[0,1],[0,-1]]:
                    x, y = i + di, j + dj
                    
                    if 0 <= x < rows and 0 <= y < columns and grid[x][y] == 0:
                        grid[x][y] = 1
                        queue.append([x,y])
#             q = new
            
            if not queue:
                break
                
            time += 1
            
        return time
```


```python
s = Solution()

grid = [[0, 1, 1, 0, 1],  
        [0, 1, 0, 1, 0],  
        [0, 0, 0, 0, 1],  
        [0, 1, 0, 0, 0]] 

rows = len(grid)
columns = len(grid[0])

s.minHour(rows, columns, grid)
```




    2




```python
class Solution:
    def minHour(self, rows, columns, grid):
        if not rows or not columns:
            return 0
        
        q = [[i,j] for i in range(rows) for j in range(columns) if grid[i][j]==1]
        time = 0
        
        while True:
            new = []
            for [i,j] in q:
                for d in [[1,0],[-1,0],[0,1],[0,-1]]:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < rows and 0 <= nj < columns and grid[ni][nj] == 0:
                        grid[ni][nj] = 1
                        new.append([ni,nj])
            q = new
            
            if not q:
                break
                
            time += 1
            
        return time
```

## 994. Rotting Oranges (Amazon OA 183)


```python
class Solution:
    def orangesRotting(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        
        if not grid:
            return 0
        
        rows = len(grid)
        columns = len(grid[0])
        
        queue = [[i,j] for i in range(rows) for j in range(columns) if grid[i][j]==2]
        time = 0
        
        oranges = 0
        for i in range(rows):
            for j in range(columns):
                if grid[i][j] == 2 or grid[i][j] == 1:
                    oranges += 1
                    
        rotten = len(queue)
        
        while queue:
            for i in range(len(queue)):
                i, i = queue.pop(0)
                for di, dj in [[1,0],[-1,0],[0,1],[0,-1]]:
                    x, y = i + di, j + dj
                    if 0 <= x < rows and 0 <= y < columns and grid[x][y] == 1:
                        grid[x][y] = 2
                        rotten += 1
                        queue.append([x, y])

            if not queue:
                break
                
            time += 1
            
        if oranges == rotten:
            return time
        
        else:
            return -1
```

## Treasure Island (Amazon OA)


```python
from collections import deque
def solution(matrix):
    if len(matrix) == 0 or len(matrix[0]) == 0:
        return -1  # impossible

    m, n = len(matrix), len(matrix[0])

    q = deque([((0, 0), 0)])  # ((x, y), step)
    matrix[0][0] = "D"
    
    while q:
        (i, j), step = q.popleft()
        
        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            x = i + di
            y = j + dj
            
            if 0 <= x < m and 0 <= y < n:
                if matrix[x][y] == "X":
                    return step + 1
                
                if matrix[x][y] == "O":
                    # mark visited
                    matrix[x][y] = "D"
                    q.append(((x, y), step + 1))

    return -1
```


```python
matrix = [['O', 'O', 'O', 'O'],
          ['D', 'O', 'D', 'O'],
          ['O', 'O', 'O', 'O'],
          ['X', 'D', 'D', 'O']]

solution(matrix)
```




    5



## Treasure Island II (Amazon OA)


```python
from collections import deque
def bfs(matrix):
    m = len(matrix)
    n = len(matrix[0])
    
    q = deque()
    for i in range(m):
        for j in range(n):
            if matrix[i][j]=="S":
                q.append((i, j))
            
    steps = 0

    while q:
        for i in range(len(q)):
            i, j = q.popleft()
            for di, dj in [(0,1), (1,0), (-1,0), (0,-1)]:
                x, y = i + di, j + dj
                if 0 <= x < m and 0 <= y < n and matrix[x][y]!="D":: 
                    if matrix[x][y] == "X":
                        return steps + 1
                    
                    matrix[x][y]="D"
                    q.append((x, y))
        steps += 1


```


```python
matrix = [['S', 'O', 'O', 'S', 'S'],['D', 'O', 'D', 'O', 'D'],['O', 'O', 'O', 'O', 'X'],
 ['X', 'D', 'D', 'O', 'O'],['X', 'D', 'D', 'D', 'O']]
bfs(matrix)
```




    3



## 1057. Campus Bikes (Google 23)


```python
class Solution:
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: List[int]
        """
        
        dist = []
        
        for i, w in enumerate(workers):
            for j, b in enumerate(bikes):
                dist.append((abs(w[0]-b[0]) + abs(w[1]-b[1]), i, j))
        
        dist.sort(reverse = True)
        worker = set()
        bike = set()
        
        res = [0] * len(workers)
        
        while dist:
            d, w, b = dist.pop()
            
            if w not in worker and b not in bike: # 这个人和车都没有被分配
                res[w] = b
                
                worker.add(w) # 这个worker已经分配了
                bike.add(b) # 这个bike已经分配了
                
        return res
```

## 1197 Minimum Knight Moves (Graph. BFS-Queue) (Facebook 9, Google 5, Amazon 4, Apple 2, Microsoft 2)


```python
class Solution:
    def minKnightMoves(self, x: int, y: int) -> int:
        moves = [(1,2),(2,1),(2,-1),(1,-2),(-1,-2),(-2,-1),(-2,1),(-1,2)]
        
        visited = set()
        visited.add((0,0))
        queue = [(0,0,0)]
        
        x = abs(x)
        y = abs(y)
        
        while queue:
            vertex = queue.pop(0)
            
            for move in moves:
                i = vertex[0] + move[0]
                j = vertex[1] + move[1]
                
                if (vertex[0], vertex[1]) == (x,y):
                return vertex[2] 

#                 if -5 <= i <= 302 and -5 <= j <= 302:
                if -2 <= i <= 302 and -2 <= j <= 302:
                    if (i,j) not in visited:
                        visited.add((i,j))
                        queue.append((i,j,vertex[2]+1))
                        
# class Solution(object):
#     memo = {(0, 0): 0}
#     queue = [(0, 0, 0)]
#     while queue:
#         vertex = queue.pop(0)
#         for move in ((2, -1), (2, 1), (-2, -1), (-2, 1), (1, -2), (1, 2), (-1, -2), (-1, 2)):
#             i = vertex[0]+move[0]
#             j = vertex[1]+move[1]
            
#             if -300 <= i <= 300 and -300 <= j <= 300:
#                 if (i, j) not in memo:
#                     memo[i,j] = vertex[2]+1
#                     queue.append((i, j, vertex[2]+1))
#     print(queue)
#     def minKnightMoves(self, x, y):
#         x = abs(x)
#         y = abs(y)
#         return self.memo[x,y]
```


```python
seen = set(['abc', 'abc', 'acb'])
seen
```




    {'abc', 'acb'}



## 688. Knight Probability in Chessboard (Amazon 4, Microsoft 2, Apple 2)


```python
class Solution(object):
    def knightProbability(self, N, K, r, c):
        """
        :type N: int
        :type K: int
        :type r: int
        :type c: int
        :rtype: float
        """
        dp = [[0] * N for _ in xrange(N)]
        dp[r][c] = 1
        for _ in xrange(K):
            dp2 = [[0] * N for _ in xrange(N)]
            for r, row in enumerate(dp):
                for c, val in enumerate(row):
                    for dr, dc in ((2,1),(2,-1),(-2,1),(-2,-1),
                                   (1,2),(1,-2),(-1,2),(-1,-2)):
                        if 0 <= r + dr < N and 0 <= c + dc < N:
                            dp2[r+dr][c+dc] += val / 8.0
            dp = dp2

        return sum(map(sum, dp))

```

## 490. The Maze (Amazon 6)


```python
class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        
        if not maze:
            return False
        
        m = len(maze)
        n = len(maze[0])
        
        queue = [start]
        # maze[start[0]][start[1]] = 1
        visited = set()
        visited.add(tuple(start))
        
        while queue:
            i, j = queue.pop(0)
            print(i, j)
            
            if i == destination[0] and j == destination[1]:
                return True
            
            for di, dj in ((0, -1), (-1, 0), (0, 1), (1, 0)):
                x, y = i + di, j + dj
                
                while 0 <= x < m and 0 <= y < n and maze[x][y] == 0:
                      
                    # maze[x][y] = 1    
                    x += di
                    y += dj
                    
                if (x-di, y-dj) not in visited:
                    visited.add((x-di, y -dj))
                    queue.append([x-di, y-dj])
                        
        return False
```

## 1236. Web Crawler (Amazon 4, Microsoft 4)


```python
class Solution:
    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        hostname = ''
        # get hostname
        
        count = 0
        for index, char in enumerate(startUrl):
            if char == '/':  
                count += 1
                if count == 3:
                    break
                
            hostname += char
        
		# process stack
        result, stack = set([startUrl]), [startUrl]
        
        while stack:
            q = stack.pop()
             
            for url in htmlParser.getUrls(q):
                if url.find(hostname) != -1 and url not in result:
                    result.add(url)
                    stack.append(url)
        return result
```

## 675. Cut Off Trees for Golf Event (BFS-Iteration) (Amazon 6->3) (Hard)



```python
from collections import deque

class Solution:
    def cutOffTree(self, forest):
        trees = sorted((v, r, c) for r, row in enumerate(forest)
                       for c, v in enumerate(row) if v > 1)
        
        sr = sc = ans = 0
        
        def bfs(forest, sr, sc, tr, tc):
            R, C = len(forest), len(forest[0])
            queue = deque([(sr, sc, 0)])
            seen = {(sr, sc)}
            
            while queue:
                r, c, d = queue.popleft()
                if r == tr and c == tc:
                    return d
                
                for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                    if (0 <= nr < R and 0 <= nc < C and
                            (nr, nc) not in seen and forest[nr][nc]):
                        seen.add((nr, nc))
                        queue.append((nr, nc, d+1))
            return -1

        
        for _, tr, tc in trees:
            d = bfs(forest, sr, sc, tr, tc)
            if d < 0: 
                return -1
            ans += d
            sr, sc = tr, tc
        return ans
```

## 1306. Jump Game III (Microsoft OA)


```python
class Solution:
    def canReach(self, arr, start):
        """
        :type arr: List[int]
        :type start: int
        :rtype: bool
        """    
        # BFS
        queue = collections.deque()
        queue.append(start)
        seen = set()
        seen.add(start)
        while queue:
            cur_index = queue.popleft()
            if arr[cur_index] == 0:
                return True
            if 0 <= cur_index + arr[cur_index] < len(arr) and cur_index + arr[cur_index] not in seen:
                queue.append(cur_index + arr[cur_index])
                seen.add(cur_index + arr[cur_index])
            if 0 <=  cur_index - arr[cur_index] < len(arr) and cur_index - arr[cur_index] not in seen:
                queue.append(cur_index - arr[cur_index])
                seen.add(cur_index - arr[cur_index])
        return False
```


```python
class Solution:
    def canReach(self, arr, start):
        """
        :type arr: List[int]
        :type start: int
        :rtype: bool
        """    
        # BFS 
        
        queue = [start]
        visited = [start]
        
        while queue:
            i = array.pop(0)
            if not arr[i]:
                return True
            
            right_i = i + arr[i]
            
            if 0 <= right_i <= len(arr) - 1 and right_i not in visited:
                queue.append(right_i)
                visited.add(right_i)
                
            left_i = i - arr[i] 
                
            if 0 <= left_i <= len(arr) - 1 and left_i not in visited:
                queue.append(left_i)
                visited.add(left_i)
                
        return False
```

## 909. Snakes and Ladders (BFS-Iteration) (Amazon 5, Microsoft 4)


```python
class Solution:
    def snakesAndLadders(self, board):
        """
        :type board: List[List[int]]
        :rtype: int
        """
        N = len(board)
        # convert to 1 d
        bd = [0]
        cnt = 0
        for i in range(N-1,-1,-1):
            if cnt % 2 == 0:
                bd += board[i]
            else:
                bd += board[i][::-1]
            cnt += 1
        print(bd)        
        #self.minCnt = float('inf')
        N2 = N*N
        queue = [1]
        move  = 0
        seen = set()
        seen.add(1)
        #print(bd)
        while queue:
    
            for _ in range(len(queue)):
                val = queue.pop(0)
                
                if val == N2:
                    return move
                
                for i in range(1,7):
                    tgt = val + i
                    
                    if tgt <= N2:
                        if bd[tgt] != -1:
                            tgt = bd[tgt]

                        if tgt not in seen:
                            queue.append(tgt)
                            seen.add(tgt)
                        
            move += 1
            
            # move在前面，move。在最后move + 1
        return -1
```
