```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"
```

### List. BS, Pointers, Sliding Window

### List, Matrix. In-place, Binary Search-2 Pointers.  O(logN) O(1). Must be sorted


```python
def sort(nums):
    l = 0
    r = len(nums) - 1
    
    while l < r:
        if nums[l] < nums[r]:
            nums[l], nums[r] = nums[r], nums[l]
            
    
```

## Binary Search


```python
def binarySearch(arr, target):
    l , r = 0, len(arr) - 1  
    while l <= r:            
        mid = (l + r) // 2 # mid = l + (r - l) // 2
        if arr[mid] == target:
            return mid
        if arr[mid] < target:
            l = mid + 1
        else:
            r = mid - 1
    return -1
```

##  69. Sqrt(x) (Int, BS) (Microsoft 6, Amazon 4, Google 2)


```python
class Solution:
    def mySqrt(self, x):        
        if x < 2:
            return x
        
        left = 2
        right = x // 2
        
        while left <= right:
            mid = left + (right - left) // 2
            num = mid * mid
            if num == x:
                return mid
            
            if num > x:
                right = mid -1
            elif num < x:
                left = mid + 1
            
        return right
```


```python
class Solution:
    def mySqrt(self, x):
        if not x:
            return 0
        
        if x < 4:
            return 1
        
        left = 2
        right = x // 2
        
        while left <= right:
            mid = left + (right - left) // 2
            num = mid * mid
            if num == x:
                return mid
            
            if num > x:
                right = mid -1
            elif num < x:
                left = mid + 1
            
        return right
```

## Sum of Perfect Squares (Google Phone)
https://leetcode.com/discuss/interview-question/385489/Google-or-Phone-Screen-or-Sum-of-Perfect-Squares-and-Missing-Ranges 


```python
class Main:
    def square(self, num):
        res = 0
        for n in range(1, num + 1):
            if self.mySqrt(n):
                res += n
                
        return res

    def mySqrt(self, x):
            if x < 2:
                return True

            left = 2
            right = x // 2

            while left <= right:
                mid = left + (right - left) // 2
                num = mid * mid
                if num == x:
                    return True

                if num > x:
                    right = mid -1
                elif num < x:
                    left = mid + 1

            return False
```


```python
s = Main()
s.square(10)
```




    14



## Salary Adjustment (Google Phone, Amazon Onsite)  
https://leetcode.com/discuss/interview-question/351313/Google-or-Phone-Screen-or-Salary-Adjustment


```python
def adjust(array, maxValue):
    array.sort(reverse = True)
    
    for i in range(1, len(array)):
        k = (maxValue - sum(array[i:])) // i
        if k > array[i]:
            return k
```


```python
array = [100, 200, 300, 400]
maxValue = 800
adjust(array, maxValue)
```




    250




```python
array = [80, 60, 150, 170, 125]
maxValue = sum(array) - 70
adjust(array, maxValue)
```




    127



## Array Adjustment (Google Phone)  
https://leetcode.com/discuss/interview-question/349612/Google-or-Phone-Screen-or-Array-Adjustment


```python
def max_value(nums,val):    
    l,r = min(nums), max(nums)
    
    while l < r:
        m = l+ (r-l) // 2
        s = 0
        for n in nums:
            if n >= m:
                s+=m
            else:
                s+=n
        if s < val:
            l = m+1
        elif s > val:
            r = m-1
            
        elif s == val:
            return m
    return l

# def max_value(nums,val):
#     l, r = min(nums), max(nums)+1 # O(N)

#     while l < r:
#         m = l + (r - l) // 2
#         s = 0
#         for n in nums: # O(N)
#             if n >= m:
#                 s+=m
#             else:
#                 s+=n

#         if s == val:
#             return m
        
#         elif s < val:
#             l = m + 1
#         else:
#             r = m

#     return m
```


```python
nums = [100, 200, 300, 400] #[10, 5, 20, 30] 

maxValue = 800

max_value(nums, maxValue)
```




    250



## 278. First Bad Version (Int. BS) (Facebook 28->41, Microsoft Onsite 2)


```python
class Solution():
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left = 1
        right = n
        while left <= right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid - 1
                
            else:
                left = mid + 1
                
        return left     
```

## 852. Peak Index in a Mountain Array (List, BS) (Google 3->5, Amazon 4)

O(logN)  
O(1)


```python
class Solution:
    def peakIndexInMountainArray(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        
        l = 0
        r = len(A) - 1
        while l <= r:
            mid = (l + r) // 2
            if A[mid - 1] < A[mid] > A[mid + 1]:
                return mid
            
            if A[mid-1] < A[mid] < A[mid + 1]:
                l = mid + 1
                
            elif A[mid-1] > A[mid] > A[mid + 1]:
                r = mid - 1
                
```


```python
class Solution:
    def peakIndexInMountainArray(self, A):
        l = 0
        r = len(A) - 1
        while l <= r:
            mid = (l + r) // 2
            if A[mid] < A[mid + 1]:
                l = mid + 1
            elif A[mid] > A[mid + 1]:
                r = mid - 1
        return l
```

## 34. Find First and Last Position of Element in Sorted Array (List, BS) (Facebook 12, Google 8, Uber 5, Amazon 4)

O(logN)  
O(N)


```python
class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        if not nums: 
            return [-1, -1]

        res = []
        l, r = 0, len(nums)-1
        # search for left bound
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == 0 or nums[mid-1] != target):
                res.append(mid)
                break
                
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
                
        if not res:
            return [-1, -1]

        # search for right bound, now we don't need to reset left pointer
        r = len(nums)-1
        while l <= r:
            mid = l + ((r - l) >> 1)
            if nums[mid] == target and (mid == len(nums)-1 or nums[mid+1] != target):
                res.append(mid)
                break
            elif nums[mid] > target:
                r = mid - 1
            else:
                l = mid + 1 
        # 这里直接返回res是因为前面如果判断左边界没返回的话就说明我们判断右边界的时候一定会append元素
        return res
```


```python
class Solution:
    # returns leftmost (or rightmost) index at which `target` should be inserted in sorted
    # array `nums` via binary search.
    def extreme_insertion_index(self, nums, target, left):
        lo = 0
        hi = len(nums) - 1

        while lo <= hi:
            mid = (lo + hi) // 2
            if nums[mid] > target or (left and target == nums[mid]):
                hi = mid
            else:
                lo = mid + 1

        return lo


    def searchRange(self, nums, target):
        left_idx = self.extreme_insertion_index(nums, target, True)

        # assert that `left_idx` is within the array bounds and that `target`
        # is actually in `nums`.
        if left_idx == len(nums) or nums[left_idx] != target:
            return [-1, -1]

        return [left_idx, self.extreme_insertion_index(nums, target, False)-1]
```


```python
def find(arr, target):
    
    start = 0
    end = 0
    
    for i in range(len(arr)):
        if arr[i] == target:
            start = i
            break
            
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] == target:
            end = i
            break
            
    return [start, end]

arr = [1,2,3,3,3,4]
target = 3
find(arr, target)
```

## Find the number of occurrences of an element in a sorted array (List. BS) (Google)


```python
# public int count(int[] arr, int target) {
#     int left = binarySearch(arr, target, true);
#     if (left < 0) return 0;
#     int right = binarySearch(arr, target, false);
#     return right - left + 1;
# }

# private int binarySearch(int[] arr, int target, boolean leftmost) {
#     int lo = 0;
#     int hi = arr.length - 1;
#     int idx = -1;
#     while (lo <= hi) {
#         int mid = (lo + hi) >>> 1; 

#         if (target > arr[mid]) {
#             lo = mid + 1;
#         } else if (target < arr[mid]) {
#             hi = mid - 1;
#         } else {
#             idx = mid;
#             if (leftmost) {
#                 hi = mid - 1;
#             } else {
#                 lo = mid + 1;
#             }
#         }
#     }
#     return idx;
# }

class Solution:
    def count(self, arr, target):
        def binarySearch(arr, target, leftmost):
            l = 0
            r = len(arr) - 1
            index = -1
            while l <= r:
                mid = (l + r) // 2
                if arr[mid] < target:
                    l = mid + 1
                    
                elif arr[mid] > target:
                    r = mid - 1
                    
                elif arr[mid == target: 
                    index = mid
                    if leftmost:
                        r = mid - 1
                    else:
                        l = mid + 1
                        
            return index
        
        
        left = binarySearch(arr, target, True)
        if left < 0:
            return 0
        
        right = binarySearch(arr, target, False)
        return right - left + 1
    

arr = [4, 4, 8, 8, 8, 15, 16, 23, 23, 42]
target = 8
s = Solution()
s.count(arr, target)
```




    3



## 410. Split Array Largest Sum (List, BS) (Google 31->8, Amazon 4) (Hard)

O(logN)  
O(1)


```python
class Solution:
    def splitArray(self, nums, m):
        """
        :type nums: List[int]
        :type m: int
        :rtype: int
        """    
        l = max(nums)
#         print('l=',l)
        r = sum(nums)
#         print('r=',r)
        while l <= r:
            mid = (l + r) // 2
#             print('mid=',mid)
            buckets = 1 
            sums = 0
            for n in nums:
                if sums + n > mid:
                    buckets += 1
                    sums = 0
                sums += n
                
#             print('buckets=', buckets)
#             print('sums=', sums)
                
            if buckets <= m:
                r = mid - 1
            elif beckets > m:
                l = mid + 1
        return l
```


```python
s = Solution()
nums = [7,2,5,10,8]
m = 2
s.splitArray(nums, m)
```

    l= 16
    r= 32
    mid= 24
    buckets= 2
    sums= 8
    mid= 20
    buckets= 2
    sums= 18
    mid= 18
    buckets= 2
    sums= 18
    mid= 17
    buckets= 3
    sums= 8





    18



## Divide Chocolate (


```python
# class Solution {
#     public int splitArray(int[] nums, int m) {
#         int low = 0, high = Integer.MAX_VALUE;
#         while (low <= high) {
#             int mid = low + (high - low) / 2;
#             if (canSplit(nums, m, mid)) {
#                 low = mid + 1;
#             } else {
#                 high = mid - 1;
#             }
#         }
#         return high;
        
#     }
    
#     // for a certian min sum requirement, check whether this can split into m groups
#     private boolean canSplit(int[] nums, int m, int minSum) {
#         int count = 0;
#         long sum = 0;
#         for (int i = 0; i < nums.length; i++) {
#             sum += nums[i];
#             if (sum >= minSum) {
#                 sum = 0;
#                 count++;
#             }
#         }
#         return count >= m;
#     }
# }
```




    18



## 153. Find Minimum in Rotated Sorted Array (List, BS) (Amazon 8, Microsoft 5)


```python
# O(logN), binary search  
# O(1)
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return nums[0]

        l = 0
        r = len(nums) - 1

        while l <= r:
            m = l + (r - l) // 2
            if nums[m] > nums[m + 1]:
                return nums[m + 1]

            if nums[m] < nums[m - 1]:
                return nums[m]

            if nums[m] > nums[r]:
                l = m + 1

            elif nums[m] < nums[r]:
                r = m - 1
                
nums = [2,3,4,5,1]
s = Solution()
s.findMin(nums)
```

    m 2
    3
    m 3
    1





    1




```python
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        l = 0
        r = len(nums) - 1
        while l < r:
            m = (l + r) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m
        return nums[l]
```


```python
l = [3,4,5,1,2]
```

## 154. Find Minimum in Rotated Sorted Array II (List, BS) (Amazon 2)
O(logN)~O(N)


```python
class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return nums[0]

        l = 0
        r = len(nums) - 1

        while l <= r:
            m = l + (r - l) // 2
            if nums[m] > nums[m + 1]:
                return nums[m + 1]

            if nums[m] < nums[m - 1]:
                return nums[m]

            if nums[m] > nums[r]:
                l = m + 1

            elif nums[m] < nums[r]:
                r = m - 1
                
            elif nums[m] == nums[r]:
                r -= 1
                
        return nums[l]
```


```python
class Solution:
    def findMin(self, nums):
        l = 0
        r = len(nums) - 1
        while l < r:
            m = (l + r) // 2
            if nums[m] == nums[r]:
                r -= 1
            
            elif nums[m] > nums[r]:
                l = m + 1
                
            elif nums[m] < nums[r]:
                r = m 

        return nums[l]
```


```python
from typing import List


class Solution:
    def findMin(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 0:
            return Exception('程序出错')

        left = 0
        right = size - 1
        while left < right:
            # mid = left + (right - left) // 2
            mid = (left + right) >> 1
            if nums[mid] > nums[right]:
                # mid 肯定不是最小值
                # [7,8,9,10,11,1,2,3]
                left = mid + 1
            elif nums[mid] < nums[right]:
                # mid 有可能是最小值
                # [7,8,1,2,3]
                right = mid
            else:
                # 都有可能，所以就把 right 排除了
                # [1,1,1,1,1,0,1]
                assert nums[mid] == nums[right]
                right = right - 1
        # 无需后处理
        return nums[left]
```

## 33. Search in Rotated Sorted Array (List, BS) (Amazon 19, Microsoft 10, Facebook 10, Google Phone 5)


```python
# 时间复杂度: O(lgN)   
# O(1)
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        
        if not nums:
            return -1
        
        l = 0
        r = len(nums) - 1
        
        while l <= r:
            mid = l + (r - l) // 2
            
            if nums[mid] == target:
                return mid
            
            if nums[mid] >= nums[l]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                    
                else:
                    l = mid + 1
                
            elif nums[mid] < nums[l]:
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                    
                else:
                    r = mid - 1
                    
        return -1
```


```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums:
            return -1

        l = 0 
        r = len(nums) - 1

        while l <= r:
            m = (l + r) // 2
#             print('mid =', mid)
            if nums[m] == target:
                return m

            if nums[m] < nums[r]: # nums[mid] <= nums[low]
                if nums[m] < target <= nums[r]:
#                     print('3')
                    l = m + 1
                else:
#                     print('4')
                    r = m - 1
        
            elif nums[m] >= nums[r]:
                if nums[l] <= target < nums[m]:
#                     print('1')
                    r = m - 1
                else:
#                     print('2')
                    l = m + 1
        return -1
```


```python
s = Solution()
nums = [4,5,6,7,0,1,2]
target = 0
s.search(nums, target)
```

    mid = 3
    2
    mid = 5
    1
    mid = 4





    4



## 74. Search a 2D Matrix (List, BS) (Amazon 15, Facebook 4, Microsoft 4)

N(log(mn))  
O(1)


```python
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        
        row = len(matrix)
        col = len(matrix[0])
        
        # binary search
        l = 0
        r = row * col - 1
        while l <= r:
            m = (l + r) // 2
            num = matrix[m // col][m % col]
            if num == target:
                return True
            elif num > target:
                r = m - 1
            else:
                l = m + 1
        return False
```


```python
for nums in matrix:
    l = 0
    r = len(nums) - 1
    while l <= r:
        m = (l + r) // 2
        if nums[m] == target:
            return True

        elif nums[m] < target:
            l = m + 1

        else:
            r = m - 1

return False
```

## 378. Kth Smallest Element in a Sorted Matrix (List. BS, heapq) (Amazon 7, Microsoft Onsite 3, Facebook 3)


```python
import bisect
class Solution():
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        l = matrix[0][0]
        r = matrix[-1][-1]

        while l <= r:
            m = (l + r) // 2
            count = 0
            for row in matrix:
                count += bisect.bisect(row, m)
            if k > count:
                l = m + 1
            else:
                r = m - 1
        return l
```


```python
import heapq
class Solution:
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        
        heap = []
        for array in matrix:
            for n in array:
                heapq.heappush(heap, n)
                
        for n in range(k):
            res = heapq.heappop(heap)
            
        return res
```


```python
import heapq
class Solution:
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        
        array = [y for x in matrix for y in x]
        return heapq.nsmallest(k, array)[-1]
```

## 540. Single Element in a Sorted Array (List. Binary Search) (Amazon 4, Facebook 4, Microsoft 3)


```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l = 0
        r = len(nums) - 1   
        
        while l < r:
            mid = l + (r - l) // 2

            # halves_are_even = (hi - mid) % 2 == 0
            
            if nums[mid] == nums[mid - 1]:
                if (mid + 1) % 2: #odd
                    r = mid - 2
                else: #even
                    l = mid + 1
                    
            elif nums[mid] == nums[mid + 1]:
                if (mid + 1) % 2: #odd
                    l = mid + 2
                else: #even
                    r = mid - 1
            
            else:
                return nums[mid]
        return nums[l]
```


```python
# class Solution:
#     def singleNonDuplicate(self, nums):
#         """
#         :type nums: List[int]
#         :rtype: int
#         """
        
#         a = 0
#         for i in nums:
#             a ^= i
#             print(a)
#         return a
        
#         previous = nums[0]
#         cnt = 0
#         for i in range(1, len(nums)):
#             if nums[i] == previous:
#                 cnt += 1

#             elif nums[i] != previous and cnt != 0:
#                 previous = nums[i]
#                 cnt = 0

#             elif nums[i] != previous and cnt == 0:
#                 return previous

#         return nums[-1]

    
class Solution {
    public int singleNonDuplicate(int[] nums) {
       int l=0,r=nums.length-1;
       while(l<r){
           int h=(r+l)/2;
           if(h%2==1){
               if(nums[h]==nums[h+1])
                   r=h-1;
               else
                   l=h+1;
           }else{
               if(nums[h]==nums[h+1])
                   l=h+2;
               else
                   r=h;
           }
       }
        return nums[l];
    }
}
```


```python
class Solution:
    def singleNonDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        previous = nums[0]
        cnt = 0
        for i in range(1, len(nums)):
            if nums[i] == previous:
                cnt += 1

            elif nums[i] != previous and cnt != 0:
                previous = nums[i]
                cnt = 0

            elif nums[i] != previous and cnt == 0:
                return previous

        return nums[-1]
```


```python
def xor(nums):
    a = 0
    for i in nums:
        a ^= i
    return a
```

## 240 Search a 2D Matrix II (Matrix. 2 Pointers) (Amazon OA 15, Microsoft 8)


```python
# O(max(M,N))  
# O(1)
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        
        m = 0
        n = len(matrix[0]) - 1
        
        while m < len(matrix) and n >= 0:
            if matrix[m][n] == target:
                return True
                
            elif matrix[m][n] < target:
                m += 1    
                
            elif matrix[m][n] > target:
                n -= 1
            
        return False
```

## Leftmost Column Index of 1 (Google/Facebook Phone)
https://leetcode.com/discuss/interview-question/341247/Facebook-or-Leftmost-column-index-of-1  


```python
# public class Main {
    
#     public static int findLeftmostIndexOfOne(int[][] matrix) {
#         int rows = matrix.length;
#         int cols = matrix[0].length;
#         int candidate = -1;
#         for (int r = 0, c = cols - 1; r < rows && c >= 0; ) {
#             if (matrix[r][c] == 1) {
#                 candidate = c;
#                 c--;
#             } else {
#                 r++;
#             }
#         }
#         return candidate;
#     }
    
class Main:
    def findLeft(self, matrix):
        row = len(matrix)
        col = len(matrix[0])
    
        res = -1
    
        r = 0
        c = col - 1
        while r <= row - 1 and c >= 0:
            if matrix[r][c] == 1:
                res = c
                c -= 1
            else:
                r += 1
        return res
```


```python
s = Main()
matrix = [[0, 0, 0, 1],
          [0, 0, 1, 1],
          [0, 1, 1, 1],
          [0, 0, 0, 0]]
s.findLeft(matrix)
```




    1



### String, List. In-place, List. Pointers. O(N) O(1). Must bee sorted

## Construct Odd Even Array (Google Phone)


```python
def oddEven(arr):
    l = 0
    r = len(arr) // 2    
    while r <= len(arr) - 1:
        arr[l], arr[r] = arr[r], arr[l]
        l += 2
        r += 1
        
    for l in range(1, len(arr), 2):
        r = l + 2
        while r <= len(arr) - 1:
            if arr[l] < arr[r]:
                arr[l], arr[r] = arr[r], arr[l]
            r += 2
```


```python
arr = [1, 2, 3, 4, 5, 6, 7]
oddEven(arr)
arr
```




    [4, 3, 5, 2, 6, 1, 7]




```python
for l in range(1, 7, 2):
    r = l + 2
    while r <= 6:
        print(l, r)
        r += 2
```

## 977. Squares of a Sorted Array (List, 2 Pointers) (Facebook 9, Amazon 4, Microsoft 2, Uber 7->3)

O(N)  
O(N)


```python
class Solution:
    def sortedSquares(self, nums):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        l = 0 
        r = len(nums) - 1
        end = len(nums) - 1
        res = [0] * len(nums)
        
        while l <= r:
            if nums[l]**2 < nums[r]**2:
                res[end] = nums[r]**2
                end -= 1
                r -= 1
                
            else:
                res[end] = nums[l]**2
                end -= 1
                l += 1
                
        return res
```


```python
class Solution:
    def sortedSquares(self, nums):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        res = [0] * len(nums)
        l = 0 
        r = len(nums) - 1
        while l <= r:
            if abs(nums[l]) < abs(nums[r]):
                res[r - l] = abs(nums[r])**2
                r -= 1
            else:
                res[r - l] = abs(nums[l])**2
                l += 1
        return res
```

## 88. (5) Merge Sorted Arrays (List, 2 Pointers) (Facebook 18, Microsoft Onsite 10, Amazon 8)

O(m+n)  
O(1)


```python
class Solution:
    def merge(self, A, m, B, n):
        """
        :type A: List[int]
        :type m: int
        :type B: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        p1 = m - 1
        p2 = n - 1
        end = m + n - 1
        
        while p1 >= 0 and p2 >= 0:
#             print('m =', m, 'n =', n)
            if A[p1] > B[p2]:
                A[end] = A[p1]
#                 print('nums1 =', nums1)
                end -= 1
                p1 -= 1
#                 print('m =', m)
            else:
                A[end] = B[p2]
#                 print('nums1 =', nums1)
                end -= 1
                p2 -= 1
#                 print('n =', n)     
#             print()
        # if p2 > 0:
        A[:p2+1] = B[:p2+1]
```


```python
s = Solution()
nums1 = [1,2,3,0,0,0]
nums2 = [2,5,6]
s.merge(nums1,3,nums2,3)
nums1
```

    m = 3 n = 3
    nums1 = [1, 2, 3, 0, 0, 6]
    n = 2
    
    m = 3 n = 2
    nums1 = [1, 2, 3, 0, 5, 6]
    n = 1
    
    m = 3 n = 1
    nums1 = [1, 2, 3, 3, 5, 6]
    m = 2
    
    m = 2 n = 1
    nums1 = [1, 2, 2, 3, 5, 6]
    n = 0
    





    [1, 2, 2, 3, 5, 6]



Given two sorted arrays, return the merge of the two sorted arrays also in sorted order.

Example  
Input  
arr1[] = {5, 8, 9}  
arr2[] = {4, 7, 8}  

Output  
arr3[] = {4, 5, 7, 8, 8, 9}  


```python
def merge(left, right):
    l = r = 0
    ret = []

    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            ret.append(left[l])
            l += 1
        else:
            ret.append(right[r])
            r += 1
    
    # append what is remained in either of the lists
    ret.extend(left[l:])
    ret.extend(right[r:])
    
    return ret

arr1 = [5,8,9]
arr2 = [4,7,8]
merge(arr1, arr2)
```

    []





    [4, 5, 7, 8, 8, 9]




```python
def merge_arrays(arr1, arr2):
    if not arr1:
        return arr2
    if not arr2:
        return arr1
    
    m = 0
    n = 0
    end = len(arr1) + len(arr2) - 1
    
    res = [0] * len(arr2)
    
    arr3 = [0] * (len(arr1) + len(arr2))
    
    
    print(arr1)
    # arr1 = [5,8,9,0,0,0]
    
    while m <= len(arr1) - 1 and n <= len(arr2) - 1:
        if arr1[m] > arr2[n]:
            arr3[m+n] = arr2[n]
            n +=1
        else:
            arr3[m+n] = arr1[m]
            m +=1
    
    # print(m)
    # print(n)
    if m <= len(arr1) - 1:
        arr3[m+n:] = arr1[m:]
        
    if n <= len(arr2) - 1:
        arr3[m+n:] = arr2[n:]
```

## 4. Median of Two Sorted Arrays (List, 3 Pointers) (Amazon 14, Google 12, Apple 8, Facebook 5, Microsoft 7) (Hard)

O(log(min(m,n)))  
O(1)


```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        
        
        m = len(nums1)
        n = len(nums2)
        # 让nums2成为更长的那一个数组
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        
        # 如果两个都为空的异常处理
        if n == 0:
            raise ValueError

        # nums1中index在imid左边的都被分到左堆，nums2中jmid左边的都被分到左堆
        imin, imax = 0, m
        
        # 二分答案
        while(imin <= imax):
            imid = imin + (imax - imin) // 2
            # 左堆最大的只有可能是nums1[imid-1],nums2[jmid-1]
            # 右堆最小只有可能是nums1[imid],nums2[jmid]
            # 让左右堆大致相等需要满足的条件是imid+jmid = m-imid+n-jmid 即 jmid = (m+n-2imid)//2
            # 为什么是大致呢？因为有总数为奇数的情况，这里用向下取整数操作，所以如果是奇数，右堆会多1
            jmid = (m + n - 2*imid) // 2 
            
            # 前面的判断条件只是为了保证不会index out of range
            if imid > 0 and nums1[imid-1] > nums2[jmid]:
                # imid太大了，这是里精确查找，不是左闭右开，而是双闭区间，所以直接移动一位
                imax = imid - 1
            elif imid < m and nums2[jmid-1] > nums1[imid] :
                imin = imid + 1
            # 满足条件
            else:
                # 边界情况处理，都是为了不out of index
                # 依次得到左堆最大和右堆最小
                if(imid == m): 
                    minright = nums2[jmid]
                elif(jmid == n): 
                    minright = nums1[imid]
                else:
                    minright = min(nums1[imid],nums2[jmid])        
                    
                if(imid == 0): 
                    maxleft = nums2[jmid-1]
                elif(jmid == 0): 
                    maxleft = nums1[imid-1]
                else:
                    maxleft = max(nums1[imid-1],nums2[jmid-1])
                
                # 前面也提过，因为取中间的时候用的是向下取整，所以如果总数是奇数的话，
                # 应该是右边个数多一些，边界的minright就是中位数
                if((m+n)%2) == 1:
                    return minright 
     
                # 否则我们在两个值中间做个平均
                return (maxleft + minright)/2
    
nums1 = [1,2,3,4]
nums2= [2,3,4,5]
s = Solution()
s.findMedianSortedArrays(nums1, nums2)
```




    3.0




```python
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        m, n = len(A), len(B)
        
        if m > n:
            A, B, m, n = B, A, n, m
            
        if n == 0:
            return 0

        imin, imax, half_len = 0, m, (m + n + 1) // 2
        
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and B[j-1] > A[i]:
                # i is too small, must increase it
                imin = i + 1
            elif i > 0 and A[i-1] > B[j]:
                # i is too big, must decrease it
                imax = i - 1
            else:
                # i is perfect

                if i == 0: 
                    max_of_left = B[j-1]
                elif j == 0: 
                    max_of_left = A[i-1]
                else: 
                    max_of_left = max(A[i-1], B[j-1])

                if i == m: 
                    min_of_right = B[j]
                elif j == n: 
                    min_of_right = A[i]
                else:
                    min_of_right = min(A[i], B[j])
                    
                if (m + n) % 2 == 1:
                    return max_of_left

                return (max_of_left + min_of_right) / 2.0
```

O(m+n)  
O(1)


```python
class Solution:
    def findMedianSortedArrays(self, A, B):
        """
        :type A: List[int]
        :type B: List[int]
        :rtype: float
        """
        def findKth(A, B, k):
            p1 = 0
            p2 = 0
            m = 0
            res = 0
            while p1 <= len(A) - 1 and p2 <= len(B) - 1 and m <= k:
                if A[p1] < B[p2]:
                    res = A[p1]
                    p1 += 1
                else:
                    res = B[p2]
                    p2 += 1
                m += 1

            while p1 <= len(A) -1 and m <= k:
                res = A[p1]
                p1 += 1
                m += 1

            while p2 <= len(B) - 1 and m <= k:
                res = B[p2]
                p2 += 1
                m += 1

            return res

        n = len(A) + len(B)
#         print(n)
        if n % 2 == 1:
#             print('yes')
            return findKth(A, B, n // 2)
        else:
            smaller = findKth(A, B, n // 2 - 1)
            bigger = findKth(A, B, n // 2)
            return (smaller + bigger) / 2
        
a = Solution()
a.findMedianSortedArrays([1,4,5],[2,6])
```

    5
    yes





    4




```python
def findKth(A, B, k):
    p1 = 0
    p2 = 0
    m = 0
    res = 0
    while p1 <= len(A) - 1 and p2 <= len(B) - 1 and m <= k:
        if A[p1] < B[p2]:
            res = A[p1]
            p1 += 1
        else:
            res = B[p2]
            p2 += 1
        m += 1

    while p1 <= len(A) -1 and m <= k:
        res = A[p1]
        p1 += 1
        m += 1

    while p2 <= len(B) - 1 and m <= k:
        res = B[p2]
        p2 += 1
        m += 1

    return res
        
findKth([1,3], [2, 4], 3)
```




    4



## 28. Implement strStr() (Amazon 5)

*- 时间复杂度: O(m * n)- 空间复杂度: O(1)*

m = len(haystack)
n = len(needle)
作弊，python str.find() 底层实现是 Boyer–Moore–Horspool 算法

The time complexity is O(N) on average, O(NM) worst case (N being the length of the longer string, M, the shorter string you search for).


```python
class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        n, h = len(needle), len(haystack)
        
        if n == 0:
            return 0

        ph = 0
        while ph <= h - n:
            while ph <= h - n:
                if haystack[ph] == needle[0]:
                    break
                ph += 1
            
            pn = 0
            while pn < n and ph < h:
                if haystack[ph] != needle[pn]:
                    break
                    
                ph += 1
                pn += 1
            
            if pn == n:
                return ph - n

            ph = ph - pn + 1
            
        return -1
```


```python
class Solution():
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        n, h = len(needle), len(haystack)
        
        if n == 0:
            return 0

        ph = 0
        while ph <= h - n:
            # find the position of the first needle character
            # in the haystack string
            while ph <= h - n and haystack[ph] != needle[0]:
                ph += 1
            
            # compute the max match string
            curr_len = pn = 0
            while pn < n and ph < h and haystack[ph] == needle[pn]:
                ph += 1
                pn += 1
                curr_len += 1
            
            # if the whole needle string is found,
            # return its start position
            if curr_len == n:
                return ph - n
            
            # otherwise, backtrack
            ph = ph - curr_len + 1
            
        return -1
```


```python
class Solution:
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        return haystack.find(needle)
```

## 167. Two Sum II - Input Array is Sorted (List, 2 Pointers) (Amazon 10)
O(n)  
O(1)

https://www.hrwhisper.me/leetcode-2-sum-3-sum-4-sum-3-sum-closest-k-sum/


```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        l = 0
        r = len(nums) - 1
        while l < r:
            if nums[l] + nums[r] == target:
                return [l + 1, r + 1]
            elif nums[l] + nums[r] > target:
                r -= 1
            else:
                l += 1
        return [-1, -1]
```


```python
s = (3,2)
sorted((3,2))
```




    [2, 3]



## Optimal Utilization (Amazon OA)


```python
class Solution:
    def findPairs(self, a, b, target):
        a.sort(key=lambda x: x[1])
        b.sort(key=lambda x: x[1])
        
        print(a)
        print(b)
        
        l, r = 0, len(b) - 1
        ans = []
        curDiff = float('inf')
        
        while l < len(a) and r >= 0:
            id1, i = a[l]
            id2, j = b[r]
            
            if (i + j <= target and target - i - j < curDiff):
                ans.clear()
                ans.append([id1, id2])
                curDiff = target - i - j
                
            elif (target - i - j == curDiff):
                ans.append([id1, id2])
                
            if i + j < target:
                l += 1
            else:
                r -= 1
                
        return ans
```


```python
a = [[1, 2], [2, 4], [3, 6]]
b = [[1, 2]]
target = 7

s = Solution()
s.findPairs(a,b,target)
```

    [[1, 2], [2, 4], [3, 6]]
    [[1, 2]]





    [[2, 1]]



## 15. 3Sum (List, 2 Pointers) (Amazon 32, Facebook 16, Microsoft 7)

O(N^2)  
O(n)  
排序  
固定左边，如果左边重复，继续  
左右弄边界，去重，针对不同的左右边界情况处理


```python
# right
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res =[]
#         i = 0
        
        for i in range(len(nums)-2):
#             if i == 0 or nums[i] > nums[i-1]:
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            l = i + 1
            r = len(nums) - 1

            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == 0:
                    res.append([nums[i], nums[l], nums[r]])
                    l += 1
                    r -= 1

                    while l < r and nums[l] == nums[l-1]:
                        l += 1
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1
                elif s > 0:
                    r -=1
                else :
                    l +=1
        return res
```

## 16. 3Sum Closest (List, 2 Pointers) (Google 6, Amazon 3)
O(N^2)  
O(1)


```python
class Solution:
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res = 0
        res_diff = float('inf')
        for i in range(len(nums)-2):
            if i > 0 and nums[i] == nums[i-1]:
                continue 
            
            l = i + 1 
            r = len(nums) - 1
                
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == target:
                    return target
                elif s > target:
                    r -= 1
                else:
                    l += 1
            
                if abs(s-target) < res_diff:
                    res_diff = abs(s-target)
                    res = s

        return res
```


      File "<ipython-input-13-d54a57fc2267>", line 29
        if diff < res_diff
                          ^
    SyntaxError: invalid syntax




```python
class Solution:
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res = None
        diff = float('inf')
        for i in range(len(nums)-2):
            if i == 0 or nums[i] > nums[i-1]:
                l = i+1 
                r = len(nums)-1
                
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == target:
                    return target
                elif s > target:
                    r -= 1
                    if abs(s-target) < diff:
                        diff = abs(s-target)
                        res = s
                    while l < r and nums[r] == nums[r+1]:
                        r -= 1    
                else:
                    l += 1
                    if abs(s-target) < diff:
                        diff = abs(s-target)
                        res = s
                    while l < r and nums[l] == nums[l-1]:
                        l += 1 
        return res
```

## 18. 4Sum (List, 2 Pointers) (Amazon 4)

O(N^3)  
O(n)


```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        res = []
        for i in range(len(nums) - 3):
            if i > 0 and nums[i] == nums[i - 1]: 
                continue
                
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target: 
                break
            if nums[i] + nums[i - 3] + nums[i - 2] + nums[i - 1] < target: 
                continue
                
            for j in range(i + 1, len(nums) - 2):
                if j > i + 1 and nums[j] == nums[j - 1]: 
                    continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target: 
                    break
                if nums[i] + nums[j] + nums[j - 2] + nums[j - 1] < target: 
                    continue
                    
                l = j + 1 
                r = len(nums) - 1
                while l < r:
                    s = nums[i] + nums[j] + nums[l] + nums[r]
                    if s == target:
                        res.append([nums[i], nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                        while l < r and nums[l] == nums[l - 1]: 
                            l += 1
                        while l < r and nums[r] == nums[r + 1]: 
                            r -= 1
                    elif s > target:
                        r -= 1
                    else:
                        l += 1
        return res
```


```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        res = []
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                l = j + 1
                r = len(nums) - 1
                while l < r:
                    s = nums[i] + nums[j] + nums[l] + nums[r]
                    if s == target:
                        if [nums[i], nums[j], nums[l], nums[r]] not in res:
                            res.append([nums[i], nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                    elif s > target:
                        r -= 1
                    else:
                        l += 1
        return res
```

## 11. (5) Container With Most Water (List, 2 Pointers) (Amazon 18, Google 5, Microsoft 2)

O(N)  
O(1)


```python
class Solution:
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l = 0
        r = len(height) - 1
        res = 0
        while l < r:
            water = min(height[l], height[r]) * (r - l) 
            res = max(res, water)
            if height[l] <= height[r]:
                l += 1
            elif height[l] > height[r]:
                r -= 1
#             else:
#                 left += 1
#                 right -= 1
        return res     
```

## 42. (5) Trapping Rain Water (List, 2 Pointers) (Amazon 37, Facebook 17, Microsoft Onsite 16, Google 13)


```python
class Solution:
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """        
        l = 0
        r = len(height) - 1
        res = 0
        
        while l < r:
            minimum = min(height[l], height[r])
#             print('min =', min_height)
            while l < r and minimum >= height[l]:
                res += minimum - height[l] 
#                 print('water =', water)
                l += 1
#                 print('l =', l)

            while l < r and minimum >= height[r]:
                res += minimum - height[r]
#                 print('water =', water)
                r -= 1
#                 print('r =', r)
                
#             print()
        return res
```


```python
s = Solution()
s.trap([0,1,0,2,1,0,1,3,2,1,2,1])
```

    min = 0
    water = 0
    l = 1
    
    min = 1
    water = 0
    l = 2
    water = 1
    l = 3
    water = 1
    r = 10
    
    min = 2
    water = 1
    l = 4
    water = 2
    l = 5
    water = 4
    l = 6
    water = 5
    l = 7
    water = 5
    r = 9
    water = 6
    r = 8
    water = 6
    r = 7
    





    6



## 125. Valid Palindrome (String. 2 Pointers) (Facebook 34, Microsoft 8)

O(N)  
O(1)


```python
class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        l, r = 0, len(s) - 1
        while l < r:
            if not s[l].isalnum():
                l += 1
           
            elif not s[r].isalnum():
                r -= 1
            
            elif s[l].lower() != s[r].lower():
                return False
            
            else:
                l +=1
                r -= 1
        return True
```


```python
class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        l, r = 0, len(s)-1
        while l < r:
            while l < r and not s[l].isalnum():
                l += 1
            while l < r and not s[r].isalnum():
                r -= 1
            if s[l].lower() != s[r].lower():
                return False
            l +=1
            r -= 1
        return True
```

O(N)  
O(1)


```python
class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if not s:
            return True
        
        strs = []
        for c in s:
            if c.isalnum():
                strs.append(c.lower())
                
        return strs==strs[::-1]
```


```python
class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s = ''.join(c for c in s if c.isalnum()).lower()
        print(s)
        return s==s[::-1]
    
#         s = s.lower()
#         n = ''
#         for c in s:
#             if c.isalnum():
#                 n += c
                
#         print(n)
#         return n == n[::-1]

#         s = s.lower()
#         for c in s:
#             if not c.isalnum():
#                 s = s.replace(c, '')
                
#         print(s)
#         return s == s[::-1]
```


```python
d = "A man, a plan, a canal: Panama"
s = Solution()
s.isPalindrome(d)
```

    amanaplanacanalpanama





    True




```python
for n in d:
    print(n)
```

    A
     
    m
    a
    n
    ,
     
    a
     
    p
    l
    a
    n
    ,
     
    a
     
    c
    a
    n
    a
    l
    :
     
    P
    a
    n
    a
    m
    a


## 31. Next Permutation (List) (Facebook 23, Amazon 7, Google 7, Microsoft 3)
就是返回一个大且仅大于当前数字的序列 如果没有更大的 就返回一个最小的数字 就是这么简单  
先找出最大的索引k满足nums[l]<nums[l+1], 如果不存在，翻转整个list  
再找出另一个最大索引l，满足nums[r]>nums[l]  
swap nums[l] and nums[r]  
reverse nums[l+1:]  


```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return 
        
        if len(nums) == 1:
            return nums
        
        l = len(nums) - 2
        
        while l >= 0:
            if nums[l] < nums[l+1]:
                break
                
            l -= 1
                
        if l == -1:
            nums[:] = nums[::-1]
            return
                
        r = len(nums) - 1
        while r >= l:
            if nums[r] > nums[l]:
                break

            r -= 1
                
        nums[l],nums[r] = nums[r], nums[l]
        nums[l+1:] = nums[l+1:][::-1]
```


```python
class Solution:
    def nextPermutation(self, nums):
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return 
        
        if len(nums) == 1:
            return nums
        
        l = len(nums) - 2
        
        while l >= 0 and nums[l] >= nums[l+1]:
            l -= 1
                
        if l == -1:
            nums[:] = nums[::-1]
            return
                
        r = len(nums) - 1
        while r >= l and nums[r] <= nums[l]:
            r -= 1
                
        nums[l],nums[r] = nums[r], nums[l]
        nums[l+1:] = nums[l+1:][::-1]
```


```python
public void nextPermutation(int[] nums) {
    int i = nums.length - 2;
    //找到第一个不再递增的位置
    while (i >= 0 && nums[i + 1] <= nums[i]) {
        i--;
    }
    //如果到了最左边，就直接倒置输出
    if (i < 0) {
        reverse(nums, 0);
        return;
    }
    //找到刚好大于 nums[i]的位置
    int j = nums.length - 1;
    while (j >= 0 && nums[j] <= nums[i]) {
        j--;
    }
    //交换
    swap(nums, i, j);
    //利用倒置进行排序
    reverse(nums, i + 1);

}
```


```python
# O(N)  
# O(1)
class Solution:
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        """
        def reverse(nums, i, j):
            while i < j:
                nums[i],nums[j] = nums[j], nums[i]
                i += 1
                j -= 1

        l = -1
        for l in range(len(nums)-2, -1, -1):
            if nums[i] < nums[i+1]:
                l = i
                break
                
        if l == -1:
            reverse(nums, 0, len(nums)-1)
            return
                
        r = -1    
        for i in range(len(nums)-1, l, -1):
            if nums[i] > nums[l]:
                r = i
                break
                
        nums[l],nums[r] = nums[r], nums[l]
        reverse(nums, l+1, len(nums)-1)

```

## 344. Reverse String (String List, 2 Pointers) (Amazon 7)

O(N)  
O(1)


```python
class Solution:
    def reverseString(self, s):
        """
        :type s: List[str]
        :rtype: None Do not return anything, modify s in-place instead.
        """
        l = 0
        r = len(s) - 1
        while l < r:
            s[l], s[r] = s[r], s[l]
            l += 1
            r -= 1
        return s
```

## 151. Reverse Words in String (String. Pointer. Stack) (Microsoft Onsite 12, Facebook 7, Amazon 3)


```python
class Solution:
    def reverseWords(self, s):  
        """
        :type s: str
        :rtype: str
        """

        strs = s.split()
        
        l = 0
        r = len(strs) - 1
        
        while l < r:
            strs[l], strs[r] = strs[r], strs[l]
            l += 1
            r -= 1
            
        return ' '.join(strs)
```


```python
# O(n)  
# O(n)
class Solution:
    def reverseWords(self, s):  
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''
        
        strs = s.split()
        res = []
        while strs:
            s = strs.pop()
            res.append(s)
        return ' '.join(res)
```


```python
s = 'ss    ss'
s.split()
```




    ['ss', 'ss']




```python
class Solution:
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        return ' '.join(s.split()[::-1])
```


```python
s = 'sjdksf ksdjkf'
s.split()
```

## 186. Reverse Words in String II (String List, Pointer) (Microsoft 3)

O(N)  
O(1)


```python
class Solution:
    def reverseWords(self, strs):
        """
        :type s: a list of 1 length strings (List[str])
        :rtype: nothing
        """
#         strs.reverse()
        def reverse(strs):
            l = 0
            r = len(strs) - 1
            while l < r:
                strs[l], strs[r] = strs[r], strs[l]
                l += 1
                r -= 1

        reverse(strs)
        
        chor = 0
        for i, c in enumerate(strs):
            if c == " ":
                strs[chor: i] = strs[chor: i][::-1]
                chor = i + 1

        strs[chor:] = strs[chor:][::-1]
```


```python
class Solution:
    def reverseWords(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        def reverse(s, l, r):
            while l < r:
                s[l], s[r] = s[r], s[l]
                l += 1
                r -= 1

        reverse(s, 0, len(s)-1)
        print(s)
        
        chor = 0
        for i, c in enumerate(s):
            if c == " ":
                
                reverse(s, chor, i-1)
                chor = i + 1

        reverse(s, chor, len(s)-1)
```


```python
x = Solution()
s = ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
# x.reverseWords(s)

print(s[0:])
```

## 557. Reverse Words in a String III (String. List) (Microsoft 9, Amazon 3)
O(N)  
O(N)


```python
class Solution:
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''
        
        strs = s.split()
        res = ""
        for word in strs:
            res += word[::-1] + " "
        return res.strip()
```


```python
res = 'myname'
res[:-1]
```


```python
class Solution:
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''

        sentence = ""
        for word in s.split():
            sentence += word[::-1] + " "
            
        return sentence.strip()
```


```python
class Solution:
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return ''
        
        return ' '.join([i[::-1] for i in s.split(' ')])
```

## 75. Sort Colors (List, 3 Pointers) (Amazon 9, Microsoft Onsite 5, Facebook 5)
O(N)  
O(1)


```python
class Solution:
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return
        
        l = 0
        cur = 0
        r = len(nums) - 1

        while cur <= r:
            if nums[cur] == 0:
                nums[cur], nums[l] = nums[l], nums[cur]
                cur += 1
                l += 1
            elif nums[cur] == 1:
                cur += 1
            elif nums[cur] == 2:
                nums[cur], nums[r] = nums[r], nums[cur]
                r -= 1
```

## Cyclic Sort  
O(N)  
O(1)


```python
def sort(nums): # 0-n
    i = 0
    while i < len(nums):
        if i  == nums[i]:
            i += 1
            
        else:
            j = nums[i] 
            nums[i], nums[j] = nums[j], nums[i]  # swap
            
    return nums

A = [3,5,6,2,1,0,4]
sort(A)
```




    [0, 1, 2, 3, 4, 5, 6]




```python
def sort(nums): # 1-n
    i = 0
    while i < len(nums):
        if i + 1 == nums[i]:
            i += 1
            
        else:
            j = nums[i] - 1
            nums[i], nums[j] = nums[j], nums[i]  # swap
            
    return nums

nums = [1, 5, 6, 4, 3, 2]
A = [5,6,1,4,3,2]
sort(A)
```




    [1, 2, 3, 4, 5, 6]




```python
def cyclic_sort(nums): # 0 to n
    i = 0
    while i < len(nums):
        j = nums[i]
        if nums[i] == nums[j]:
            i += 1

        else:
            nums[i], nums[j] = nums[j], nums[i]  # swap
            
    return nums       

nums = [3,5,6,2,1,0,4]
cyclic_sort(nums)
```




    [0, 1, 2, 3, 4, 5, 6]




```python
def cyclic_sort(nums): # 1 to n
    i = 0
    while i < len(nums):
        j = nums[i] - 1
        if nums[i] == nums[j]:
            i += 1
        else:
            nums[i], nums[j] = nums[j], nums[i]  # swap
    return nums

# nums = [1,3,4,2]
# nums = [2, 3, 4, 1, 5, 6]
nums = [1, 5, 6, 4, 3, 2]
cyclic_sort(nums)
```




    [1, 2, 3, 4, 5, 6]



## Reorder array according to the given indexes (Google Phone)   
https://leetcode.com/discuss/interview-question/309656/Google-or-Reorder-array-according-to-the-given-indexes


```python
def sort(A, B):
    i = 0
    while i < len(B):
        if i == B[i]:
            i += 1
            
        else:
            j = B[i] 
            B[i], B[j] = B[j], B[i]  # swap
            A[i], A[j] = A[j], A[i]
    return A

```


```python
# Input: nums = [10, 11, 12], indexes = [1, 0, 2]
# Output: [11, 10, 12]

def sort(A, B):
    i = 0
    while i <= len(B) - 1:
        j = B[i] 
        if B[i] == B[j]: 
            i += 1           
            
        else:
            B[i], B[j] = B[j], B[i]
            A[i], A[j] = A[j], A[i]
            
    return A      
```


```python
A = [24, 56, 74, -23, 87, 91]#[10, 11, 12]
B = [1, 2, 3, 0, 4, 5]#[1, 0, 2]

# Input: nums = [24, 56, 74, -23, 87, 91], indexes = [1, 2, 3, 0, 4, 5]
# Output: [56, 74, -23, 24, 87, 89]
sort(A,B)
```




    [-23, 24, 56, 74, 87, 91]



## 287. Find the Duplicate Number (List. Pointers) (Amazon 7, Google 5, Microsoft Onsite 4)


```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums):
            if i + 1 == nums[i]:
                i += 1
                
            else:
                j = nums[i] - 1
                if nums[i] == nums[j]:  # we have found the duplicate
                    return nums[i]

                else:  
                    nums[i], nums[j] = nums[j], nums[i]  # swap
                    

        return -1
```


```python
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # The "tortoise and hare" step.  We start at the end of the array and try
        # to find an intersection point in the cycle.
        slow, fast = 0, 0
        # Keep advancing 'slow' by one step and 'fast' by two steps until they
        # meet inside the loop.
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        # Start up another pointer from the end of the array and march it forward
        # until it hits the pointer inside the array.
        finder = 0
        while True:
            slow   = nums[slow]
            finder = nums[finder]
            # If the two hit, the intersection index is the duplicate element.
            if slow == finder:
                return slow
```


```python
class Solution:
    def findDuplicate(self, nums):
        seen = set()
        for num in nums:
            if num in seen:
                return num
            seen.add(num)
```

## Minimum Swaps to Sort Array (Google Phone)


```python
array = [2,3,5,1,4]
```


```python
def minimumSwaps(array):
    swap = 0
    for i in range(len(array)):
        if i + 1 != array[i]:
            tmp = i
            
            while i + 1 != array[tmp]:
                tmp += 1
                
            array[i], array[tmp] = array[tmp], array[i]
            swap += 1
            
    return swap

minimumSwaps(array)
```




    4




```python
def sort(nums): # 1-n
    i = 0
    swap = 0
    while i < len(nums):
        if i + 1 == nums[i]:
            i += 1
            
        else:
            j = nums[i] - 1
            nums[i], nums[j] = nums[j], nums[i]  # swap
            swap += 1
            
    return swap

sort(array)
```




    4




```python
public class Solution {
    static int minimumSwaps(int[] array) {
        int n = array.length - 1;
        int minSwaps = 0;
        for (int i = 0; i < n; i++) {
            if (i < array[i] - 1) {
                swap(array, i, Math.min(n, array[i] - 1));
                minSwaps++;
                i--;
            }
        }
        return minSwaps;
    }

```


```python
def minimum(array):
    swap = 0
    for i in range(len(array)):
        if i < array[i] - 1:
            x = min(len(array)-1, array[i]-1)
            array[i], array[x] = array[x], array[i]
            swap += 1
            i -= 1
            
    return swap
```


```python
def m(array):
    swap = 0
    idx = 0
    for i in range(len(array)):
        if array[i] != i + 1:
            for j in range(i+1, len(array)):
                if array[j] == i + 1:
                    idx = j
                    break
                    
            array[i], array[idx] = array[idx], array[i]
            swap += 1
            
    return swap
```


```python
def mini(arr):
    total_swaps = 0
    start = 0
    while start < len(arr):
        if arr[start] == start + 1:
            start += 1
            continue
        arr[arr[start] - 1], arr[start] = arr[start], arr[arr[start] - 1]
        total_swaps += 1
    return total_swaps
```


```python
import heapq
def minSwaps(nums):
    dic = {}
    for i in range(len(nums)):
        dic[nums[i]] = i
    
    heap = nums[::]
    heapq.heapify(heap)

    swaps = 0
    for i in range(len(nums)):
        smallest = heapq.heappop(heap)

       # check if previous swappes luckily made the array sorted
        if nums[i] != smallest:
            cur = nums[i] # needed to update the dic two lines below
            nums[i], nums[dic[smallest]] = nums[dic[smallest]], nums[i]
            dic[smallest], dic[cur] = dic[cur], dic[smallest]
            swaps += 1

    return swaps
```


```python
array = [5,1,3,2]
minSwaps(array)
```


```python
def alternatingSort(a):
    b = [a[0]] * len(a)
    
    index = -1
    for i in range(1, len(a), 2):
        
        b[i] = a[index]
        index -= 1
        
    index2 = 1
    for i in range(2, len(a), 2):
        b[i] = a[index2]
        
        index2 += 1
        
    for i in range(0, len(b)-1):
        if b[i] >= b[i+1]:
            return False
    
    print(b)
    return True 
```


```python
from collections import Counter
def mergeStrings(s1, s2):
    dic1 = Counter(s1)
    dic2 = Counter(s2)
    
    print('dic1', dic1)
    print('dic2', dic2)
    
    res = []
    
    i = 0
    j = 0
    while i <= len(s1) -1 and j <= len(s2) -1:
        if dic1[s1[i]] == dic2[s2[j]]:
            if s1[i] <= s2[j]:
                res.append(s1[i])
                i += 1

            else:
                res.append(s2[j])
                j += 1
                
        elif dic1[s1[i]] > dic2[s2[j]]:
            res.append(s2[j])
            j += 1
            
        elif dic1[s1[i]] < dic2[s2[j]]:
            res.append(s1[i])
            i += 1
            
    while i <= len(s1) - 1:
        res.append(s1[i])
        i += 1
    while j <= len(s2) - 1:
        res.append(s2[j])
        j += 1
            
            
    return ''.join(res)

s1 = 'abbc'
s2 = 'def'
mergeStrings(s1, s2)
```

    dic1 Counter({'b': 2, 'a': 1, 'c': 1})
    dic2 Counter({'d': 1, 'e': 1, 'f': 1})





    'adefbbc'



## 280. Wiggle Sort (String)


```python
class Solution:
    def wiggleSort(self, nums):
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums)):
            if i % 2 == 0 and nums[i] > nums[i-1] or i % 2 == 1 and nums[i] < nums[i-1]:
                nums[i], nums[i-1] = nums[i-1], nums[i]
```

## 969. Pancake Sorting (Amazon 3, Facebook 3, Microsoft 2)


```python
# 首先说一下核心思路，就是先找到当前最大值，然后将最大值翻转到数组最后一位。
# 以3241举例。
# 1.先找到当前最大的数4，
# 2.将4及其之前的数进行翻转,
# 3.将整个数组（不包括比当前最大值大的值）进行翻转

class Solution:
    def pancakeSort(self, A: List[int]) -> List[int]:
        if not A:
            return
        
        res = []
        sort = sorted(A)
        tmp = A.copy()

        i = len(A)
        while sort != A:
            maximum = max(tmp)
            tmp.remove(maximum)
            index = A.index(maximum) + 1
            A[:index] = A[:index][::-1]

            A[:i] = A[:i][::-1]
            i -= 1
            
            res.append(index)
            res.append(len(tmp))
            
        return res
```

## Remove Duplicate Spaces (Google Phone)


```python
def removeDup(chars):
    res = []
    count = 0
    for c in chars:
        if c != ' ':
            res.append(c)
            
        else:
            count += 1
            if count == 1:
                res.append(c)
                
    return res
```


```python
def removeDup(chars):
    l = 0
    r = 0
    while r < len(chars):
        if chars[r] != ' ': 
            chars[l] = chars[r]
            l += 1
            r += 1
            
        elif chars[r] == ' ':
            chars[l] = chars[r]
            while r < len(chars) and chars[r] == ' ':
                r += 1
                
            l += 1
                
input : {'a', 'b', ' ', ' ', 'c' } Output : {'a', 'b', ' ', 'c'}
input : {'a', 'b', ' ', ' ', ' ' } Output : {'a', 'b', ' '}
```

## Remove Chairs in String (Google Phone)
https://leetcode.com/discuss/interview-question/407622/Google-or-Phone-Screen-or-Remove-Chars-in-String

Q1. Use writing_index and through the string if you meet some char except 'a' rewrite string at position write_index and increase by one, so on. In the end, just substr the whole array from the begin to write_index; S[0:write_index]

Q2. Need to use an additional array to replace 'b' to 'bee'. Firstly, count of b and init additional array with length of len(A) + countB * 2 and after that just go over the array and replace 'b' to 'bee'.


```python
def moveChars(self, chars):
    pos = 0
    for i in range(len(chars)):
        if chars[i] != 'a':
            chars[pos], chars[i] = chars[i], chars[pos]
            pos += 1
```

## 283. Move Zeros (List, Pointer) (Facebook 8, Amazon 7, Microsoft 3 Phone)
O(N)  
O(1)  


```python
class Solution:
    def moveZeroes(self, nums):
        """
        Do not return anything, modify nums in-place instead.
        """
        pos = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[pos], nums[i] = nums[i], nums[pos]
                pos += 1
```

## 调整数组顺序使奇数位于偶数前面


```python
def move(nums):
    pos = 0
    for i in range(len(nums)):
        if nums[i] % 2:
            nums[pos], nums[i] = nums[i], nums[pos]
            pos += 1
            
nums = [1, 2, 3, 4]
move(nums)
nums
```




    [1, 3, 2, 4]



## 26. Remove Duplicates from Sorted Array (List, Pointer) (Microsoft 6, Google 4, Facebook 6)

- 时间复杂度: O(N)- 空间复杂度: O(1)


```python
class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        i = 0
        for j in range(1,len(nums)):
            if nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
        return i + 1
```


```python
array = [1, 2, 2, 3, 4]
s = Solution()
s.removeDuplicates(array)
```




    4




```python
class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        
        res = 1
        i = 0
        for j in range(len(nums)):
            if nums[j] != nums[i]:
                res += 1
                i += 1
                nums[j], nums[i] = nums[i], nums[j]
                
        return res
```


```python
class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        for n in nums:
            if i < 1 or n > nums[i - 1]:
                nums[i] = n
                i += 1
        return i
```

### Other Pointers

## 881. Boats to Save People (Amazon 4)


```python
class Solution:
    def numRescueBoats(self, people, limit):
        """
        :type people: List[int]
        :type limit: int
        :rtype: int
        """
        people.sort(reverse = True)
        
        i, j = 0, len(people) - 1
        ans = 0
        while i <= j:
            ans += 1
            if people[i] + people[j] <= limit:
                j -= 1
                
            i += 1
        return ans
```

## Watering Plants (Google OA)

Input: plants = [2, 4, 5, 1, 2], capacity = 6
Output: 17
Explanation:
First you water plants[0] and plants[1] (2 steps).
Then you have to go back to refill (2 steps) and water plants[2] and plants[3] (4 steps).
Then again you have to refill (4 steps) and water plants[4] (5 steps).
So 2 + 2 + 4 + 4 + 5 = 17.


```python
class Solution:
    def solution(self, plants, capacity):
        cur = capacity
        i = 0
        res = 0
        while i <= len(plants) -1:
            if cur >= plants[i]:
#                 plants[i] = 0
                cur -= plants[i]
                res += 1
                i += 1
                
            elif cur < plants[i]:
                cur = capacity - plants[i]
#                 plants[i] = 0
                res += i * 2 + 1
                i += 1
        
        return res
```


```python
s = Solution()
s.solution([2,2,1,1,2], 3)
```


```python
class Solution:
    def solution(self, flowers, cap1, cap2):
        res = 2
        me = cap1
        friend = cap2
        
        mid = len(flowers)//2
        
        for i in range(mid):
            if me < flowers[i]:
                me = cap1
                res += 1
            me -= flowers[i]
            
        flowers2 = flowers[::-1]
        for i in range(len(mid):
            if friend < flowers2[i]:
                friend = cap2
                res += 1
            friend -= flowers[i]

        if len(flowers) % 2:
            if (me + friend) < flowers[mid]:
                res += 1
                
        return res
```


```python
flowers = [2,4,5,1,2]
s = Solution()
s.solution(flowers, 5, 7)
```

## 413. Arithmetic Slices  


```python
class Solution:
    def numberOfArithmeticSlices(self, array):
        res = 0    
        dp =0

        i = 0
        while i <= len(array) - 3:
            if array[i+1] - array[i] == array[i+2] - array[i+1]:
                dp += 1
                res += dp

            else:
                dp = 0

            i += 1

        if res < 1000000000:
            return res  

        else:
            return -1 
    
s = Solution()

a = [1,3,5,7,9]
b = [-1, 1, 3, 3, 3, 2, 3, 2, 1, 0]
s.numberOfArithmeticSlices(b)
```




    5



## Particle Velocity (Microsoft OA)


```python
def solution(array):
    if len(array) < 3:
        return -1
    
    res = 0    
    dp =0

    i = 0
    while i <= len(array) - 3:
        if array[i+1] - array[i] == array[i+2] - array[i+1]:
            dp += 1
            res += dp

        else:
            dp = 0

        i += 1
        
        
    if res < 1000000000:
        return res  
    
    else:
        return -1
    
a = [-1, 1, 3, 3, 3, 2, 3, 2, 1, 0]
solution(a)
```




    5



## Min Moves to Obtain String Without 3 Identical Consecutive Letters (Microsoft OA)


```python
def solution(s):
    moves = 0
    
    i = 0
    while i < len(s):
        length = 1
        
        while i + 1 < len(s) and s[i] == s[i+1]:
            length += 1
            i += 1
            
        moves += length // 3 
        
        i += 1
        
    return moves
```


```python
#array = 'baaabbaabbba'
array = 'baababb'
solution(array)
```




    0



## Longest Semi-Alternating Substring (Microsoft OA)


```python
def solution(s):
    l = 0
    r = 2
    length = 0
    while r < len(s):
        if r - l > 1:
            if s[r] == s[r-1] and s[r] == s[r-2]:
                length = max(length, r - l)
                l += 1
                r = l
    
        r += 1
        
    if not length:
        return len(s)
            
    return length
           
a = 'baaabbabbb'
b = 'babba'
c = 'abaaaa'
solution(b)
```




    5



## Longest Substring Without 3 Contiguous Occurrences of Letter (Microsoft OA)


```python
def solution(s):
    l = 0
    r = 2
    length = 0
    ans = ''
    while r < len(s):
        if r - l > 1:
            if s[r] == s[r-1] and s[r] == s[r-2]:
                
                if r - l > length:
                    length = max(length, r - l)
                    ans = s[l:r]
                l += 1
                r = l
    
        r += 1
        
    if not length:
        return len(s)
            
    return ans

a = 'baaabbabbb'
b = 'babba'
c = 'abaaaa'
solution(a)
```




    'aabbabb'



## 209 Minimum Size Subarray Sum (List, 2 Poinsters) (Google 7, Facebook 3, Amazon 3)


```python
# sliding window
# O(n)
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums : 
            return 0
        
        left = 0
        cur = 0
        res = float("inf")
        for right in range(len(nums)):
            cur += nums[right]
            
            while cur >= s:
                res = min(res, right - left + 1)
                cur -= nums[left]
                left += 1
                
        return res if res != float("inf") else 0
```


```python
# binary search
# O(nlogn)
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums :           
            return 0
        # 求前缀和
        for i in range(1, len(nums)):
            nums[i] += nums[i - 1]
        #print(nums)
        # 总和都小于 s 时候
        if nums[-1] < s: return 0
        res = float("inf")
        nums = [0] + nums
        for i in range(1, len(nums)):
            if nums[i] - s >= 0:
                # 二分查找
                loc = bisect.bisect_left(nums, nums[i] - s)
                if nums[i] - nums[loc] >= s:
                    res = min(res, i - loc)
                    continue
                if loc > 0:
                    res = min(res, i - loc + 1)
        return res

```

## Min Swaps to make Palindrome (Microsoft OA)


```python
def solution(s):
    length = len(s)
    res = 0
    
    array = list(s)
    
    for i in range(length//2):
        found = False
        
        for j in range(length-i-1, i+1, -1):
            if array[i] != array[j]:
                continue
                
            found = True
            
            for k in range(j, length-i-1):
                array[k], array[k+1] = array[k+1], array[k]
                res += 1
                
            break
            
            if not found and length%2 == 1:
                for k in range(i, n//2):
                    array[k], array[k+1] = array[k+1], array[k]
                    res += 1
                    
    if not res:
        return -1
    else:
        return res
    
a = 'mamad'
b = 'aabb'
solution(b)
```




    -1




```python
static int MainSwapPalindrome(string inputStr)
        {
            int n = inputStr.Length;
            int result = 0;
            char[] items = inputStr.ToCharArray();
            for(int i = 0; i< n/2; i++)
            {
                bool found = false;
                for(int j = n-i-1; j >= i+1; j--)
                {
                    if (items[i] != items[j])
                        continue;
                    found = true;
                    for(int k = j; k < n - i - 1; k++)
                    {
                        char temp = items[k];
                        items[k] = items[k+1];
                        items[k+1] = temp;
                        result++;                        
                    }
                    break;
                }
                if(!found && n%2 == 1)
                {
                    for(int k = i; k < n/2; k++)
                    {
                        char temp = items[k];
                        items[k] = items[k + 1];
                        items[k + 1] = temp;
                        result++;
                    }
                }
            }
            return result == 0 ? -1 : result;
        }
```

## 763. Partition Labels (String. Dic, 2 Pointers) (Amazon OA 18)

Time Complexity: O(N), where N is the length of S.  
O(N)


```python
class Solution:
    def partitionLabels(self, S):
        """
        :type S: str
        :rtype: List[int]
        """
        if not S:
            return True
        
        dic = {}
        for i, c in enumerate(S):
            dic[c] = i
            
        l, r = 0, 0
        res = []
        for i, c in enumerate(S):
            r = max(r, dic[c])
            
            if i == r:
                res.append(r - l + 1)
                l = i + 1
                
        return res
```


```python
s = Solution()
s.partitionLabels("ababcbacadefegdehijhklij")

```

## 187. Repeated DNA Sequences (Str. Set) (Amazon 5)


```python
from collections import Counter
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if not s:
            return []
        
        if len(s) < 11:
            return []
        
        seen = set()
        res = set()
        
        l = 0
        r = 10
        
        while r <= len(s):
            if s[l:r] in seen:
                res.add(s[l:r])
            
            else:
                seen.add(s[l:r])
            
            l += 1
            r += 1
```

## 953. Verifying an Alien Dictionary (Facebook 108)


```python
class Solution(object):
    def isAlienSorted(self, words, order):
        """
        :type words: List[str]
        :type order: str
        :rtype: bool
        """
        order_index = {c: i for i, c in enumerate(order)}

        for i in xrange(len(words) - 1):
            word1 = words[i]
            word2 = words[i+1]

            # Find the first difference word1[k] != word2[k].
            for k in xrange(min(len(word1), len(word2))):
                # If they compare badly, it's not sorted.
                if word1[k] != word2[k]:
                    if order_index[word1[k]] > order_index[word2[k]]:
                        return False
                    break
            else:
                # If we didn't find a first difference, the
                # words are like ("app", "apple").
                if len(word1) > len(word2):
                    return False

        return True
```

## 670. Maximum Swap (Facebook 14)


```python
class Solution:
    def maximumSwap(self, num):
        """
        :type num: int
        :rtype: int
        """
        num = list(map(int, str(num)))
        digitIndex = {x: i for i, x in enumerate(num)}
        
        for i, x in enumerate(num):
            for d in range(9, x, -1):
                if d in digitIndex and digitIndex[d] > i:
                    j = digitIndex[d]
                    num[i], num[j] = num[j], num[i]
                    return int(''.join(map(str, num)))
                
        return int(''.join(map(str, num)))
```

### Sliding Window-Dic, Pointer

## 30. Substring with Concatenation of All Words (String List. Sliding Window-Dic, Pointer) (Amazon 6, Microsoft 5)


```python
class Solution: 
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        if not s or len(s)==0 or not words or len(words)==0:
            return []

        dic, res = {}, []
        for i in words:
            if i not in dic:
                dic[i] = 1
            else:
                dic[i] += 1
                
        one = len(words[0])
        total = len(words) * one
        
        for i in range(len(s) - total + 1):
            tmp = s[i:i+total]
            d = dic.copy()
            # 将子串和临时字典进行比较
            for j in range(0, len(tmp), one):
                # 从子串tmp_str中取出one长度的子串，看是否出现在临时字典中
                # 如果是就将临时字典记录的频率-1，如果不在就跳出循环
                key = tmp[j:j+one]
                if key in d:
                    d[key] -= 1
                    if d[key]==0:
                        d.pop(key)
                else:
                    break

            if not d:
                res.append(i)
        return res
```


```python
from collections import Counter
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        
        if not s or not words:
            return []
        
        length = len(words[0])
        total = len(words) * length
        words = Counter(words)
        res = []
        
        for i in range(len(s) - total + 1):
            tmp = s[i:i + total]
            array = []
            for j in range(0, total, length):
                array.append(tmp[j:j + length])
                
            if Counter(array) == words:
                res.append(i)
                
        return res
```


```python
class Solution:
    def findSubstring(self, s, words):
         """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        if not s or not words:
            return []
        
        words.sort()
        length = len(words[0])
        totallen = len(words) * len(words[0])
        res = []
        
        for i in range(len(s) - totallen + 1):
            string = s[i:i + totallen]
            List = []
            index = 0
            
            while index < len(string):
                List.append(string[index:index + length])
                index += length
            if sorted(List) == words:
                res.append(i)
        return res
```

## 3. Longest Substring Without Repeating Characters (String. Sliding Window-Dic, Pointer) (Amazon Onsite 27, Microsoft 13, Google 11, Facebook 9)
- 时间复杂度: O(N)- 空间复杂度: O(N)


```python
# 使用 dic 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 dic 中出现重复字符时，开始移动 left 缩小窗口，如此往复

from collections import Counter
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        
        l = 0
        r = 0
        counter = 0 # counter 为当前子串中相同字符的数量
        res = 0
        
        dic = Counter()
        
        while r < len(s):
            if dic[s[r]] > 0:
                counter += 1
                
            dic[s[r]] += 1
            r += 1
            
            while counter:
                if dic[s[l]] > 1:
                    counter -= 1
                    
                dic[s[l]] -= 1
                l += 1
                
            res = max(res, r - l)
        return res
```

时间复杂度: O(N)  
O(N)


```python
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        # start 指针指向的是当前子串首字符在 input 中对应的index
        cur = 0 
        res = 0
        dic = {}
        
        for i, c in enumerate(s):
            cur = max(cur, dic.get(c, -1) + 1) # 找到当前子串新的起点
            res = max(res, i - cur + 1) # 当前子串满足条件了，更新结果
#             print(dic.get(s[i],-1)+1,start,res)
            dic[c] = i # 将当前字符与其在 input 中的 index 记录下来
        return res

s = Solution()
s.lengthOfLongestSubstring('abcabcbb')
```

    0 0 1
    0 0 2
    0 0 3
    1 1 3
    2 2 3
    3 3 3
    5 5 3
    7 7 3





    3



## 159. Longest Substring with At Most Two Distinct Characters (String. Sliding Window-Dic, Pointer) (Google 2, Facebook 2)
- 时间复杂度: O(N)- 空间复杂度: O(N)


```python
from collections import Counter
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s):
        """
        :type s: str
        :rtype: int
        """   
        
        
        l = 0
        r = 0
        counter = 0
        res = 0
        
        dic = Counter()
        
        while r <= len(s) - 1:
            if dic[s[r]] == 0:
                counter += 1
            
            dic[s[r]] += 1
            r += 1
            
            while counter > 2:
                if dic[s[l]] == 1:
                    counter -= 1
                    
                dic[s[l]] -= 1
                l += 1
                
            res = max(res, r - l)
        return res
```

O(N)  
O(N)


```python
from collections import defaultdict
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        n = len(s) 
        if n < 3:
            return n
        
        # sliding window left and right pointers
        left, right = 0, 0
        # hashmap character -> its rightmost position 
        # in the sliding window
        hashmap = defaultdict()

        max_len = 2
        
        while right < n:
            # slidewindow contains less than 3 characters
            if len(hashmap) < 3:
                hashmap[s[right]] = right
                right += 1

            # slidewindow contains 3 characters
            if len(hashmap) == 3:
                # delete the leftmost character
                del_idx = min(hashmap.values())
                del hashmap[s[del_idx]]
                # move left pointer of the slidewindow
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len
```

## 340 Longest Substring with At Most K(Two) Distinct Characters (String. Sliding Window-Dic, Pointers) (Facebook 11, Amazon 9, Microsoft 5, Google 5)
- 时间复杂度: O(N)- 空间复杂度: O(N)


```python
from collections import Counter
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        
        l = 0
        r = 0
        counter = 0
        res = 0
        
        dic = Counter()
        
        while r <= len(s) - 1:
            if dic[s[r]] == 0:
                counter += 1
                
            dic[s[r]] += 1
            r += 1
            
            while counter > k:
                if dic[s[l]] == 1:
                    counter -= 1
                
                dic[s[l]] -= 1
                l += 1
                
            res = max(res, r - l)
        return res
```

## 76. Minimum Window Substring (String. Sliding Window-Dic, Pointer) (Facebook 20, Amazon 13, Linkedin 9, Google 11, Microsoft 6) (Hard)

O(s+t)  
O(s+t)


```python
from collections import Counter
class Solution:
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        
        l = 0
        r = 0
        
        counter = len(t)
        min_len = float("inf")
        res = ""
        
        dic = Counter(t)
        
        while r < len(s):
            if dic[s[r]] > 0:
                counter -= 1
                
            dic[s[r]] -= 1
            r += 1
            
            while counter == 0:
                if min_len > r - l:
                    min_len = r - l
                    res = s[l:r]
                    
                if dic[s[l]] == 0:
                    counter += 1
                    
                dic[s[l]] += 1
                l += 1
        return res
```


```python
a = Solution()
s = "ADOBECODEBANC"
t = "ABC"
a.minWindow(s,t)
```

    dict_t= Counter({'A': 1, 'B': 1, 'C': 1})
    required= 3
    character= A
    window_counts= {'A': 1}
    formed= 1
    
    character= D
    window_counts= {'A': 1, 'D': 1}
    
    character= O
    window_counts= {'A': 1, 'D': 1, 'O': 1}
    
    character= B
    window_counts= {'A': 1, 'D': 1, 'O': 1, 'B': 1}
    formed= 2
    
    character= E
    window_counts= {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1}
    
    character= C
    window_counts= {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1, 'C': 1}
    formed= 3
    ans= (6, 0, 5)
    
    character= O
    window_counts= {'A': 0, 'D': 1, 'O': 2, 'B': 1, 'E': 1, 'C': 1}
    
    character= D
    window_counts= {'A': 0, 'D': 2, 'O': 2, 'B': 1, 'E': 1, 'C': 1}
    
    character= E
    window_counts= {'A': 0, 'D': 2, 'O': 2, 'B': 1, 'E': 2, 'C': 1}
    
    character= B
    window_counts= {'A': 0, 'D': 2, 'O': 2, 'B': 2, 'E': 2, 'C': 1}
    
    character= A
    window_counts= {'A': 1, 'D': 2, 'O': 2, 'B': 2, 'E': 2, 'C': 1}
    formed= 3
    
    character= N
    window_counts= {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1, 'C': 0, 'N': 1}
    
    character= C
    window_counts= {'A': 1, 'D': 1, 'O': 1, 'B': 1, 'E': 1, 'C': 1, 'N': 1}
    formed= 3
    ans= (5, 8, 12)
    ans= (4, 9, 12)
    





    'BANC'



## 438. Find All Anagrams in a String (String. Sliding Window-Dic, Pointer) (Facebook 29, Microsoft 4, Google 4, Amazon 3)


```python
from collections import Counter
class Solution():
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
#         vector<int> res;
#         int left = 0, right = 0;
#         unordered_map<char, int> needs;
#         unordered_map<char, int> window;
#         for (char c : t) needs[c]++;
#         int match = 0;

#         while (right < s.size()) {
#             char c1 = s[right];
#             if (needs.count(c1)) {
#                 window[c1]++;
#                 if (window[c1] == needs[c1])
#                     match++;
#             }
#             right++;

#             while (match == needs.size()) {
#                 // 如果 window 的大小合适
#                 // 就把起始索引 left 加入结果
#                 if (right - left == t.size()) {
#                     res.push_back(left);
#                 }
#                 char c2 = s[left];
#                 if (needs.count(c2)) {
#                     window[c2]--;
#                     if (window[c2] < needs[c2])
#                         match--;
#                 }
#                 left++;
#             }
#         }
#         return res;
#         }

        res = []
        l = 0
        r = 0
        needs = Counter()
        dic = Counter()
        for c in p:
            needs[c] += 1
            
        match = 0
        
        while r < len(s):
            c1 = s[r]
            if c1 in needs:
                dic[c1] += 1
                if dic[c1] == needs[c1]:
                    match += 1
                    
            r += 1
            
            while match == len(needs):
                # 如果 window 的大小合适
                # 就把起始索引 left 加入结果
                if r - l == len(p):
                    res.append(l)
                    
                c2 = s[l]    
                if c2 in needs:
                    dic[c2] -= 1
                    if dic[c2] < needs[c2]:
                        match -= 1
                        
                l -= 1
                
        return res
```

## 567. Permutation in String (Facebook 4, Google 3, Microsoft 2)


```python
# 和438题解法几乎一摸一样，只是修改下返回条件即可
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function(s, p) {
    let res = [];
    let left = 0,right = 0;
    let needs = {},windows = {};
    let match = 0;
    for(let i = 0;i < p.length;i++){
        needs[p[i]] ? needs[p[i]]++ : needs[p[i]] = 1;
    }
    let needsLen = Object.keys(needs).length;
    while(right < s.length){
        let c1 = s[right];
        if(needs[c1]){
            windows[c1] ? windows[c1]++ : windows[c1] = 1;
            if(windows[c1] === needs[c1]){
                match++;
            }
        }
        right++;
        while(match === needsLen){
            if(right - left === p.length){
                res.push(left);
            }
            let c2 = s[left];
            if(needs[c2]){
                windows[c2]--;
                if(windows[c2] < needs[c2]){
                    match--;
                }
            }
            left++;
        }
    }
    return res;
};
```

## 727. Minimum Window Subsequence (Google 11, Microsoft 3)


```python

```
